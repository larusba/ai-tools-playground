"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/neo4j-driver-core";
exports.ids = ["vendor-chunks/neo4j-driver-core"];
exports.modules = {

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/auth-token-manager.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/auth-token-manager.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.staticAuthTokenManager = exports.authTokenManagers = exports.AuthTokenAndExpiration = void 0;\nvar auth_1 = __importDefault(__webpack_require__(/*! ./auth */ \"(rsc)/./node_modules/neo4j-driver-core/lib/auth.js\"));\nvar internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/index.js\");\n/**\n * Interface for the piece of software responsible for keeping track of current active {@link AuthToken} across the driver.\n * @interface\n * @since 5.14\n */\nvar AuthTokenManager = /** @class */ (function () {\n    function AuthTokenManager() {\n    }\n    /**\n     * Returns a valid token.\n     *\n     * **Warning**: This method must only ever return auth information belonging to the same identity.\n     * Switching identities using the `AuthTokenManager` is undefined behavior.\n     *\n     * @returns {Promise<AuthToken>|AuthToken} The valid auth token or a promise for a valid auth token\n     */\n    AuthTokenManager.prototype.getToken = function () {\n        throw new Error('Not Implemented');\n    };\n    /**\n     * Handles an error notification emitted by the server if a security error happened.\n     *\n     * @param {AuthToken} token The expired token.\n     * @param {`Neo.ClientError.Security.${string}`} securityErrorCode the security error code returned by the server\n     * @return {boolean} whether the exception was handled by the manager, so the driver knows if it can be retried..\n     */\n    AuthTokenManager.prototype.handleSecurityException = function (token, securityErrorCode) {\n        throw new Error('Not implemented');\n    };\n    return AuthTokenManager;\n}());\nexports[\"default\"] = AuthTokenManager;\n/**\n * Interface which defines an {@link AuthToken} with an expiration data time associated\n * @interface\n * @since 5.14\n */\nvar AuthTokenAndExpiration = /** @class */ (function () {\n    function AuthTokenAndExpiration() {\n        /**\n         * The {@link AuthToken} used for authenticate connections.\n         *\n         * @type {AuthToken}\n         * @see {auth}\n         */\n        this.token = auth_1.default.none();\n        /**\n         * The expected expiration date of the auth token.\n         *\n         * This information will be used for triggering the auth token refresh\n         * in managers created with {@link authTokenManagers#bearer}.\n         *\n         * If this value is not defined, the {@link AuthToken} will be considered valid\n         * until a `Neo.ClientError.Security.TokenExpired` error happens.\n         *\n         * @type {Date|undefined}\n         */\n        this.expiration = undefined;\n    }\n    return AuthTokenAndExpiration;\n}());\nexports.AuthTokenAndExpiration = AuthTokenAndExpiration;\n/**\n * Defines the object which holds the common {@link AuthTokenManager} used in the Driver\n */\nvar AuthTokenManagers = /** @class */ (function () {\n    function AuthTokenManagers() {\n    }\n    /**\n     * Creates a {@link AuthTokenManager} for handle {@link AuthToken} which is expires.\n     *\n     * **Warning**: `tokenProvider` must only ever return auth information belonging to the same identity.\n     * Switching identities using the `AuthTokenManager` is undefined behavior.\n     *\n     * @param {object} param0 - The params\n     * @param {function(): Promise<AuthTokenAndExpiration>} param0.tokenProvider - Retrieves a new valid auth token.\n     * Must only ever return auth information belonging to the same identity.\n     * @returns {AuthTokenManager} The temporal auth data manager.\n     */\n    AuthTokenManagers.prototype.bearer = function (_a) {\n        var tokenProvider = _a.tokenProvider;\n        if (typeof tokenProvider !== 'function') {\n            throw new TypeError(\"tokenProvider should be function, but got: \".concat(typeof tokenProvider));\n        }\n        return new ExpirationBasedAuthTokenManager(tokenProvider, [\n            'Neo.ClientError.Security.Unauthorized',\n            'Neo.ClientError.Security.TokenExpired'\n        ]);\n    };\n    /**\n     * Creates a {@link AuthTokenManager} for handle {@link AuthToken} and password rotation.\n     *\n     * **Warning**: `tokenProvider` must only ever return auth information belonging to the same identity.\n     * Switching identities using the `AuthTokenManager` is undefined behavior.\n     *\n     * @param {object} param0 - The params\n     * @param {function(): Promise<AuthToken>} param0.tokenProvider - Retrieves a new valid auth token.\n     * Must only ever return auth information belonging to the same identity.\n     * @returns {AuthTokenManager} The basic auth data manager.\n     */\n    AuthTokenManagers.prototype.basic = function (_a) {\n        var _this = this;\n        var tokenProvider = _a.tokenProvider;\n        if (typeof tokenProvider !== 'function') {\n            throw new TypeError(\"tokenProvider should be function, but got: \".concat(typeof tokenProvider));\n        }\n        return new ExpirationBasedAuthTokenManager(function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = {};\n                        return [4 /*yield*/, tokenProvider()];\n                    case 1: return [2 /*return*/, (_a.token = _b.sent(), _a)];\n                }\n            });\n        }); }, ['Neo.ClientError.Security.Unauthorized']);\n    };\n    return AuthTokenManagers;\n}());\n/**\n * Holds the common {@link AuthTokenManagers} used in the Driver.\n */\nvar authTokenManagers = new AuthTokenManagers();\nexports.authTokenManagers = authTokenManagers;\nObject.freeze(authTokenManagers);\n/**\n * Create a {@link AuthTokenManager} for handle static {@link AuthToken}\n *\n * @private\n * @param {param} args - The args\n * @param {AuthToken} args.authToken - The static auth token which will always used in the driver.\n * @returns {AuthTokenManager} The temporal auth data manager.\n */\nfunction staticAuthTokenManager(_a) {\n    var authToken = _a.authToken;\n    return new StaticAuthTokenManager(authToken);\n}\nexports.staticAuthTokenManager = staticAuthTokenManager;\nvar TokenRefreshObservable = /** @class */ (function () {\n    function TokenRefreshObservable(_subscribers) {\n        if (_subscribers === void 0) { _subscribers = []; }\n        this._subscribers = _subscribers;\n    }\n    TokenRefreshObservable.prototype.subscribe = function (sub) {\n        this._subscribers.push(sub);\n    };\n    TokenRefreshObservable.prototype.onCompleted = function (data) {\n        this._subscribers.forEach(function (sub) { return sub.onCompleted(data); });\n    };\n    TokenRefreshObservable.prototype.onError = function (error) {\n        this._subscribers.forEach(function (sub) { return sub.onError(error); });\n    };\n    return TokenRefreshObservable;\n}());\nvar ExpirationBasedAuthTokenManager = /** @class */ (function () {\n    function ExpirationBasedAuthTokenManager(_tokenProvider, _handledSecurityCodes, _currentAuthData, _refreshObservable) {\n        this._tokenProvider = _tokenProvider;\n        this._handledSecurityCodes = _handledSecurityCodes;\n        this._currentAuthData = _currentAuthData;\n        this._refreshObservable = _refreshObservable;\n    }\n    ExpirationBasedAuthTokenManager.prototype.getToken = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(this._currentAuthData === undefined ||\n                            (this._currentAuthData.expiration !== undefined &&\n                                this._currentAuthData.expiration < new Date()))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this._refreshAuthToken()];\n                    case 1:\n                        _b.sent();\n                        _b.label = 2;\n                    case 2: return [2 /*return*/, (_a = this._currentAuthData) === null || _a === void 0 ? void 0 : _a.token];\n                }\n            });\n        });\n    };\n    ExpirationBasedAuthTokenManager.prototype.handleSecurityException = function (token, securityErrorCode) {\n        var _a;\n        if (this._handledSecurityCodes.includes(securityErrorCode)) {\n            if (internal_1.util.equals(token, (_a = this._currentAuthData) === null || _a === void 0 ? void 0 : _a.token)) {\n                this._scheduleRefreshAuthToken();\n            }\n            return true;\n        }\n        return false;\n    };\n    ExpirationBasedAuthTokenManager.prototype._scheduleRefreshAuthToken = function (observer) {\n        var _this = this;\n        if (this._refreshObservable === undefined) {\n            this._currentAuthData = undefined;\n            this._refreshObservable = new TokenRefreshObservable();\n            Promise.resolve(this._tokenProvider())\n                .then(function (data) {\n                var _a;\n                _this._currentAuthData = data;\n                (_a = _this._refreshObservable) === null || _a === void 0 ? void 0 : _a.onCompleted(data);\n            })\n                .catch(function (error) {\n                var _a;\n                (_a = _this._refreshObservable) === null || _a === void 0 ? void 0 : _a.onError(error);\n            })\n                .finally(function () {\n                _this._refreshObservable = undefined;\n            });\n        }\n        if (observer !== undefined) {\n            this._refreshObservable.subscribe(observer);\n        }\n    };\n    ExpirationBasedAuthTokenManager.prototype._refreshAuthToken = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {\n                            _this._scheduleRefreshAuthToken({\n                                onCompleted: resolve,\n                                onError: reject\n                            });\n                        })];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    return ExpirationBasedAuthTokenManager;\n}());\nvar StaticAuthTokenManager = /** @class */ (function () {\n    function StaticAuthTokenManager(_authToken) {\n        this._authToken = _authToken;\n    }\n    StaticAuthTokenManager.prototype.getToken = function () {\n        return this._authToken;\n    };\n    StaticAuthTokenManager.prototype.handleSecurityException = function (_, __) {\n        return false;\n    };\n    return StaticAuthTokenManager;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2F1dGgtdG9rZW4tbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLHlCQUF5QixHQUFHLDhCQUE4QjtBQUMzRiw2QkFBNkIsbUJBQU8sQ0FBQyxrRUFBUTtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBWTtBQUNyQztBQUNBLHdGQUF3RixpQkFBaUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLDRCQUE0QixPQUFPLEdBQUc7QUFDckQsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZTtBQUNmO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0Esa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0JBQStCO0FBQ3BFO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5QjtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0IsWUFBWSxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSw2Q0FBNkM7QUFDNUQ7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0IsWUFBWSxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYSx3QkFBd0IsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxXQUFXO0FBQ3RCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsK0JBQStCO0FBQ2xGO0FBQ0E7QUFDQSxtREFBbUQsNEJBQTRCO0FBQy9FO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvYXV0aC10b2tlbi1tYW5hZ2VyLmpzPzRlZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdGF0aWNBdXRoVG9rZW5NYW5hZ2VyID0gZXhwb3J0cy5hdXRoVG9rZW5NYW5hZ2VycyA9IGV4cG9ydHMuQXV0aFRva2VuQW5kRXhwaXJhdGlvbiA9IHZvaWQgMDtcbnZhciBhdXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXV0aFwiKSk7XG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBwaWVjZSBvZiBzb2Z0d2FyZSByZXNwb25zaWJsZSBmb3Iga2VlcGluZyB0cmFjayBvZiBjdXJyZW50IGFjdGl2ZSB7QGxpbmsgQXV0aFRva2VufSBhY3Jvc3MgdGhlIGRyaXZlci5cbiAqIEBpbnRlcmZhY2VcbiAqIEBzaW5jZSA1LjE0XG4gKi9cbnZhciBBdXRoVG9rZW5NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dGhUb2tlbk1hbmFnZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB2YWxpZCB0b2tlbi5cbiAgICAgKlxuICAgICAqICoqV2FybmluZyoqOiBUaGlzIG1ldGhvZCBtdXN0IG9ubHkgZXZlciByZXR1cm4gYXV0aCBpbmZvcm1hdGlvbiBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgaWRlbnRpdHkuXG4gICAgICogU3dpdGNoaW5nIGlkZW50aXRpZXMgdXNpbmcgdGhlIGBBdXRoVG9rZW5NYW5hZ2VyYCBpcyB1bmRlZmluZWQgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRoVG9rZW4+fEF1dGhUb2tlbn0gVGhlIHZhbGlkIGF1dGggdG9rZW4gb3IgYSBwcm9taXNlIGZvciBhIHZhbGlkIGF1dGggdG9rZW5cbiAgICAgKi9cbiAgICBBdXRoVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYW4gZXJyb3Igbm90aWZpY2F0aW9uIGVtaXR0ZWQgYnkgdGhlIHNlcnZlciBpZiBhIHNlY3VyaXR5IGVycm9yIGhhcHBlbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRoVG9rZW59IHRva2VuIFRoZSBleHBpcmVkIHRva2VuLlxuICAgICAqIEBwYXJhbSB7YE5lby5DbGllbnRFcnJvci5TZWN1cml0eS4ke3N0cmluZ31gfSBzZWN1cml0eUVycm9yQ29kZSB0aGUgc2VjdXJpdHkgZXJyb3IgY29kZSByZXR1cm5lZCBieSB0aGUgc2VydmVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZXhjZXB0aW9uIHdhcyBoYW5kbGVkIGJ5IHRoZSBtYW5hZ2VyLCBzbyB0aGUgZHJpdmVyIGtub3dzIGlmIGl0IGNhbiBiZSByZXRyaWVkLi5cbiAgICAgKi9cbiAgICBBdXRoVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVTZWN1cml0eUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICh0b2tlbiwgc2VjdXJpdHlFcnJvckNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBBdXRoVG9rZW5NYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEF1dGhUb2tlbk1hbmFnZXI7XG4vKipcbiAqIEludGVyZmFjZSB3aGljaCBkZWZpbmVzIGFuIHtAbGluayBBdXRoVG9rZW59IHdpdGggYW4gZXhwaXJhdGlvbiBkYXRhIHRpbWUgYXNzb2NpYXRlZFxuICogQGludGVyZmFjZVxuICogQHNpbmNlIDUuMTRcbiAqL1xudmFyIEF1dGhUb2tlbkFuZEV4cGlyYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXV0aFRva2VuQW5kRXhwaXJhdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgQXV0aFRva2VufSB1c2VkIGZvciBhdXRoZW50aWNhdGUgY29ubmVjdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtBdXRoVG9rZW59XG4gICAgICAgICAqIEBzZWUge2F1dGh9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2VuID0gYXV0aF8xLmRlZmF1bHQubm9uZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGV4cGVjdGVkIGV4cGlyYXRpb24gZGF0ZSBvZiB0aGUgYXV0aCB0b2tlbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIHRyaWdnZXJpbmcgdGhlIGF1dGggdG9rZW4gcmVmcmVzaFxuICAgICAgICAgKiBpbiBtYW5hZ2VycyBjcmVhdGVkIHdpdGgge0BsaW5rIGF1dGhUb2tlbk1hbmFnZXJzI2JlYXJlcn0uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoaXMgdmFsdWUgaXMgbm90IGRlZmluZWQsIHRoZSB7QGxpbmsgQXV0aFRva2VufSB3aWxsIGJlIGNvbnNpZGVyZWQgdmFsaWRcbiAgICAgICAgICogdW50aWwgYSBgTmVvLkNsaWVudEVycm9yLlNlY3VyaXR5LlRva2VuRXhwaXJlZGAgZXJyb3IgaGFwcGVucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0RhdGV8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5leHBpcmF0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gQXV0aFRva2VuQW5kRXhwaXJhdGlvbjtcbn0oKSk7XG5leHBvcnRzLkF1dGhUb2tlbkFuZEV4cGlyYXRpb24gPSBBdXRoVG9rZW5BbmRFeHBpcmF0aW9uO1xuLyoqXG4gKiBEZWZpbmVzIHRoZSBvYmplY3Qgd2hpY2ggaG9sZHMgdGhlIGNvbW1vbiB7QGxpbmsgQXV0aFRva2VuTWFuYWdlcn0gdXNlZCBpbiB0aGUgRHJpdmVyXG4gKi9cbnZhciBBdXRoVG9rZW5NYW5hZ2VycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdXRoVG9rZW5NYW5hZ2VycygpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBBdXRoVG9rZW5NYW5hZ2VyfSBmb3IgaGFuZGxlIHtAbGluayBBdXRoVG9rZW59IHdoaWNoIGlzIGV4cGlyZXMuXG4gICAgICpcbiAgICAgKiAqKldhcm5pbmcqKjogYHRva2VuUHJvdmlkZXJgIG11c3Qgb25seSBldmVyIHJldHVybiBhdXRoIGluZm9ybWF0aW9uIGJlbG9uZ2luZyB0byB0aGUgc2FtZSBpZGVudGl0eS5cbiAgICAgKiBTd2l0Y2hpbmcgaWRlbnRpdGllcyB1c2luZyB0aGUgYEF1dGhUb2tlbk1hbmFnZXJgIGlzIHVuZGVmaW5lZCBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTAgLSBUaGUgcGFyYW1zXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBQcm9taXNlPEF1dGhUb2tlbkFuZEV4cGlyYXRpb24+fSBwYXJhbTAudG9rZW5Qcm92aWRlciAtIFJldHJpZXZlcyBhIG5ldyB2YWxpZCBhdXRoIHRva2VuLlxuICAgICAqIE11c3Qgb25seSBldmVyIHJldHVybiBhdXRoIGluZm9ybWF0aW9uIGJlbG9uZ2luZyB0byB0aGUgc2FtZSBpZGVudGl0eS5cbiAgICAgKiBAcmV0dXJucyB7QXV0aFRva2VuTWFuYWdlcn0gVGhlIHRlbXBvcmFsIGF1dGggZGF0YSBtYW5hZ2VyLlxuICAgICAqL1xuICAgIEF1dGhUb2tlbk1hbmFnZXJzLnByb3RvdHlwZS5iZWFyZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHRva2VuUHJvdmlkZXIgPSBfYS50b2tlblByb3ZpZGVyO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuUHJvdmlkZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0b2tlblByb3ZpZGVyIHNob3VsZCBiZSBmdW5jdGlvbiwgYnV0IGdvdDogXCIuY29uY2F0KHR5cGVvZiB0b2tlblByb3ZpZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFeHBpcmF0aW9uQmFzZWRBdXRoVG9rZW5NYW5hZ2VyKHRva2VuUHJvdmlkZXIsIFtcbiAgICAgICAgICAgICdOZW8uQ2xpZW50RXJyb3IuU2VjdXJpdHkuVW5hdXRob3JpemVkJyxcbiAgICAgICAgICAgICdOZW8uQ2xpZW50RXJyb3IuU2VjdXJpdHkuVG9rZW5FeHBpcmVkJ1xuICAgICAgICBdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgQXV0aFRva2VuTWFuYWdlcn0gZm9yIGhhbmRsZSB7QGxpbmsgQXV0aFRva2VufSBhbmQgcGFzc3dvcmQgcm90YXRpb24uXG4gICAgICpcbiAgICAgKiAqKldhcm5pbmcqKjogYHRva2VuUHJvdmlkZXJgIG11c3Qgb25seSBldmVyIHJldHVybiBhdXRoIGluZm9ybWF0aW9uIGJlbG9uZ2luZyB0byB0aGUgc2FtZSBpZGVudGl0eS5cbiAgICAgKiBTd2l0Y2hpbmcgaWRlbnRpdGllcyB1c2luZyB0aGUgYEF1dGhUb2tlbk1hbmFnZXJgIGlzIHVuZGVmaW5lZCBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbTAgLSBUaGUgcGFyYW1zXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBQcm9taXNlPEF1dGhUb2tlbj59IHBhcmFtMC50b2tlblByb3ZpZGVyIC0gUmV0cmlldmVzIGEgbmV3IHZhbGlkIGF1dGggdG9rZW4uXG4gICAgICogTXVzdCBvbmx5IGV2ZXIgcmV0dXJuIGF1dGggaW5mb3JtYXRpb24gYmVsb25naW5nIHRvIHRoZSBzYW1lIGlkZW50aXR5LlxuICAgICAqIEByZXR1cm5zIHtBdXRoVG9rZW5NYW5hZ2VyfSBUaGUgYmFzaWMgYXV0aCBkYXRhIG1hbmFnZXIuXG4gICAgICovXG4gICAgQXV0aFRva2VuTWFuYWdlcnMucHJvdG90eXBlLmJhc2ljID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0b2tlblByb3ZpZGVyID0gX2EudG9rZW5Qcm92aWRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblByb3ZpZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9rZW5Qcm92aWRlciBzaG91bGQgYmUgZnVuY3Rpb24sIGJ1dCBnb3Q6IFwiLmNvbmNhdCh0eXBlb2YgdG9rZW5Qcm92aWRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXhwaXJhdGlvbkJhc2VkQXV0aFRva2VuTWFuYWdlcihmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9rZW5Qcm92aWRlcigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgKF9hLnRva2VuID0gX2Iuc2VudCgpLCBfYSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfSwgWydOZW8uQ2xpZW50RXJyb3IuU2VjdXJpdHkuVW5hdXRob3JpemVkJ10pO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGhUb2tlbk1hbmFnZXJzO1xufSgpKTtcbi8qKlxuICogSG9sZHMgdGhlIGNvbW1vbiB7QGxpbmsgQXV0aFRva2VuTWFuYWdlcnN9IHVzZWQgaW4gdGhlIERyaXZlci5cbiAqL1xudmFyIGF1dGhUb2tlbk1hbmFnZXJzID0gbmV3IEF1dGhUb2tlbk1hbmFnZXJzKCk7XG5leHBvcnRzLmF1dGhUb2tlbk1hbmFnZXJzID0gYXV0aFRva2VuTWFuYWdlcnM7XG5PYmplY3QuZnJlZXplKGF1dGhUb2tlbk1hbmFnZXJzKTtcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIEF1dGhUb2tlbk1hbmFnZXJ9IGZvciBoYW5kbGUgc3RhdGljIHtAbGluayBBdXRoVG9rZW59XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7cGFyYW19IGFyZ3MgLSBUaGUgYXJnc1xuICogQHBhcmFtIHtBdXRoVG9rZW59IGFyZ3MuYXV0aFRva2VuIC0gVGhlIHN0YXRpYyBhdXRoIHRva2VuIHdoaWNoIHdpbGwgYWx3YXlzIHVzZWQgaW4gdGhlIGRyaXZlci5cbiAqIEByZXR1cm5zIHtBdXRoVG9rZW5NYW5hZ2VyfSBUaGUgdGVtcG9yYWwgYXV0aCBkYXRhIG1hbmFnZXIuXG4gKi9cbmZ1bmN0aW9uIHN0YXRpY0F1dGhUb2tlbk1hbmFnZXIoX2EpIHtcbiAgICB2YXIgYXV0aFRva2VuID0gX2EuYXV0aFRva2VuO1xuICAgIHJldHVybiBuZXcgU3RhdGljQXV0aFRva2VuTWFuYWdlcihhdXRoVG9rZW4pO1xufVxuZXhwb3J0cy5zdGF0aWNBdXRoVG9rZW5NYW5hZ2VyID0gc3RhdGljQXV0aFRva2VuTWFuYWdlcjtcbnZhciBUb2tlblJlZnJlc2hPYnNlcnZhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuUmVmcmVzaE9ic2VydmFibGUoX3N1YnNjcmliZXJzKSB7XG4gICAgICAgIGlmIChfc3Vic2NyaWJlcnMgPT09IHZvaWQgMCkgeyBfc3Vic2NyaWJlcnMgPSBbXTsgfVxuICAgICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IF9zdWJzY3JpYmVycztcbiAgICB9XG4gICAgVG9rZW5SZWZyZXNoT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmVycy5wdXNoKHN1Yik7XG4gICAgfTtcbiAgICBUb2tlblJlZnJlc2hPYnNlcnZhYmxlLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViLm9uQ29tcGxldGVkKGRhdGEpOyB9KTtcbiAgICB9O1xuICAgIFRva2VuUmVmcmVzaE9ic2VydmFibGUucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIub25FcnJvcihlcnJvcik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRva2VuUmVmcmVzaE9ic2VydmFibGU7XG59KCkpO1xudmFyIEV4cGlyYXRpb25CYXNlZEF1dGhUb2tlbk1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwaXJhdGlvbkJhc2VkQXV0aFRva2VuTWFuYWdlcihfdG9rZW5Qcm92aWRlciwgX2hhbmRsZWRTZWN1cml0eUNvZGVzLCBfY3VycmVudEF1dGhEYXRhLCBfcmVmcmVzaE9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5Qcm92aWRlciA9IF90b2tlblByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9oYW5kbGVkU2VjdXJpdHlDb2RlcyA9IF9oYW5kbGVkU2VjdXJpdHlDb2RlcztcbiAgICAgICAgdGhpcy5fY3VycmVudEF1dGhEYXRhID0gX2N1cnJlbnRBdXRoRGF0YTtcbiAgICAgICAgdGhpcy5fcmVmcmVzaE9ic2VydmFibGUgPSBfcmVmcmVzaE9ic2VydmFibGU7XG4gICAgfVxuICAgIEV4cGlyYXRpb25CYXNlZEF1dGhUb2tlbk1hbmFnZXIucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX2N1cnJlbnRBdXRoRGF0YSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuX2N1cnJlbnRBdXRoRGF0YS5leHBpcmF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEF1dGhEYXRhLmV4cGlyYXRpb24gPCBuZXcgRGF0ZSgpKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcmVmcmVzaEF1dGhUb2tlbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2EgPSB0aGlzLl9jdXJyZW50QXV0aERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b2tlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXhwaXJhdGlvbkJhc2VkQXV0aFRva2VuTWFuYWdlci5wcm90b3R5cGUuaGFuZGxlU2VjdXJpdHlFeGNlcHRpb24gPSBmdW5jdGlvbiAodG9rZW4sIHNlY3VyaXR5RXJyb3JDb2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZWRTZWN1cml0eUNvZGVzLmluY2x1ZGVzKHNlY3VyaXR5RXJyb3JDb2RlKSkge1xuICAgICAgICAgICAgaWYgKGludGVybmFsXzEudXRpbC5lcXVhbHModG9rZW4sIChfYSA9IHRoaXMuX2N1cnJlbnRBdXRoRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRva2VuKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlUmVmcmVzaEF1dGhUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRXhwaXJhdGlvbkJhc2VkQXV0aFRva2VuTWFuYWdlci5wcm90b3R5cGUuX3NjaGVkdWxlUmVmcmVzaEF1dGhUb2tlbiA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcmVmcmVzaE9ic2VydmFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEF1dGhEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaE9ic2VydmFibGUgPSBuZXcgVG9rZW5SZWZyZXNoT2JzZXJ2YWJsZSgpO1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Rva2VuUHJvdmlkZXIoKSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3VycmVudEF1dGhEYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5fcmVmcmVzaE9ic2VydmFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkNvbXBsZXRlZChkYXRhKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5fcmVmcmVzaE9ic2VydmFibGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZWZyZXNoT2JzZXJ2YWJsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoT2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHBpcmF0aW9uQmFzZWRBdXRoVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5fcmVmcmVzaEF1dGhUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY2hlZHVsZVJlZnJlc2hBdXRoVG9rZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlZDogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cGlyYXRpb25CYXNlZEF1dGhUb2tlbk1hbmFnZXI7XG59KCkpO1xudmFyIFN0YXRpY0F1dGhUb2tlbk1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljQXV0aFRva2VuTWFuYWdlcihfYXV0aFRva2VuKSB7XG4gICAgICAgIHRoaXMuX2F1dGhUb2tlbiA9IF9hdXRoVG9rZW47XG4gICAgfVxuICAgIFN0YXRpY0F1dGhUb2tlbk1hbmFnZXIucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0aFRva2VuO1xuICAgIH07XG4gICAgU3RhdGljQXV0aFRva2VuTWFuYWdlci5wcm90b3R5cGUuaGFuZGxlU2VjdXJpdHlFeGNlcHRpb24gPSBmdW5jdGlvbiAoXywgX18pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0F1dGhUb2tlbk1hbmFnZXI7XG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/auth-token-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/auth.js":
/*!****************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/auth.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar json_1 = __webpack_require__(/*! ./json */ \"(rsc)/./node_modules/neo4j-driver-core/lib/json.js\");\n/**\n * @property {function(username: string, password: string, realm: ?string)} basic the function to create a\n * basic authentication token.\n * @property {function(base64EncodedTicket: string)} kerberos the function to create a Kerberos authentication token.\n * Accepts a single string argument - base64 encoded Kerberos ticket.\n * @property {function(base64EncodedTicket: string)} bearer the function to create a Bearer authentication token.\n * Accepts a single string argument - base64 encoded Bearer ticket.\n * @property {function(principal: string, credentials: string, realm: string, scheme: string, parameters: ?object)} custom\n * the function to create a custom authentication token.\n */\nvar auth = {\n    basic: function (username, password, realm) {\n        if (realm != null) {\n            return {\n                scheme: 'basic',\n                principal: username,\n                credentials: password,\n                realm: realm\n            };\n        }\n        else {\n            return { scheme: 'basic', principal: username, credentials: password };\n        }\n    },\n    kerberos: function (base64EncodedTicket) {\n        return {\n            scheme: 'kerberos',\n            principal: '',\n            credentials: base64EncodedTicket\n        };\n    },\n    bearer: function (base64EncodedToken) {\n        return {\n            scheme: 'bearer',\n            credentials: base64EncodedToken\n        };\n    },\n    none: function () {\n        return {\n            scheme: 'none'\n        };\n    },\n    custom: function (principal, credentials, realm, scheme, parameters) {\n        var output = {\n            scheme: scheme,\n            principal: principal\n        };\n        if (isNotEmpty(credentials)) {\n            output.credentials = credentials;\n        }\n        if (isNotEmpty(realm)) {\n            output.realm = realm;\n        }\n        if (isNotEmpty(parameters)) {\n            try {\n                (0, json_1.stringify)(parameters);\n            }\n            catch (e) {\n                throw (0, error_1.newError)('Circular references in custom auth token parameters', undefined, e);\n            }\n            output.parameters = parameters;\n        }\n        return output;\n    }\n};\nfunction isNotEmpty(value) {\n    return !(value === null ||\n        value === undefined ||\n        value === '' ||\n        (Object.getPrototypeOf(value) === Object.prototype && Object.keys(value).length === 0));\n}\nexports[\"default\"] = auth;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2F1dGguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCO0FBQ0EsY0FBYyw4REFBOEQ7QUFDNUU7QUFDQSxjQUFjLHVDQUF1QztBQUNyRDtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0EsY0FBYyxzR0FBc0c7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvYXV0aC5qcz8yMDQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG52YXIganNvbl8xID0gcmVxdWlyZShcIi4vanNvblwiKTtcbi8qKlxuICogQHByb3BlcnR5IHtmdW5jdGlvbih1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCByZWFsbTogP3N0cmluZyl9IGJhc2ljIHRoZSBmdW5jdGlvbiB0byBjcmVhdGUgYVxuICogYmFzaWMgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJhc2U2NEVuY29kZWRUaWNrZXQ6IHN0cmluZyl9IGtlcmJlcm9zIHRoZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBLZXJiZXJvcyBhdXRoZW50aWNhdGlvbiB0b2tlbi5cbiAqIEFjY2VwdHMgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IC0gYmFzZTY0IGVuY29kZWQgS2VyYmVyb3MgdGlja2V0LlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihiYXNlNjRFbmNvZGVkVGlja2V0OiBzdHJpbmcpfSBiZWFyZXIgdGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIEJlYXJlciBhdXRoZW50aWNhdGlvbiB0b2tlbi5cbiAqIEFjY2VwdHMgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IC0gYmFzZTY0IGVuY29kZWQgQmVhcmVyIHRpY2tldC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24ocHJpbmNpcGFsOiBzdHJpbmcsIGNyZWRlbnRpYWxzOiBzdHJpbmcsIHJlYWxtOiBzdHJpbmcsIHNjaGVtZTogc3RyaW5nLCBwYXJhbWV0ZXJzOiA/b2JqZWN0KX0gY3VzdG9tXG4gKiB0aGUgZnVuY3Rpb24gdG8gY3JlYXRlIGEgY3VzdG9tIGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICovXG52YXIgYXV0aCA9IHtcbiAgICBiYXNpYzogZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCwgcmVhbG0pIHtcbiAgICAgICAgaWYgKHJlYWxtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1lOiAnYmFzaWMnLFxuICAgICAgICAgICAgICAgIHByaW5jaXBhbDogdXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIHJlYWxtOiByZWFsbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtZTogJ2Jhc2ljJywgcHJpbmNpcGFsOiB1c2VybmFtZSwgY3JlZGVudGlhbHM6IHBhc3N3b3JkIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGtlcmJlcm9zOiBmdW5jdGlvbiAoYmFzZTY0RW5jb2RlZFRpY2tldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1lOiAna2VyYmVyb3MnLFxuICAgICAgICAgICAgcHJpbmNpcGFsOiAnJyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBiYXNlNjRFbmNvZGVkVGlja2V0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBiZWFyZXI6IGZ1bmN0aW9uIChiYXNlNjRFbmNvZGVkVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtZTogJ2JlYXJlcicsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogYmFzZTY0RW5jb2RlZFRva2VuXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBub25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWU6ICdub25lJ1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3VzdG9tOiBmdW5jdGlvbiAocHJpbmNpcGFsLCBjcmVkZW50aWFscywgcmVhbG0sIHNjaGVtZSwgcGFyYW1ldGVycykge1xuICAgICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICAgICAgc2NoZW1lOiBzY2hlbWUsXG4gICAgICAgICAgICBwcmluY2lwYWw6IHByaW5jaXBhbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNOb3RFbXB0eShjcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIG91dHB1dC5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05vdEVtcHR5KHJlYWxtKSkge1xuICAgICAgICAgICAgb3V0cHV0LnJlYWxtID0gcmVhbG07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm90RW1wdHkocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgKDAsIGpzb25fMS5zdHJpbmdpZnkpKHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JfMS5uZXdFcnJvcikoJ0NpcmN1bGFyIHJlZmVyZW5jZXMgaW4gY3VzdG9tIGF1dGggdG9rZW4gcGFyYW1ldGVycycsIHVuZGVmaW5lZCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59O1xuZnVuY3Rpb24gaXNOb3RFbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiAhKHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgIHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgdmFsdWUgPT09ICcnIHx8XG4gICAgICAgIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDApKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGF1dGg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/auth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/bookmark-manager.js":
/*!****************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/bookmark-manager.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bookmarkManager = void 0;\n/**\n * Interface for the piece of software responsible for keeping track of current active bookmarks accross the driver.\n * @interface\n * @since 5.0\n */\nvar BookmarkManager = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     */\n    function BookmarkManager() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * Method called when the bookmarks get updated when a transaction finished.\n     *\n     * This method will be called when auto-commit queries finish and when explicit transactions\n     * get committed.\n     *\n     * @param {Iterable<string>} previousBookmarks The bookmarks used when starting the transaction\n     * @param {Iterable<string>} newBookmarks The new bookmarks received at the end of the transaction.\n     * @returns {void}\n    */\n    BookmarkManager.prototype.updateBookmarks = function (previousBookmarks, newBookmarks) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error('Not implemented');\n            });\n        });\n    };\n    /**\n     * Method called by the driver to get the bookmarks.\n     *\n     * @returns {Iterable<string>} The set of bookmarks\n     */\n    BookmarkManager.prototype.getBookmarks = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error('Not implemented');\n            });\n        });\n    };\n    return BookmarkManager;\n}());\nexports[\"default\"] = BookmarkManager;\n/**\n * @typedef {Object} BookmarkManagerConfig\n *\n * @since 5.0\n * @property {Iterable<string>} [initialBookmarks] Defines the initial set of bookmarks. The key is the database name and the values are the bookmarks.\n * @property {function():Promise<Iterable<string>>} [bookmarksSupplier] Called for supplying extra bookmarks to the BookmarkManager\n * @property {function(bookmarks: Iterable<string>): Promise<void>} [bookmarksConsumer] Called when the set of bookmarks  get updated\n */\n/**\n * Provides an configured {@link BookmarkManager} instance.\n *\n * @since 5.0\n * @param {BookmarkManagerConfig} [config={}]\n * @returns {BookmarkManager}\n */\nfunction bookmarkManager(config) {\n    if (config === void 0) { config = {}; }\n    var initialBookmarks = new Set(config.initialBookmarks);\n    return new Neo4jBookmarkManager(initialBookmarks, config.bookmarksSupplier, config.bookmarksConsumer);\n}\nexports.bookmarkManager = bookmarkManager;\nvar Neo4jBookmarkManager = /** @class */ (function () {\n    function Neo4jBookmarkManager(_bookmarks, _bookmarksSupplier, _bookmarksConsumer) {\n        this._bookmarks = _bookmarks;\n        this._bookmarksSupplier = _bookmarksSupplier;\n        this._bookmarksConsumer = _bookmarksConsumer;\n    }\n    Neo4jBookmarkManager.prototype.updateBookmarks = function (previousBookmarks, newBookmarks) {\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarks, previousBookmarks_1, previousBookmarks_1_1, bm, newBookmarks_1, newBookmarks_1_1, bm;\n            var e_1, _a, e_2, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        bookmarks = this._bookmarks;\n                        try {\n                            for (previousBookmarks_1 = __values(previousBookmarks), previousBookmarks_1_1 = previousBookmarks_1.next(); !previousBookmarks_1_1.done; previousBookmarks_1_1 = previousBookmarks_1.next()) {\n                                bm = previousBookmarks_1_1.value;\n                                bookmarks.delete(bm);\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (previousBookmarks_1_1 && !previousBookmarks_1_1.done && (_a = previousBookmarks_1.return)) _a.call(previousBookmarks_1);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                        try {\n                            for (newBookmarks_1 = __values(newBookmarks), newBookmarks_1_1 = newBookmarks_1.next(); !newBookmarks_1_1.done; newBookmarks_1_1 = newBookmarks_1.next()) {\n                                bm = newBookmarks_1_1.value;\n                                bookmarks.add(bm);\n                            }\n                        }\n                        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                        finally {\n                            try {\n                                if (newBookmarks_1_1 && !newBookmarks_1_1.done && (_b = newBookmarks_1.return)) _b.call(newBookmarks_1);\n                            }\n                            finally { if (e_2) throw e_2.error; }\n                        }\n                        if (!(typeof this._bookmarksConsumer === 'function')) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this._bookmarksConsumer(__spreadArray([], __read(bookmarks), false))];\n                    case 1:\n                        _c.sent();\n                        _c.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Neo4jBookmarkManager.prototype.getBookmarks = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarks, suppliedBookmarks, suppliedBookmarks_1, suppliedBookmarks_1_1, bm;\n            var e_3, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        bookmarks = new Set(this._bookmarks);\n                        if (!(typeof this._bookmarksSupplier === 'function')) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this._bookmarksSupplier()];\n                    case 1:\n                        suppliedBookmarks = (_a = _c.sent()) !== null && _a !== void 0 ? _a : [];\n                        try {\n                            for (suppliedBookmarks_1 = __values(suppliedBookmarks), suppliedBookmarks_1_1 = suppliedBookmarks_1.next(); !suppliedBookmarks_1_1.done; suppliedBookmarks_1_1 = suppliedBookmarks_1.next()) {\n                                bm = suppliedBookmarks_1_1.value;\n                                bookmarks.add(bm);\n                            }\n                        }\n                        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                        finally {\n                            try {\n                                if (suppliedBookmarks_1_1 && !suppliedBookmarks_1_1.done && (_b = suppliedBookmarks_1.return)) _b.call(suppliedBookmarks_1);\n                            }\n                            finally { if (e_3) throw e_3.error; }\n                        }\n                        _c.label = 2;\n                    case 2: return [2 /*return*/, __spreadArray([], __read(bookmarks), false)];\n                }\n            });\n        });\n    };\n    return Neo4jBookmarkManager;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2Jvb2ttYXJrLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlO0FBQ2Y7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsc0NBQXNDO0FBQ3BELGNBQWMsc0RBQXNEO0FBQ3BFO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QixVQUFVO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksNkJBQTZCO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLG9IQUFvSCx3QkFBd0I7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksNkJBQTZCO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvYm9va21hcmstbWFuYWdlci5qcz84MzhjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9va21hcmtNYW5hZ2VyID0gdm9pZCAwO1xuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBwaWVjZSBvZiBzb2Z0d2FyZSByZXNwb25zaWJsZSBmb3Iga2VlcGluZyB0cmFjayBvZiBjdXJyZW50IGFjdGl2ZSBib29rbWFya3MgYWNjcm9zcyB0aGUgZHJpdmVyLlxuICogQGludGVyZmFjZVxuICogQHNpbmNlIDUuMFxuICovXG52YXIgQm9va21hcmtNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm9va21hcmtNYW5hZ2VyKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgY2FsbGVkIHdoZW4gdGhlIGJvb2ttYXJrcyBnZXQgdXBkYXRlZCB3aGVuIGEgdHJhbnNhY3Rpb24gZmluaXNoZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB3aGVuIGF1dG8tY29tbWl0IHF1ZXJpZXMgZmluaXNoIGFuZCB3aGVuIGV4cGxpY2l0IHRyYW5zYWN0aW9uc1xuICAgICAqIGdldCBjb21taXR0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0l0ZXJhYmxlPHN0cmluZz59IHByZXZpb3VzQm9va21hcmtzIFRoZSBib29rbWFya3MgdXNlZCB3aGVuIHN0YXJ0aW5nIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7SXRlcmFibGU8c3RyaW5nPn0gbmV3Qm9va21hcmtzIFRoZSBuZXcgYm9va21hcmtzIHJlY2VpdmVkIGF0IHRoZSBlbmQgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICovXG4gICAgQm9va21hcmtNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVCb29rbWFya3MgPSBmdW5jdGlvbiAocHJldmlvdXNCb29rbWFya3MsIG5ld0Jvb2ttYXJrcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCBjYWxsZWQgYnkgdGhlIGRyaXZlciB0byBnZXQgdGhlIGJvb2ttYXJrcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZTxzdHJpbmc+fSBUaGUgc2V0IG9mIGJvb2ttYXJrc1xuICAgICAqL1xuICAgIEJvb2ttYXJrTWFuYWdlci5wcm90b3R5cGUuZ2V0Qm9va21hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBCb29rbWFya01hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQm9va21hcmtNYW5hZ2VyO1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCb29rbWFya01hbmFnZXJDb25maWdcbiAqXG4gKiBAc2luY2UgNS4wXG4gKiBAcHJvcGVydHkge0l0ZXJhYmxlPHN0cmluZz59IFtpbml0aWFsQm9va21hcmtzXSBEZWZpbmVzIHRoZSBpbml0aWFsIHNldCBvZiBib29rbWFya3MuIFRoZSBrZXkgaXMgdGhlIGRhdGFiYXNlIG5hbWUgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSBib29rbWFya3MuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6UHJvbWlzZTxJdGVyYWJsZTxzdHJpbmc+Pn0gW2Jvb2ttYXJrc1N1cHBsaWVyXSBDYWxsZWQgZm9yIHN1cHBseWluZyBleHRyYSBib29rbWFya3MgdG8gdGhlIEJvb2ttYXJrTWFuYWdlclxuICogQHByb3BlcnR5IHtmdW5jdGlvbihib29rbWFya3M6IEl0ZXJhYmxlPHN0cmluZz4pOiBQcm9taXNlPHZvaWQ+fSBbYm9va21hcmtzQ29uc3VtZXJdIENhbGxlZCB3aGVuIHRoZSBzZXQgb2YgYm9va21hcmtzICBnZXQgdXBkYXRlZFxuICovXG4vKipcbiAqIFByb3ZpZGVzIGFuIGNvbmZpZ3VyZWQge0BsaW5rIEJvb2ttYXJrTWFuYWdlcn0gaW5zdGFuY2UuXG4gKlxuICogQHNpbmNlIDUuMFxuICogQHBhcmFtIHtCb29rbWFya01hbmFnZXJDb25maWd9IFtjb25maWc9e31dXG4gKiBAcmV0dXJucyB7Qm9va21hcmtNYW5hZ2VyfVxuICovXG5mdW5jdGlvbiBib29rbWFya01hbmFnZXIoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgdmFyIGluaXRpYWxCb29rbWFya3MgPSBuZXcgU2V0KGNvbmZpZy5pbml0aWFsQm9va21hcmtzKTtcbiAgICByZXR1cm4gbmV3IE5lbzRqQm9va21hcmtNYW5hZ2VyKGluaXRpYWxCb29rbWFya3MsIGNvbmZpZy5ib29rbWFya3NTdXBwbGllciwgY29uZmlnLmJvb2ttYXJrc0NvbnN1bWVyKTtcbn1cbmV4cG9ydHMuYm9va21hcmtNYW5hZ2VyID0gYm9va21hcmtNYW5hZ2VyO1xudmFyIE5lbzRqQm9va21hcmtNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5lbzRqQm9va21hcmtNYW5hZ2VyKF9ib29rbWFya3MsIF9ib29rbWFya3NTdXBwbGllciwgX2Jvb2ttYXJrc0NvbnN1bWVyKSB7XG4gICAgICAgIHRoaXMuX2Jvb2ttYXJrcyA9IF9ib29rbWFya3M7XG4gICAgICAgIHRoaXMuX2Jvb2ttYXJrc1N1cHBsaWVyID0gX2Jvb2ttYXJrc1N1cHBsaWVyO1xuICAgICAgICB0aGlzLl9ib29rbWFya3NDb25zdW1lciA9IF9ib29rbWFya3NDb25zdW1lcjtcbiAgICB9XG4gICAgTmVvNGpCb29rbWFya01hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUJvb2ttYXJrcyA9IGZ1bmN0aW9uIChwcmV2aW91c0Jvb2ttYXJrcywgbmV3Qm9va21hcmtzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib29rbWFya3MsIHByZXZpb3VzQm9va21hcmtzXzEsIHByZXZpb3VzQm9va21hcmtzXzFfMSwgYm0sIG5ld0Jvb2ttYXJrc18xLCBuZXdCb29rbWFya3NfMV8xLCBibTtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgYm9va21hcmtzID0gdGhpcy5fYm9va21hcmtzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHByZXZpb3VzQm9va21hcmtzXzEgPSBfX3ZhbHVlcyhwcmV2aW91c0Jvb2ttYXJrcyksIHByZXZpb3VzQm9va21hcmtzXzFfMSA9IHByZXZpb3VzQm9va21hcmtzXzEubmV4dCgpOyAhcHJldmlvdXNCb29rbWFya3NfMV8xLmRvbmU7IHByZXZpb3VzQm9va21hcmtzXzFfMSA9IHByZXZpb3VzQm9va21hcmtzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJtID0gcHJldmlvdXNCb29rbWFya3NfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29rbWFya3MuZGVsZXRlKGJtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQm9va21hcmtzXzFfMSAmJiAhcHJldmlvdXNCb29rbWFya3NfMV8xLmRvbmUgJiYgKF9hID0gcHJldmlvdXNCb29rbWFya3NfMS5yZXR1cm4pKSBfYS5jYWxsKHByZXZpb3VzQm9va21hcmtzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobmV3Qm9va21hcmtzXzEgPSBfX3ZhbHVlcyhuZXdCb29rbWFya3MpLCBuZXdCb29rbWFya3NfMV8xID0gbmV3Qm9va21hcmtzXzEubmV4dCgpOyAhbmV3Qm9va21hcmtzXzFfMS5kb25lOyBuZXdCb29rbWFya3NfMV8xID0gbmV3Qm9va21hcmtzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJtID0gbmV3Qm9va21hcmtzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9va21hcmtzLmFkZChibSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdCb29rbWFya3NfMV8xICYmICFuZXdCb29rbWFya3NfMV8xLmRvbmUgJiYgKF9iID0gbmV3Qm9va21hcmtzXzEucmV0dXJuKSkgX2IuY2FsbChuZXdCb29rbWFya3NfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiB0aGlzLl9ib29rbWFya3NDb25zdW1lciA9PT0gJ2Z1bmN0aW9uJykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fYm9va21hcmtzQ29uc3VtZXIoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGJvb2ttYXJrcyksIGZhbHNlKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5lbzRqQm9va21hcmtNYW5hZ2VyLnByb3RvdHlwZS5nZXRCb29rbWFya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJvb2ttYXJrcywgc3VwcGxpZWRCb29rbWFya3MsIHN1cHBsaWVkQm9va21hcmtzXzEsIHN1cHBsaWVkQm9va21hcmtzXzFfMSwgYm07XG4gICAgICAgICAgICB2YXIgZV8zLCBfYjtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2ttYXJrcyA9IG5ldyBTZXQodGhpcy5fYm9va21hcmtzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiB0aGlzLl9ib29rbWFya3NTdXBwbGllciA9PT0gJ2Z1bmN0aW9uJykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fYm9va21hcmtzU3VwcGxpZXIoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBsaWVkQm9va21hcmtzID0gKF9hID0gX2Muc2VudCgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzdXBwbGllZEJvb2ttYXJrc18xID0gX192YWx1ZXMoc3VwcGxpZWRCb29rbWFya3MpLCBzdXBwbGllZEJvb2ttYXJrc18xXzEgPSBzdXBwbGllZEJvb2ttYXJrc18xLm5leHQoKTsgIXN1cHBsaWVkQm9va21hcmtzXzFfMS5kb25lOyBzdXBwbGllZEJvb2ttYXJrc18xXzEgPSBzdXBwbGllZEJvb2ttYXJrc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibSA9IHN1cHBsaWVkQm9va21hcmtzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9va21hcmtzLmFkZChibSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwbGllZEJvb2ttYXJrc18xXzEgJiYgIXN1cHBsaWVkQm9va21hcmtzXzFfMS5kb25lICYmIChfYiA9IHN1cHBsaWVkQm9va21hcmtzXzEucmV0dXJuKSkgX2IuY2FsbChzdXBwbGllZEJvb2ttYXJrc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYm9va21hcmtzKSwgZmFsc2UpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTmVvNGpCb29rbWFya01hbmFnZXI7XG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/bookmark-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/client-certificate.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/client-certificate.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.resolveCertificateProvider = exports.clientCertificateProviders = exports.RotatingClientCertificateProvider = exports.ClientCertificateProvider = void 0;\nvar json = __importStar(__webpack_require__(/*! ./json */ \"(rsc)/./node_modules/neo4j-driver-core/lib/json.js\"));\n/**\n * Represents KeyFile represented as file.\n *\n * @typedef {object} KeyFileObject\n * @property {string} path - The path of the file\n * @property {string|undefined} password - the password of the key. If none,\n * the password defined at {@link ClientCertificate} will be used.\n */\n/**\n * Holds the Client TLS certificate information.\n *\n * Browser instances of the driver should configure the certificate\n * in the system.\n *\n * Files defined in the {@link ClientCertificate#certfile}\n * and {@link ClientCertificate#keyfile} will read and loaded to\n * memory to fill the fields `cert` and `key` in security context.\n *\n * @interface\n * @see https://nodejs.org/api/tls.html#tlscreatesecurecontextoptions\n * @since 5.27\n */\nvar ClientCertificate = /** @class */ (function () {\n    function ClientCertificate() {\n        /**\n         * The path to client certificate file.\n         *\n         * @type {string|string[]}\n         */\n        this.certfile = '';\n        /**\n         * The path to the key file.\n         *\n         * @type {string|string[]|KeyFileObject|KeyFileObject[]}\n         */\n        this.keyfile = '';\n        /**\n         * The key's password.\n         *\n         * @type {string|undefined}\n         */\n        this.password = undefined;\n    }\n    return ClientCertificate;\n}());\nexports[\"default\"] = ClientCertificate;\n/**\n * Provides a client certificate to the driver for mutual TLS.\n *\n * The driver will call {@link ClientCertificateProvider#hasUpdate} to check if the client wants to update the certificate.\n * If so, it will call {@link ClientCertificateProvider#getClientCertificate} to get the new certificate.\n *\n * The certificate is only used as a second factor for authentication authenticating the client.\n * The DMBS user still needs to authenticate with an authentication token.\n *\n * All implementations of this interface must be thread-safe and non-blocking for caller threads.\n * For instance, IO operations must not be done on the calling thread.\n *\n * Note that the work done in the methods of this interface count towards the connectionAcquisition.\n * Should fetching the certificate be particularly slow, it might be necessary to increase the timeout.\n *\n * @interface\n * @since 5.27\n */\nvar ClientCertificateProvider = /** @class */ (function () {\n    function ClientCertificateProvider() {\n    }\n    /**\n     * Indicates whether the client wants the driver to update the certificate.\n     *\n     * @returns {Promise<boolean>|boolean} true if the client wants the driver to update the certificate\n     */\n    ClientCertificateProvider.prototype.hasUpdate = function () {\n        throw new Error('Not Implemented');\n    };\n    /**\n     * Returns the certificate to use for new connections.\n     *\n     * Will be called by the driver after {@link ClientCertificateProvider#hasUpdate} returned true\n     * or when the driver establishes the first connection.\n     *\n     * @returns {Promise<ClientCertificate>|ClientCertificate} the certificate to use for new connections\n     */\n    ClientCertificateProvider.prototype.getClientCertificate = function () {\n        throw new Error('Not Implemented');\n    };\n    return ClientCertificateProvider;\n}());\nexports.ClientCertificateProvider = ClientCertificateProvider;\n/**\n * Interface for  {@link ClientCertificateProvider} which provides update certificate function.\n * @interface\n * @since 5.27\n */\nvar RotatingClientCertificateProvider = /** @class */ (function (_super) {\n    __extends(RotatingClientCertificateProvider, _super);\n    function RotatingClientCertificateProvider() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Updates the certificate stored in the provider.\n     *\n     * To be called by user-code when a new client certificate is available.\n     *\n     * @param {ClientCertificate} certificate - the new certificate\n     * @throws {TypeError} If initialCertificate is not a ClientCertificate.\n     */\n    RotatingClientCertificateProvider.prototype.updateCertificate = function (certificate) {\n        throw new Error('Not implemented');\n    };\n    return RotatingClientCertificateProvider;\n}(ClientCertificateProvider));\nexports.RotatingClientCertificateProvider = RotatingClientCertificateProvider;\n/**\n * Defines the object which holds the common {@link ClientCertificateProviders} used in the Driver\n *\n * @since 5.27\n */\nvar ClientCertificateProviders = /** @class */ (function () {\n    function ClientCertificateProviders() {\n    }\n    /**\n     *\n     * @param {object} param0 - The params\n     * @param {ClientCertificate} param0.initialCertificate - The certificated used by the driver until {@link RotatingClientCertificateProvider#updateCertificate} get called.\n     *\n     * @returns {RotatingClientCertificateProvider} The rotating client certificate provider\n     * @throws {TypeError} If initialCertificate is not a ClientCertificate.\n     */\n    ClientCertificateProviders.prototype.rotating = function (_a) {\n        var initialCertificate = _a.initialCertificate;\n        if (initialCertificate == null || !isClientClientCertificate(initialCertificate)) {\n            throw new TypeError(\"initialCertificate should be ClientCertificate, but got \".concat(json.stringify(initialCertificate)));\n        }\n        var certificate = __assign({}, initialCertificate);\n        return new InternalRotatingClientCertificateProvider(certificate);\n    };\n    return ClientCertificateProviders;\n}());\n/**\n * Holds the common {@link ClientCertificateProviders} used in the Driver.\n *\n * @since 5.27\n */\nvar clientCertificateProviders = new ClientCertificateProviders();\nexports.clientCertificateProviders = clientCertificateProviders;\nObject.freeze(clientCertificateProviders);\n/**\n * Resolves ClientCertificate or ClientCertificateProvider to a ClientCertificateProvider\n *\n * Method validates the input.\n *\n * @private\n * @param input\n * @returns {ClientCertificateProvider?} A client certificate provider if provided a ClientCertificate or a ClientCertificateProvider\n * @throws {TypeError} If input is not a ClientCertificate, ClientCertificateProvider, undefined or null.\n */\nfunction resolveCertificateProvider(input) {\n    if (input == null) {\n        return undefined;\n    }\n    if (typeof input === 'object' && 'hasUpdate' in input && 'getClientCertificate' in input &&\n        typeof input.getClientCertificate === 'function' && typeof input.hasUpdate === 'function') {\n        return input;\n    }\n    if (isClientClientCertificate(input)) {\n        var certificate_1 = __assign({}, input);\n        return {\n            getClientCertificate: function () { return certificate_1; },\n            hasUpdate: function () { return false; }\n        };\n    }\n    throw new TypeError(\"clientCertificate should be configured with ClientCertificate or ClientCertificateProvider, but got \".concat(json.stringify(input)));\n}\nexports.resolveCertificateProvider = resolveCertificateProvider;\n/**\n * Verify if object is a client certificate\n * @private\n * @param maybeClientCertificate - Maybe the certificate\n * @returns {boolean} if maybeClientCertificate is a client certificate object\n */\nfunction isClientClientCertificate(maybeClientCertificate) {\n    return maybeClientCertificate != null &&\n        typeof maybeClientCertificate === 'object' &&\n        'certfile' in maybeClientCertificate && isCertFile(maybeClientCertificate.certfile) &&\n        'keyfile' in maybeClientCertificate && isKeyFile(maybeClientCertificate.keyfile) &&\n        isStringOrNotPresent('password', maybeClientCertificate);\n}\n/**\n * Check value is a cert file\n * @private\n * @param {any} value the value\n * @returns {boolean} is a cert file\n */\nfunction isCertFile(value) {\n    return isString(value) || isArrayOf(value, isString);\n}\n/**\n * Check if the value is a keyfile.\n *\n * @private\n * @param {any} maybeKeyFile might be a keyfile value\n * @returns {boolean} the value is a KeyFile\n */\nfunction isKeyFile(maybeKeyFile) {\n    function check(obj) {\n        return typeof obj === 'string' ||\n            (obj != null &&\n                typeof obj === 'object' &&\n                'path' in obj && typeof obj.path === 'string' &&\n                isStringOrNotPresent('password', obj));\n    }\n    return check(maybeKeyFile) || isArrayOf(maybeKeyFile, check);\n}\n/**\n * Verify if value is string\n *\n * @private\n * @param {any} value the value\n * @returns {boolean} is string\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\n/**\n * Verifies if value is a array of type\n *\n * @private\n * @param {any} value the value\n * @param {function} isType the type checker\n * @returns {boolean} value is array of type\n */\nfunction isArrayOf(value, isType, allowEmpty) {\n    if (allowEmpty === void 0) { allowEmpty = false; }\n    return Array.isArray(value) &&\n        (allowEmpty || value.length > 0) &&\n        value.filter(isType).length === value.length;\n}\n/**\n * Verify if valueName is present in the object and is a string, or not present at all.\n *\n * @private\n * @param {string} valueName The value in the object\n * @param {object} obj The object\n * @returns {boolean} if the value is present in object as string or not present\n */\nfunction isStringOrNotPresent(valueName, obj) {\n    return !(valueName in obj) || obj[valueName] == null || typeof obj[valueName] === 'string';\n}\n/**\n * Internal implementation\n *\n * @private\n */\nvar InternalRotatingClientCertificateProvider = /** @class */ (function () {\n    function InternalRotatingClientCertificateProvider(_certificate, _updated) {\n        if (_updated === void 0) { _updated = false; }\n        this._certificate = _certificate;\n        this._updated = _updated;\n    }\n    /**\n     *\n     * @returns {boolean|Promise<boolean>}\n     */\n    InternalRotatingClientCertificateProvider.prototype.hasUpdate = function () {\n        try {\n            return this._updated;\n        }\n        finally {\n            this._updated = false;\n        }\n    };\n    /**\n     *\n     * @returns {ClientCertificate|Promise<ClientCertificate>}\n     */\n    InternalRotatingClientCertificateProvider.prototype.getClientCertificate = function () {\n        return this._certificate;\n    };\n    /**\n     *\n     * @param certificate\n     * @returns {void}\n     */\n    InternalRotatingClientCertificateProvider.prototype.updateCertificate = function (certificate) {\n        if (!isClientClientCertificate(certificate)) {\n            throw new TypeError(\"certificate should be ClientCertificate, but got \".concat(json.stringify(certificate)));\n        }\n        this._certificate = __assign({}, certificate);\n        this._updated = true;\n    };\n    return InternalRotatingClientCertificateProvider;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2NsaWVudC1jZXJ0aWZpY2F0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLGtDQUFrQyxHQUFHLHlDQUF5QyxHQUFHLGlDQUFpQztBQUN2Six3QkFBd0IsbUJBQU8sQ0FBQyxrRUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsa0JBQWtCO0FBQ2hDLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsUUFBUSxpQ0FBaUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtC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LHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvY2xpZW50LWNlcnRpZmljYXRlLmpzPzI1YTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZUNlcnRpZmljYXRlUHJvdmlkZXIgPSBleHBvcnRzLmNsaWVudENlcnRpZmljYXRlUHJvdmlkZXJzID0gZXhwb3J0cy5Sb3RhdGluZ0NsaWVudENlcnRpZmljYXRlUHJvdmlkZXIgPSBleHBvcnRzLkNsaWVudENlcnRpZmljYXRlUHJvdmlkZXIgPSB2b2lkIDA7XG52YXIganNvbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uXCIpKTtcbi8qKlxuICogUmVwcmVzZW50cyBLZXlGaWxlIHJlcHJlc2VudGVkIGFzIGZpbGUuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gS2V5RmlsZU9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCBvZiB0aGUgZmlsZVxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBwYXNzd29yZCAtIHRoZSBwYXNzd29yZCBvZiB0aGUga2V5LiBJZiBub25lLFxuICogdGhlIHBhc3N3b3JkIGRlZmluZWQgYXQge0BsaW5rIENsaWVudENlcnRpZmljYXRlfSB3aWxsIGJlIHVzZWQuXG4gKi9cbi8qKlxuICogSG9sZHMgdGhlIENsaWVudCBUTFMgY2VydGlmaWNhdGUgaW5mb3JtYXRpb24uXG4gKlxuICogQnJvd3NlciBpbnN0YW5jZXMgb2YgdGhlIGRyaXZlciBzaG91bGQgY29uZmlndXJlIHRoZSBjZXJ0aWZpY2F0ZVxuICogaW4gdGhlIHN5c3RlbS5cbiAqXG4gKiBGaWxlcyBkZWZpbmVkIGluIHRoZSB7QGxpbmsgQ2xpZW50Q2VydGlmaWNhdGUjY2VydGZpbGV9XG4gKiBhbmQge0BsaW5rIENsaWVudENlcnRpZmljYXRlI2tleWZpbGV9IHdpbGwgcmVhZCBhbmQgbG9hZGVkIHRvXG4gKiBtZW1vcnkgdG8gZmlsbCB0aGUgZmllbGRzIGBjZXJ0YCBhbmQgYGtleWAgaW4gc2VjdXJpdHkgY29udGV4dC5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGxzLmh0bWwjdGxzY3JlYXRlc2VjdXJlY29udGV4dG9wdGlvbnNcbiAqIEBzaW5jZSA1LjI3XG4gKi9cbnZhciBDbGllbnRDZXJ0aWZpY2F0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGllbnRDZXJ0aWZpY2F0ZSgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXRoIHRvIGNsaWVudCBjZXJ0aWZpY2F0ZSBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZXJ0ZmlsZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhdGggdG8gdGhlIGtleSBmaWxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfEtleUZpbGVPYmplY3R8S2V5RmlsZU9iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZXlmaWxlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUga2V5J3MgcGFzc3dvcmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXNzd29yZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIENsaWVudENlcnRpZmljYXRlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsaWVudENlcnRpZmljYXRlO1xuLyoqXG4gKiBQcm92aWRlcyBhIGNsaWVudCBjZXJ0aWZpY2F0ZSB0byB0aGUgZHJpdmVyIGZvciBtdXR1YWwgVExTLlxuICpcbiAqIFRoZSBkcml2ZXIgd2lsbCBjYWxsIHtAbGluayBDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyI2hhc1VwZGF0ZX0gdG8gY2hlY2sgaWYgdGhlIGNsaWVudCB3YW50cyB0byB1cGRhdGUgdGhlIGNlcnRpZmljYXRlLlxuICogSWYgc28sIGl0IHdpbGwgY2FsbCB7QGxpbmsgQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlciNnZXRDbGllbnRDZXJ0aWZpY2F0ZX0gdG8gZ2V0IHRoZSBuZXcgY2VydGlmaWNhdGUuXG4gKlxuICogVGhlIGNlcnRpZmljYXRlIGlzIG9ubHkgdXNlZCBhcyBhIHNlY29uZCBmYWN0b3IgZm9yIGF1dGhlbnRpY2F0aW9uIGF1dGhlbnRpY2F0aW5nIHRoZSBjbGllbnQuXG4gKiBUaGUgRE1CUyB1c2VyIHN0aWxsIG5lZWRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIGFuIGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICpcbiAqIEFsbCBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBpbnRlcmZhY2UgbXVzdCBiZSB0aHJlYWQtc2FmZSBhbmQgbm9uLWJsb2NraW5nIGZvciBjYWxsZXIgdGhyZWFkcy5cbiAqIEZvciBpbnN0YW5jZSwgSU8gb3BlcmF0aW9ucyBtdXN0IG5vdCBiZSBkb25lIG9uIHRoZSBjYWxsaW5nIHRocmVhZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHdvcmsgZG9uZSBpbiB0aGUgbWV0aG9kcyBvZiB0aGlzIGludGVyZmFjZSBjb3VudCB0b3dhcmRzIHRoZSBjb25uZWN0aW9uQWNxdWlzaXRpb24uXG4gKiBTaG91bGQgZmV0Y2hpbmcgdGhlIGNlcnRpZmljYXRlIGJlIHBhcnRpY3VsYXJseSBzbG93LCBpdCBtaWdodCBiZSBuZWNlc3NhcnkgdG8gaW5jcmVhc2UgdGhlIHRpbWVvdXQuXG4gKlxuICogQGludGVyZmFjZVxuICogQHNpbmNlIDUuMjdcbiAqL1xudmFyIENsaWVudENlcnRpZmljYXRlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNsaWVudCB3YW50cyB0aGUgZHJpdmVyIHRvIHVwZGF0ZSB0aGUgY2VydGlmaWNhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPnxib29sZWFufSB0cnVlIGlmIHRoZSBjbGllbnQgd2FudHMgdGhlIGRyaXZlciB0byB1cGRhdGUgdGhlIGNlcnRpZmljYXRlXG4gICAgICovXG4gICAgQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlci5wcm90b3R5cGUuaGFzVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2VydGlmaWNhdGUgdG8gdXNlIGZvciBuZXcgY29ubmVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgZHJpdmVyIGFmdGVyIHtAbGluayBDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyI2hhc1VwZGF0ZX0gcmV0dXJuZWQgdHJ1ZVxuICAgICAqIG9yIHdoZW4gdGhlIGRyaXZlciBlc3RhYmxpc2hlcyB0aGUgZmlyc3QgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENsaWVudENlcnRpZmljYXRlPnxDbGllbnRDZXJ0aWZpY2F0ZX0gdGhlIGNlcnRpZmljYXRlIHRvIHVzZSBmb3IgbmV3IGNvbm5lY3Rpb25zXG4gICAgICovXG4gICAgQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlci5wcm90b3R5cGUuZ2V0Q2xpZW50Q2VydGlmaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcjtcbn0oKSk7XG5leHBvcnRzLkNsaWVudENlcnRpZmljYXRlUHJvdmlkZXIgPSBDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyO1xuLyoqXG4gKiBJbnRlcmZhY2UgZm9yICB7QGxpbmsgQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcn0gd2hpY2ggcHJvdmlkZXMgdXBkYXRlIGNlcnRpZmljYXRlIGZ1bmN0aW9uLlxuICogQGludGVyZmFjZVxuICogQHNpbmNlIDUuMjdcbiAqL1xudmFyIFJvdGF0aW5nQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUm90YXRpbmdDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJvdGF0aW5nQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjZXJ0aWZpY2F0ZSBzdG9yZWQgaW4gdGhlIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogVG8gYmUgY2FsbGVkIGJ5IHVzZXItY29kZSB3aGVuIGEgbmV3IGNsaWVudCBjZXJ0aWZpY2F0ZSBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NsaWVudENlcnRpZmljYXRlfSBjZXJ0aWZpY2F0ZSAtIHRoZSBuZXcgY2VydGlmaWNhdGVcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGluaXRpYWxDZXJ0aWZpY2F0ZSBpcyBub3QgYSBDbGllbnRDZXJ0aWZpY2F0ZS5cbiAgICAgKi9cbiAgICBSb3RhdGluZ0NsaWVudENlcnRpZmljYXRlUHJvdmlkZXIucHJvdG90eXBlLnVwZGF0ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24gKGNlcnRpZmljYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gUm90YXRpbmdDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyO1xufShDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyKSk7XG5leHBvcnRzLlJvdGF0aW5nQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlciA9IFJvdGF0aW5nQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcjtcbi8qKlxuICogRGVmaW5lcyB0aGUgb2JqZWN0IHdoaWNoIGhvbGRzIHRoZSBjb21tb24ge0BsaW5rIENsaWVudENlcnRpZmljYXRlUHJvdmlkZXJzfSB1c2VkIGluIHRoZSBEcml2ZXJcbiAqXG4gKiBAc2luY2UgNS4yN1xuICovXG52YXIgQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtMCAtIFRoZSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0NsaWVudENlcnRpZmljYXRlfSBwYXJhbTAuaW5pdGlhbENlcnRpZmljYXRlIC0gVGhlIGNlcnRpZmljYXRlZCB1c2VkIGJ5IHRoZSBkcml2ZXIgdW50aWwge0BsaW5rIFJvdGF0aW5nQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlciN1cGRhdGVDZXJ0aWZpY2F0ZX0gZ2V0IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSb3RhdGluZ0NsaWVudENlcnRpZmljYXRlUHJvdmlkZXJ9IFRoZSByb3RhdGluZyBjbGllbnQgY2VydGlmaWNhdGUgcHJvdmlkZXJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGluaXRpYWxDZXJ0aWZpY2F0ZSBpcyBub3QgYSBDbGllbnRDZXJ0aWZpY2F0ZS5cbiAgICAgKi9cbiAgICBDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVycy5wcm90b3R5cGUucm90YXRpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGluaXRpYWxDZXJ0aWZpY2F0ZSA9IF9hLmluaXRpYWxDZXJ0aWZpY2F0ZTtcbiAgICAgICAgaWYgKGluaXRpYWxDZXJ0aWZpY2F0ZSA9PSBudWxsIHx8ICFpc0NsaWVudENsaWVudENlcnRpZmljYXRlKGluaXRpYWxDZXJ0aWZpY2F0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbml0aWFsQ2VydGlmaWNhdGUgc2hvdWxkIGJlIENsaWVudENlcnRpZmljYXRlLCBidXQgZ290IFwiLmNvbmNhdChqc29uLnN0cmluZ2lmeShpbml0aWFsQ2VydGlmaWNhdGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNlcnRpZmljYXRlID0gX19hc3NpZ24oe30sIGluaXRpYWxDZXJ0aWZpY2F0ZSk7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJuYWxSb3RhdGluZ0NsaWVudENlcnRpZmljYXRlUHJvdmlkZXIoY2VydGlmaWNhdGUpO1xuICAgIH07XG4gICAgcmV0dXJuIENsaWVudENlcnRpZmljYXRlUHJvdmlkZXJzO1xufSgpKTtcbi8qKlxuICogSG9sZHMgdGhlIGNvbW1vbiB7QGxpbmsgQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnN9IHVzZWQgaW4gdGhlIERyaXZlci5cbiAqXG4gKiBAc2luY2UgNS4yN1xuICovXG52YXIgY2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnMgPSBuZXcgQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnMoKTtcbmV4cG9ydHMuY2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnMgPSBjbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVycztcbk9iamVjdC5mcmVlemUoY2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnMpO1xuLyoqXG4gKiBSZXNvbHZlcyBDbGllbnRDZXJ0aWZpY2F0ZSBvciBDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyIHRvIGEgQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlclxuICpcbiAqIE1ldGhvZCB2YWxpZGF0ZXMgdGhlIGlucHV0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gaW5wdXRcbiAqIEByZXR1cm5zIHtDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyP30gQSBjbGllbnQgY2VydGlmaWNhdGUgcHJvdmlkZXIgaWYgcHJvdmlkZWQgYSBDbGllbnRDZXJ0aWZpY2F0ZSBvciBhIENsaWVudENlcnRpZmljYXRlUHJvdmlkZXJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgaW5wdXQgaXMgbm90IGEgQ2xpZW50Q2VydGlmaWNhdGUsIENsaWVudENlcnRpZmljYXRlUHJvdmlkZXIsIHVuZGVmaW5lZCBvciBudWxsLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQ2VydGlmaWNhdGVQcm92aWRlcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmICdoYXNVcGRhdGUnIGluIGlucHV0ICYmICdnZXRDbGllbnRDZXJ0aWZpY2F0ZScgaW4gaW5wdXQgJiZcbiAgICAgICAgdHlwZW9mIGlucHV0LmdldENsaWVudENlcnRpZmljYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnB1dC5oYXNVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoaXNDbGllbnRDbGllbnRDZXJ0aWZpY2F0ZShpbnB1dCkpIHtcbiAgICAgICAgdmFyIGNlcnRpZmljYXRlXzEgPSBfX2Fzc2lnbih7fSwgaW5wdXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0Q2xpZW50Q2VydGlmaWNhdGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNlcnRpZmljYXRlXzE7IH0sXG4gICAgICAgICAgICBoYXNVcGRhdGU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjbGllbnRDZXJ0aWZpY2F0ZSBzaG91bGQgYmUgY29uZmlndXJlZCB3aXRoIENsaWVudENlcnRpZmljYXRlIG9yIENsaWVudENlcnRpZmljYXRlUHJvdmlkZXIsIGJ1dCBnb3QgXCIuY29uY2F0KGpzb24uc3RyaW5naWZ5KGlucHV0KSkpO1xufVxuZXhwb3J0cy5yZXNvbHZlQ2VydGlmaWNhdGVQcm92aWRlciA9IHJlc29sdmVDZXJ0aWZpY2F0ZVByb3ZpZGVyO1xuLyoqXG4gKiBWZXJpZnkgaWYgb2JqZWN0IGlzIGEgY2xpZW50IGNlcnRpZmljYXRlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG1heWJlQ2xpZW50Q2VydGlmaWNhdGUgLSBNYXliZSB0aGUgY2VydGlmaWNhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBpZiBtYXliZUNsaWVudENlcnRpZmljYXRlIGlzIGEgY2xpZW50IGNlcnRpZmljYXRlIG9iamVjdFxuICovXG5mdW5jdGlvbiBpc0NsaWVudENsaWVudENlcnRpZmljYXRlKG1heWJlQ2xpZW50Q2VydGlmaWNhdGUpIHtcbiAgICByZXR1cm4gbWF5YmVDbGllbnRDZXJ0aWZpY2F0ZSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBtYXliZUNsaWVudENlcnRpZmljYXRlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnY2VydGZpbGUnIGluIG1heWJlQ2xpZW50Q2VydGlmaWNhdGUgJiYgaXNDZXJ0RmlsZShtYXliZUNsaWVudENlcnRpZmljYXRlLmNlcnRmaWxlKSAmJlxuICAgICAgICAna2V5ZmlsZScgaW4gbWF5YmVDbGllbnRDZXJ0aWZpY2F0ZSAmJiBpc0tleUZpbGUobWF5YmVDbGllbnRDZXJ0aWZpY2F0ZS5rZXlmaWxlKSAmJlxuICAgICAgICBpc1N0cmluZ09yTm90UHJlc2VudCgncGFzc3dvcmQnLCBtYXliZUNsaWVudENlcnRpZmljYXRlKTtcbn1cbi8qKlxuICogQ2hlY2sgdmFsdWUgaXMgYSBjZXJ0IGZpbGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2FueX0gdmFsdWUgdGhlIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgYSBjZXJ0IGZpbGVcbiAqL1xuZnVuY3Rpb24gaXNDZXJ0RmlsZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgfHwgaXNBcnJheU9mKHZhbHVlLCBpc1N0cmluZyk7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhIGtleWZpbGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YW55fSBtYXliZUtleUZpbGUgbWlnaHQgYmUgYSBrZXlmaWxlIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGhlIHZhbHVlIGlzIGEgS2V5RmlsZVxuICovXG5mdW5jdGlvbiBpc0tleUZpbGUobWF5YmVLZXlGaWxlKSB7XG4gICAgZnVuY3Rpb24gY2hlY2sob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKG9iaiAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAncGF0aCcgaW4gb2JqICYmIHR5cGVvZiBvYmoucGF0aCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICBpc1N0cmluZ09yTm90UHJlc2VudCgncGFzc3dvcmQnLCBvYmopKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrKG1heWJlS2V5RmlsZSkgfHwgaXNBcnJheU9mKG1heWJlS2V5RmlsZSwgY2hlY2spO1xufVxuLyoqXG4gKiBWZXJpZnkgaWYgdmFsdWUgaXMgc3RyaW5nXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSB0aGUgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBpcyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbi8qKlxuICogVmVyaWZpZXMgaWYgdmFsdWUgaXMgYSBhcnJheSBvZiB0eXBlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSB0aGUgdmFsdWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGlzVHlwZSB0aGUgdHlwZSBjaGVja2VyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdmFsdWUgaXMgYXJyYXkgb2YgdHlwZVxuICovXG5mdW5jdGlvbiBpc0FycmF5T2YodmFsdWUsIGlzVHlwZSwgYWxsb3dFbXB0eSkge1xuICAgIGlmIChhbGxvd0VtcHR5ID09PSB2b2lkIDApIHsgYWxsb3dFbXB0eSA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIChhbGxvd0VtcHR5IHx8IHZhbHVlLmxlbmd0aCA+IDApICYmXG4gICAgICAgIHZhbHVlLmZpbHRlcihpc1R5cGUpLmxlbmd0aCA9PT0gdmFsdWUubGVuZ3RoO1xufVxuLyoqXG4gKiBWZXJpZnkgaWYgdmFsdWVOYW1lIGlzIHByZXNlbnQgaW4gdGhlIG9iamVjdCBhbmQgaXMgYSBzdHJpbmcsIG9yIG5vdCBwcmVzZW50IGF0IGFsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlTmFtZSBUaGUgdmFsdWUgaW4gdGhlIG9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IG9iaiBUaGUgb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgdGhlIHZhbHVlIGlzIHByZXNlbnQgaW4gb2JqZWN0IGFzIHN0cmluZyBvciBub3QgcHJlc2VudFxuICovXG5mdW5jdGlvbiBpc1N0cmluZ09yTm90UHJlc2VudCh2YWx1ZU5hbWUsIG9iaikge1xuICAgIHJldHVybiAhKHZhbHVlTmFtZSBpbiBvYmopIHx8IG9ialt2YWx1ZU5hbWVdID09IG51bGwgfHwgdHlwZW9mIG9ialt2YWx1ZU5hbWVdID09PSAnc3RyaW5nJztcbn1cbi8qKlxuICogSW50ZXJuYWwgaW1wbGVtZW50YXRpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSW50ZXJuYWxSb3RhdGluZ0NsaWVudENlcnRpZmljYXRlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJuYWxSb3RhdGluZ0NsaWVudENlcnRpZmljYXRlUHJvdmlkZXIoX2NlcnRpZmljYXRlLCBfdXBkYXRlZCkge1xuICAgICAgICBpZiAoX3VwZGF0ZWQgPT09IHZvaWQgMCkgeyBfdXBkYXRlZCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX2NlcnRpZmljYXRlID0gX2NlcnRpZmljYXRlO1xuICAgICAgICB0aGlzLl91cGRhdGVkID0gX3VwZGF0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58UHJvbWlzZTxib29sZWFuPn1cbiAgICAgKi9cbiAgICBJbnRlcm5hbFJvdGF0aW5nQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlci5wcm90b3R5cGUuaGFzVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NsaWVudENlcnRpZmljYXRlfFByb21pc2U8Q2xpZW50Q2VydGlmaWNhdGU+fVxuICAgICAqL1xuICAgIEludGVybmFsUm90YXRpbmdDbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRDbGllbnRDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlcnRpZmljYXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2VydGlmaWNhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBJbnRlcm5hbFJvdGF0aW5nQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlci5wcm90b3R5cGUudXBkYXRlQ2VydGlmaWNhdGUgPSBmdW5jdGlvbiAoY2VydGlmaWNhdGUpIHtcbiAgICAgICAgaWYgKCFpc0NsaWVudENsaWVudENlcnRpZmljYXRlKGNlcnRpZmljYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNlcnRpZmljYXRlIHNob3VsZCBiZSBDbGllbnRDZXJ0aWZpY2F0ZSwgYnV0IGdvdCBcIi5jb25jYXQoanNvbi5zdHJpbmdpZnkoY2VydGlmaWNhdGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2VydGlmaWNhdGUgPSBfX2Fzc2lnbih7fSwgY2VydGlmaWNhdGUpO1xuICAgICAgICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBJbnRlcm5hbFJvdGF0aW5nQ2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcjtcbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/client-certificate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/connection-provider.js":
/*!*******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/connection-provider.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable @typescript-eslint/promise-function-async */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Releasable = void 0;\n/**\n * Interface define a releasable resource shape\n *\n * @private\n * @interface\n */\nvar Releasable = /** @class */ (function () {\n    function Releasable() {\n    }\n    /**\n     * @returns {Promise<void>}\n     */\n    Releasable.prototype.release = function () {\n        throw new Error('Not implemented');\n    };\n    return Releasable;\n}());\nexports.Releasable = Releasable;\n/**\n * Interface define a common way to acquire a connection\n *\n * @private\n */\nvar ConnectionProvider = /** @class */ (function () {\n    function ConnectionProvider() {\n    }\n    /**\n     * This method acquires a connection against the specified database.\n     *\n     * Access mode and Bookmarks only applies to routing driver. Access mode only\n     * differentiates the target server for the connection, where WRITE selects a\n     * WRITER server, whereas READ selects a READ server. Bookmarks, when specified,\n     * is only passed to the routing discovery procedure, for the system database to\n     * synchronize on creation of databases and is never used in direct drivers.\n     *\n     * @param {object} param - object parameter\n     * @property {string} param.accessMode - the access mode for the to-be-acquired connection\n     * @property {string} param.database - the target database for the to-be-acquired connection\n     * @property {Bookmarks} param.bookmarks - the bookmarks to send to routing discovery\n     * @property {string} param.impersonatedUser - the impersonated user\n     * @property {function (databaseName:string)} param.onDatabaseNameResolved - Callback called when the database name get resolved\n     * @property {AuthToken} param.auth - auth token used to authorize for connection acquisition\n     * @property {string} param.homeDb - the driver's best guess at the current home database for the user\n     * @returns {Promise<Connection>}\n     */\n    ConnectionProvider.prototype.acquireConnection = function (param) {\n        throw Error('Not implemented');\n    };\n    /**\n     * This method checks whether the backend database supports multi database functionality\n     * by checking protocol handshake result.\n     *\n     * @returns {Promise<boolean>}\n     */\n    ConnectionProvider.prototype.supportsMultiDb = function () {\n        throw Error('Not implemented');\n    };\n    /**\n     * This method checks whether the backend database supports transaction config functionality\n     * by checking protocol handshake result.\n     *\n     * @returns {Promise<boolean>}\n     */\n    ConnectionProvider.prototype.supportsTransactionConfig = function () {\n        throw Error('Not implemented');\n    };\n    /**\n     * This method checks whether the backend database supports user impersonation functionality\n     * by checking protocol handshake result.\n     *\n     * @returns {Promise<boolean>}\n     */\n    ConnectionProvider.prototype.supportsUserImpersonation = function () {\n        throw Error('Not implemented');\n    };\n    /**\n     * This method checks whether the driver session re-auth functionality\n     * by checking protocol handshake result\n     *\n     * @returns {Promise<boolean>}\n     */\n    ConnectionProvider.prototype.supportsSessionAuth = function () {\n        throw Error('Not implemented');\n    };\n    ConnectionProvider.prototype.SSREnabled = function () {\n        return false;\n    };\n    /**\n     * This method verifies the connectivity of the database by trying to acquire a connection\n     * for each server available in the cluster.\n     *\n     * @param {object} param - object parameter\n     * @property {string} param.database - the target database for the to-be-acquired connection\n     * @property {string} param.accessMode - the access mode for the to-be-acquired connection\n     *\n     * @returns {Promise<ServerInfo>} promise resolved with server info or rejected with error.\n     */\n    ConnectionProvider.prototype.verifyConnectivityAndGetServerInfo = function (param) {\n        throw Error('Not implemented');\n    };\n    /**\n     * This method verifies the authorization credentials work by trying to acquire a connection\n     * to one of the servers with the given credentials.\n     *\n     * @param {object} param - object parameter\n     * @property {AuthToken} param.auth - the target auth for the to-be-acquired connection\n     * @property {string} param.database - the target database for the to-be-acquired connection\n     * @property {string} param.accessMode - the access mode for the to-be-acquired connection\n     *\n     * @returns {Promise<boolean>} promise resolved with true if succeed, false if failed with\n     *  authentication issue and rejected with error if non-authentication error happens.\n     */\n    ConnectionProvider.prototype.verifyAuthentication = function (param) {\n        throw Error('Not implemented');\n    };\n    /**\n     * Returns the protocol version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<number>} the protocol version negotiated via handshake.\n     * @throws {Error} When protocol negotiation fails\n     */\n    ConnectionProvider.prototype.getNegotiatedProtocolVersion = function () {\n        throw Error('Not Implemented');\n    };\n    /**\n     * Closes this connection provider along with its internals (connections, pools, etc.)\n     *\n     * @returns {Promise<void>}\n     */\n    ConnectionProvider.prototype.close = function () {\n        throw Error('Not implemented');\n    };\n    return ConnectionProvider;\n}());\nexports[\"default\"] = ConnectionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2Nvbm5lY3Rpb24tcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixXQUFXO0FBQzdCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixnQ0FBZ0M7QUFDbEQsa0JBQWtCLFdBQVc7QUFDN0Isa0JBQWtCLFFBQVE7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0IsV0FBVztBQUM3QixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9jb25uZWN0aW9uLXByb3ZpZGVyLmpzPzczZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVsZWFzYWJsZSA9IHZvaWQgMDtcbi8qKlxuICogSW50ZXJmYWNlIGRlZmluZSBhIHJlbGVhc2FibGUgcmVzb3VyY2Ugc2hhcGVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGludGVyZmFjZVxuICovXG52YXIgUmVsZWFzYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWxlYXNhYmxlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBSZWxlYXNhYmxlLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbGVhc2FibGU7XG59KCkpO1xuZXhwb3J0cy5SZWxlYXNhYmxlID0gUmVsZWFzYWJsZTtcbi8qKlxuICogSW50ZXJmYWNlIGRlZmluZSBhIGNvbW1vbiB3YXkgdG8gYWNxdWlyZSBhIGNvbm5lY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgQ29ubmVjdGlvblByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25Qcm92aWRlcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYWNxdWlyZXMgYSBjb25uZWN0aW9uIGFnYWluc3QgdGhlIHNwZWNpZmllZCBkYXRhYmFzZS5cbiAgICAgKlxuICAgICAqIEFjY2VzcyBtb2RlIGFuZCBCb29rbWFya3Mgb25seSBhcHBsaWVzIHRvIHJvdXRpbmcgZHJpdmVyLiBBY2Nlc3MgbW9kZSBvbmx5XG4gICAgICogZGlmZmVyZW50aWF0ZXMgdGhlIHRhcmdldCBzZXJ2ZXIgZm9yIHRoZSBjb25uZWN0aW9uLCB3aGVyZSBXUklURSBzZWxlY3RzIGFcbiAgICAgKiBXUklURVIgc2VydmVyLCB3aGVyZWFzIFJFQUQgc2VsZWN0cyBhIFJFQUQgc2VydmVyLiBCb29rbWFya3MsIHdoZW4gc3BlY2lmaWVkLFxuICAgICAqIGlzIG9ubHkgcGFzc2VkIHRvIHRoZSByb3V0aW5nIGRpc2NvdmVyeSBwcm9jZWR1cmUsIGZvciB0aGUgc3lzdGVtIGRhdGFiYXNlIHRvXG4gICAgICogc3luY2hyb25pemUgb24gY3JlYXRpb24gb2YgZGF0YWJhc2VzIGFuZCBpcyBuZXZlciB1c2VkIGluIGRpcmVjdCBkcml2ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtIC0gb2JqZWN0IHBhcmFtZXRlclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXJhbS5hY2Nlc3NNb2RlIC0gdGhlIGFjY2VzcyBtb2RlIGZvciB0aGUgdG8tYmUtYWNxdWlyZWQgY29ubmVjdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXJhbS5kYXRhYmFzZSAtIHRoZSB0YXJnZXQgZGF0YWJhc2UgZm9yIHRoZSB0by1iZS1hY3F1aXJlZCBjb25uZWN0aW9uXG4gICAgICogQHByb3BlcnR5IHtCb29rbWFya3N9IHBhcmFtLmJvb2ttYXJrcyAtIHRoZSBib29rbWFya3MgdG8gc2VuZCB0byByb3V0aW5nIGRpc2NvdmVyeVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXJhbS5pbXBlcnNvbmF0ZWRVc2VyIC0gdGhlIGltcGVyc29uYXRlZCB1c2VyXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbiAoZGF0YWJhc2VOYW1lOnN0cmluZyl9IHBhcmFtLm9uRGF0YWJhc2VOYW1lUmVzb2x2ZWQgLSBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgbmFtZSBnZXQgcmVzb2x2ZWRcbiAgICAgKiBAcHJvcGVydHkge0F1dGhUb2tlbn0gcGFyYW0uYXV0aCAtIGF1dGggdG9rZW4gdXNlZCB0byBhdXRob3JpemUgZm9yIGNvbm5lY3Rpb24gYWNxdWlzaXRpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcGFyYW0uaG9tZURiIC0gdGhlIGRyaXZlcidzIGJlc3QgZ3Vlc3MgYXQgdGhlIGN1cnJlbnQgaG9tZSBkYXRhYmFzZSBmb3IgdGhlIHVzZXJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uPn1cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLmFjcXVpcmVDb25uZWN0aW9uID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIHRoZSBiYWNrZW5kIGRhdGFiYXNlIHN1cHBvcnRzIG11bHRpIGRhdGFiYXNlIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBieSBjaGVja2luZyBwcm90b2NvbCBoYW5kc2hha2UgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG4gICAgQ29ubmVjdGlvblByb3ZpZGVyLnByb3RvdHlwZS5zdXBwb3J0c011bHRpRGIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIHRoZSBiYWNrZW5kIGRhdGFiYXNlIHN1cHBvcnRzIHRyYW5zYWN0aW9uIGNvbmZpZyBmdW5jdGlvbmFsaXR5XG4gICAgICogYnkgY2hlY2tpbmcgcHJvdG9jb2wgaGFuZHNoYWtlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIENvbm5lY3Rpb25Qcm92aWRlci5wcm90b3R5cGUuc3VwcG9ydHNUcmFuc2FjdGlvbkNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgdGhlIGJhY2tlbmQgZGF0YWJhc2Ugc3VwcG9ydHMgdXNlciBpbXBlcnNvbmF0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBieSBjaGVja2luZyBwcm90b2NvbCBoYW5kc2hha2UgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG4gICAgQ29ubmVjdGlvblByb3ZpZGVyLnByb3RvdHlwZS5zdXBwb3J0c1VzZXJJbXBlcnNvbmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciB0aGUgZHJpdmVyIHNlc3Npb24gcmUtYXV0aCBmdW5jdGlvbmFsaXR5XG4gICAgICogYnkgY2hlY2tpbmcgcHJvdG9jb2wgaGFuZHNoYWtlIHJlc3VsdFxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAgICovXG4gICAgQ29ubmVjdGlvblByb3ZpZGVyLnByb3RvdHlwZS5zdXBwb3J0c1Nlc3Npb25BdXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLlNTUkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHZlcmlmaWVzIHRoZSBjb25uZWN0aXZpdHkgb2YgdGhlIGRhdGFiYXNlIGJ5IHRyeWluZyB0byBhY3F1aXJlIGEgY29ubmVjdGlvblxuICAgICAqIGZvciBlYWNoIHNlcnZlciBhdmFpbGFibGUgaW4gdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW0gLSBvYmplY3QgcGFyYW1ldGVyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHBhcmFtLmRhdGFiYXNlIC0gdGhlIHRhcmdldCBkYXRhYmFzZSBmb3IgdGhlIHRvLWJlLWFjcXVpcmVkIGNvbm5lY3Rpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcGFyYW0uYWNjZXNzTW9kZSAtIHRoZSBhY2Nlc3MgbW9kZSBmb3IgdGhlIHRvLWJlLWFjcXVpcmVkIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcnZlckluZm8+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggc2VydmVyIGluZm8gb3IgcmVqZWN0ZWQgd2l0aCBlcnJvci5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLnZlcmlmeUNvbm5lY3Rpdml0eUFuZEdldFNlcnZlckluZm8gPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdmVyaWZpZXMgdGhlIGF1dGhvcml6YXRpb24gY3JlZGVudGlhbHMgd29yayBieSB0cnlpbmcgdG8gYWNxdWlyZSBhIGNvbm5lY3Rpb25cbiAgICAgKiB0byBvbmUgb2YgdGhlIHNlcnZlcnMgd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW0gLSBvYmplY3QgcGFyYW1ldGVyXG4gICAgICogQHByb3BlcnR5IHtBdXRoVG9rZW59IHBhcmFtLmF1dGggLSB0aGUgdGFyZ2V0IGF1dGggZm9yIHRoZSB0by1iZS1hY3F1aXJlZCBjb25uZWN0aW9uXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHBhcmFtLmRhdGFiYXNlIC0gdGhlIHRhcmdldCBkYXRhYmFzZSBmb3IgdGhlIHRvLWJlLWFjcXVpcmVkIGNvbm5lY3Rpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcGFyYW0uYWNjZXNzTW9kZSAtIHRoZSBhY2Nlc3MgbW9kZSBmb3IgdGhlIHRvLWJlLWFjcXVpcmVkIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggdHJ1ZSBpZiBzdWNjZWVkLCBmYWxzZSBpZiBmYWlsZWQgd2l0aFxuICAgICAqICBhdXRoZW50aWNhdGlvbiBpc3N1ZSBhbmQgcmVqZWN0ZWQgd2l0aCBlcnJvciBpZiBub24tYXV0aGVudGljYXRpb24gZXJyb3IgaGFwcGVucy5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLnZlcmlmeUF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3RvY29sIHZlcnNpb24gbmVnb3RpYXRlZCB2aWEgaGFuZHNoYWtlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gY2FsbCBfYWx3YXlzXyBjYXVzZXMgYSByb3VuZC10cmlwIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSB0aGUgcHJvdG9jb2wgdmVyc2lvbiBuZWdvdGlhdGVkIHZpYSBoYW5kc2hha2UuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFdoZW4gcHJvdG9jb2wgbmVnb3RpYXRpb24gZmFpbHNcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLmdldE5lZ290aWF0ZWRQcm90b2NvbFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGlzIGNvbm5lY3Rpb24gcHJvdmlkZXIgYWxvbmcgd2l0aCBpdHMgaW50ZXJuYWxzIChjb25uZWN0aW9ucywgcG9vbHMsIGV0Yy4pXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGlvblByb3ZpZGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/connection-provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/connection.js":
/*!**********************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/connection.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\n/* eslint-disable @typescript-eslint/promise-function-async */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Interface which defines a connection for the core driver object.\n *\n *\n * This connection exposes only methods used by the code module.\n * Methods with connection implementation details can be defined and used\n * by the implementation layer.\n *\n * @private\n * @interface\n */\nvar Connection = /** @class */ (function () {\n    function Connection() {\n    }\n    /**\n     *\n     * @param config\n     * @returns {ResultStreamObserver}\n     */\n    Connection.prototype.beginTransaction = function (config) {\n        throw new Error('Not implemented');\n    };\n    /**\n     *\n     * @param query\n     * @param parameters\n     * @param config\n     * @returns {ResultStreamObserver}\n     */\n    Connection.prototype.run = function (query, parameters, config) {\n        throw new Error('Not implemented');\n    };\n    /**\n     *\n     * @param config\n     * @returns {ResultStreamObserver}\n     */\n    Connection.prototype.commitTransaction = function (config) {\n        throw new Error('Not implemented');\n    };\n    /**\n     *\n     * @param config\n     * @returns {ResultStreamObserver}\n     */\n    Connection.prototype.rollbackTransaction = function (config) {\n        throw new Error('Not implemented');\n    };\n    /**\n     *\n     * @returns {Promise<void>}\n     */\n    Connection.prototype.resetAndFlush = function () {\n        throw new Error('Not implemented');\n    };\n    /**\n     *\n     * @returns {boolean}\n     */\n    Connection.prototype.isOpen = function () {\n        throw new Error('Not implemented');\n    };\n    /**\n     *\n     * @returns {number}\n     */\n    Connection.prototype.getProtocolVersion = function () {\n        throw new Error('Not implemented');\n    };\n    /**\n     *\n     * @returns {boolean}\n     */\n    Connection.prototype.hasOngoingObservableRequests = function () {\n        throw new Error('Not implemented');\n    };\n    return Connection;\n}());\nexports[\"default\"] = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvY29ubmVjdGlvbi5qcz83ZWFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSW50ZXJmYWNlIHdoaWNoIGRlZmluZXMgYSBjb25uZWN0aW9uIGZvciB0aGUgY29yZSBkcml2ZXIgb2JqZWN0LlxuICpcbiAqXG4gKiBUaGlzIGNvbm5lY3Rpb24gZXhwb3NlcyBvbmx5IG1ldGhvZHMgdXNlZCBieSB0aGUgY29kZSBtb2R1bGUuXG4gKiBNZXRob2RzIHdpdGggY29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGNhbiBiZSBkZWZpbmVkIGFuZCB1c2VkXG4gKiBieSB0aGUgaW1wbGVtZW50YXRpb24gbGF5ZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBpbnRlcmZhY2VcbiAqL1xudmFyIENvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICogQHJldHVybnMge1Jlc3VsdFN0cmVhbU9ic2VydmVyfVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmJlZ2luVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBxdWVyeVxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtSZXN1bHRTdHJlYW1PYnNlcnZlcn1cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocXVlcnksIHBhcmFtZXRlcnMsIGNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICogQHJldHVybnMge1Jlc3VsdFN0cmVhbU9ic2VydmVyfVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmNvbW1pdFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICogQHJldHVybnMge1Jlc3VsdFN0cmVhbU9ic2VydmVyfVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnJvbGxiYWNrVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnJlc2V0QW5kRmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRQcm90b2NvbFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmhhc09uZ29pbmdPYnNlcnZhYmxlUmVxdWVzdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGlvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/driver.js":
/*!******************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/driver.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueryConfig = exports.SessionConfig = exports.routing = exports.WRITE = exports.READ = exports.Driver = void 0;\nvar bookmarks_1 = __webpack_require__(/*! ./internal/bookmarks */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/bookmarks.js\");\nvar configured_custom_resolver_1 = __importDefault(__webpack_require__(/*! ./internal/resolver/configured-custom-resolver */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/configured-custom-resolver.js\"));\nvar constants_1 = __webpack_require__(/*! ./internal/constants */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/constants.js\");\nvar logger_1 = __webpack_require__(/*! ./internal/logger */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/logger.js\");\nvar session_1 = __importDefault(__webpack_require__(/*! ./session */ \"(rsc)/./node_modules/neo4j-driver-core/lib/session.js\"));\nvar util_1 = __webpack_require__(/*! ./internal/util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\nvar bookmark_manager_1 = __webpack_require__(/*! ./bookmark-manager */ \"(rsc)/./node_modules/neo4j-driver-core/lib/bookmark-manager.js\");\nvar result_transformers_1 = __importDefault(__webpack_require__(/*! ./result-transformers */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result-transformers.js\"));\nvar query_executor_1 = __importDefault(__webpack_require__(/*! ./internal/query-executor */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/query-executor.js\"));\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar homedb_cache_1 = __importDefault(__webpack_require__(/*! ./internal/homedb-cache */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/homedb-cache.js\"));\nvar auth_util_1 = __webpack_require__(/*! ./internal/auth-util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/auth-util.js\");\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\n/**\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\n * @type {number}\n */\nvar DEFAULT_FETCH_SIZE = 1000;\n/**\n * The maximum number of entries allowed in the home database cache before pruning.\n */\nvar HOMEDB_CACHE_MAX_SIZE = 10000;\n/**\n * Constant that represents read session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\n * @type {string}\n */\nvar READ = constants_1.ACCESS_MODE_READ;\nexports.READ = READ;\n/**\n * Constant that represents write session access mode.\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\n * @type {string}\n */\nvar WRITE = constants_1.ACCESS_MODE_WRITE;\nexports.WRITE = WRITE;\nvar idGenerator = 0;\n/**\n * The session configuration\n *\n * @interface\n */\nvar SessionConfig = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     */\n    function SessionConfig() {\n        /**\n         * The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\n         * **Default**: {@link WRITE}\n         * @type {string}\n         */\n        this.defaultAccessMode = WRITE;\n        /**\n         * The initial reference or references to some previous\n         * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\n         * @type {string|string[]|undefined}\n         */\n        this.bookmarks = [];\n        /**\n         * The database this session will operate on.\n         *\n         * This option has no explicit value by default, but it is recommended to set\n         * one if the target database is known in advance. This has the benefit of\n         * ensuring a consistent target database name throughout the session in a\n         * straightforward way and potentially simplifies driver logic as well as\n         * reduces network communication resulting in better performance.\n         *\n         * Usage of Cypher clauses like USE is not a replacement for this option.\n         * The driver does not parse any Cypher.\n         *\n         * When no explicit name is set, the driver behavior depends on the connection\n         * URI scheme supplied to the driver on instantiation and Bolt protocol\n         * version.\n         *\n         * Specifically, the following applies:\n         *\n         * - **bolt schemes** - queries are dispatched to the server for execution\n         *   without explicit database name supplied, meaning that the target database\n         *   name for query execution is determined by the server. It is important to\n         *   note that the target database may change (even within the same session),\n         *   for instance if the user's home database is changed on the server.\n         *\n         * - **neo4j schemes** - providing that Bolt protocol version 4.4, which was\n         *   introduced with Neo4j server 4.4, or above is available, the driver\n         *   fetches the user's home database name from the server on first query\n         *   execution within the session and uses the fetched database name\n         *   explicitly for all queries executed within the session. This ensures that\n         *   the database name remains consistent within the given session. For\n         *   instance, if the user's home database name is 'movies' and the server\n         *   supplies it to the driver upon database name fetching for the session,\n         *   all queries within that session are executed with the explicit database\n         *   name 'movies' supplied. Any change to the users home database is\n         *   reflected only in sessions created after such change takes effect. This\n         *   behavior requires additional network communication. In clustered\n         *   environments, it is strongly recommended to avoid a single point of\n         *   failure. For instance, by ensuring that the connection URI resolves to\n         *   multiple endpoints. For older Bolt protocol versions the behavior is the\n         *   same as described for the **bolt schemes** above.\n         *\n         * @type {string|undefined}\n         */\n        this.database = '';\n        /**\n         * The username which the user wants to impersonate for the duration of the session.\n         *\n         * @type {string|undefined}\n         */\n        this.impersonatedUser = undefined;\n        /**\n         * The {@link AuthToken} which will be used for the duration of the session.\n         *\n         * By default, the session will use connections authenticated with the {@link AuthToken} configured on\n         * driver creation. This configuration allows switching user and/or authorization information for the\n         * session lifetime.\n         *\n         * **Warning**: This option is only available when the driver is connected to Neo4j Database servers\n         * which supports Bolt 5.1 or newer.\n         *\n         * @type {AuthToken|undefined}\n         * @see {@link driver}\n         */\n        this.auth = undefined;\n        /**\n         * The record fetch size of each batch of this session.\n         *\n         * Use {@link FETCH_ALL} to always pull all records in one batch. This will override the config value set on driver config.\n         *\n         * @type {number|undefined}\n         */\n        this.fetchSize = undefined;\n        /**\n         * Configure a BookmarkManager for the session to use\n         *\n         * A BookmarkManager is a piece of software responsible for keeping casual consistency between different sessions by sharing bookmarks\n         * between the them.\n         * Enabling it is done by supplying an BookmarkManager implementation instance to this param.\n         * A default implementation could be acquired by calling the factory function {@link bookmarkManager}.\n         *\n         * **Warning**: Sharing the same BookmarkManager instance across multiple sessions can have a negative impact\n         * on performance since all the queries will wait for the latest changes being propagated across the cluster.\n         * For keeping consistency between a group of queries, use {@link Session} for grouping them.\n         * For keeping consistency between a group of sessions, use {@link BookmarkManager} instance for grouping them.\n         *\n         * @example\n         * const bookmarkManager = neo4j.bookmarkManager()\n         * const linkedSession1 = driver.session({ database:'neo4j', bookmarkManager })\n         * const linkedSession2 = driver.session({ database:'neo4j', bookmarkManager })\n         * const unlinkedSession = driver.session({ database:'neo4j' })\n         *\n         * // Creating Driver User\n         * const createUserQueryResult = await linkedSession1.run('CREATE (p:Person {name: $name})', { name: 'Driver User'})\n         *\n         * // Reading Driver User will *NOT* wait of the changes being propagated to the server before RUN the query\n         * // So the 'Driver User' person might not exist in the Result\n         * const unlinkedReadResult = await unlinkedSession.run('CREATE (p:Person {name: $name}) RETURN p', { name: 'Driver User'})\n         *\n         * // Reading Driver User will wait of the changes being propagated to the server before RUN the query\n         * // So the 'Driver User' person should exist in the Result, unless deleted.\n         * const linkedResult = await linkedSession2.run('CREATE (p:Person {name: $name}) RETURN p', { name: 'Driver User'})\n         *\n         * await linkedSession1.close()\n         * await linkedSession2.close()\n         * await unlinkedSession.close()\n         *\n         * @type {BookmarkManager|undefined}\n         * @since 5.0\n         */\n        this.bookmarkManager = undefined;\n        /**\n         * Configure filter for {@link Notification} objects returned in {@link ResultSummary#notifications}.\n         *\n         * This configuration enables filter notifications by:\n         *\n         * * the minimum severity level ({@link NotificationFilterMinimumSeverityLevel})\n         * * disabling notification categories ({@link NotificationFilterDisabledCategory})\n         *\n         *\n         * Disabling notifications can be done by defining the minimum severity level to 'OFF'.\n         * At driver level, when omitted, uses the server's default.\n         * At session level, when omitted, defaults to what filters have been configured at driver level.\n         *\n         * Disabling categories or severities allows the server to skip analysis for those, which can speed up query\n         * execution.\n         *\n         * @example\n         * // enabling warning notification, but disabling `HINT` and `DEPRECATION` notifications.\n         * const session = driver.session({\n         *     database: 'neo4j',\n         *     notificationFilter: {\n         *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.WARNING, // or 'WARNING\n         *         disabledCategories: [\n         *             neo4j.notificationFilterDisabledCategory.HINT, // or 'HINT'\n         *             neo4j.notificationFilterDisabledCategory.DEPRECATION // or 'DEPRECATION'\n         *        ]\n         *     }\n         * })\n         *\n         * @example\n         * // disabling notifications for a session\n         * const session = driver.session({\n         *     database: 'neo4j',\n         *     notificationFilter: {\n         *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.OFF // or 'OFF'\n         *     }\n         * })\n         *\n         * @example\n         * // using default values configured in the driver\n         * const sessionWithDefaultValues = driver.session({ database: 'neo4j' })\n         * // or driver.session({ database: 'neo4j', notificationFilter: undefined })\n         *\n         * // using default minimum severity level, but disabling 'HINT' and 'UNRECOGNIZED'\n         * // notification categories\n         * const sessionWithDefaultSeverityLevel = driver.session({\n         *     database: 'neo4j',\n         *     notificationFilter: {\n         *         disabledCategories: [\n         *             neo4j.notificationFilterDisabledCategory.HINT, // or 'HINT'\n         *             neo4j.notificationFilterDisabledCategory.UNRECOGNIZED // or 'UNRECOGNIZED'\n         *        ]\n         *     }\n         * })\n         *\n         * // using default disabled categories, but configuring minimum severity level to 'WARNING'\n         * const sessionWithDefaultSeverityLevel = driver.session({\n         *     database: 'neo4j',\n         *     notificationFilter: {\n         *         minimumSeverityLevel: neo4j.notificationFilterMinimumSeverityLevel.WARNING // or 'WARNING'\n         *     }\n         * })\n         *\n         * @type {NotificationFilter|undefined}\n         * @since 5.7\n         */\n        this.notificationFilter = undefined;\n    }\n    return SessionConfig;\n}());\nexports.SessionConfig = SessionConfig;\nvar ROUTING_WRITE = 'WRITE';\nvar ROUTING_READ = 'READ';\n/**\n * @typedef {'WRITE'|'READ'} RoutingControl\n */\n/**\n * Constants that represents routing modes.\n *\n * @example\n * driver.executeQuery(\"<QUERY>\", <PARAMETERS>, { routing: neo4j.routing.WRITE })\n */\nvar routing = {\n    WRITE: ROUTING_WRITE,\n    READ: ROUTING_READ\n};\nexports.routing = routing;\nObject.freeze(routing);\n/**\n * The query configuration\n * @interface\n */\nvar QueryConfig = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     */\n    function QueryConfig() {\n        /**\n         * Define the type of cluster member the query will be routed to.\n         *\n         * @type {RoutingControl}\n         */\n        this.routing = routing.WRITE;\n        /**\n         * Define the transformation will be applied to the Result before return from the\n         * query method.\n         *\n         * @type {ResultTransformer}\n         * @see {@link resultTransformers} for provided implementations.\n         */\n        this.resultTransformer = undefined;\n        /**\n         * The database this session will operate on.\n         *\n         * @type {string|undefined}\n         */\n        this.database = '';\n        /**\n         * The username which the user wants to impersonate for the duration of the query.\n         *\n         * @type {string|undefined}\n         */\n        this.impersonatedUser = undefined;\n        /**\n         * Configure a BookmarkManager for the session to use\n         *\n         * A BookmarkManager is a piece of software responsible for keeping casual consistency between different pieces of work by sharing bookmarks\n         * between the them.\n         *\n         * By default, it uses the driver's non mutable driver level bookmark manager. See, {@link Driver.executeQueryBookmarkManager}\n         *\n         * Can be set to null to disable causal chaining.\n         * @type {BookmarkManager|undefined|null}\n         */\n        this.bookmarkManager = undefined;\n        /**\n         * Configuration for all transactions started to execute the query.\n         *\n         * @type {TransactionConfig|undefined}\n         *\n         */\n        this.transactionConfig = undefined;\n        /**\n         * The {@link AuthToken} which will be used for executing the query.\n         *\n         * By default, the query executor will use connections authenticated with the {@link AuthToken} configured on\n         * driver creation. This configuration allows switching user and/or authorization information for the\n         * underlying transaction's lifetime.\n         *\n         * **Warning**: This option is only available when the driver is connected to Neo4j Database servers\n         * which support Bolt 5.1 or newer.\n         *\n         * @type {AuthToken|undefined}\n         * @see {@link driver}\n         */\n        this.auth = undefined;\n        /**\n         * The {@link AbortSignal} for aborting query execution.\n         *\n         * When aborted, the signal triggers the result consumption cancelation and\n         * transactions are reset. However, due to race conditions,\n         * there is no guarantee the transaction will be rolled back.\n         * Equivalent to {@link Session.close}\n         *\n         * **Warning**: This option is only available in runtime which supports AbortSignal.addEventListener.\n         *\n         * @since 5.22.0\n         * @type {AbortSignal|undefined}\n         * @experimental\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n         */\n        this.signal = undefined;\n    }\n    return QueryConfig;\n}());\nexports.QueryConfig = QueryConfig;\n/**\n * A driver maintains one or more {@link Session}s with a remote\n * Neo4j instance. Through the {@link Session}s you can send queries\n * and retrieve results from the database.\n *\n * Drivers are reasonably expensive to create - you should strive to keep one\n * driver instance around per Neo4j Instance you connect to.\n *\n * @access public\n */\nvar Driver = /** @class */ (function () {\n    /**\n     * You should not be calling this directly, instead use {@link driver}.\n     * @constructor\n     * @protected\n     * @param {Object} meta Metainformation about the driver\n     * @param {Object} config\n     * @param {function(id: number, config:Object, log:Logger, hostNameResolver: ConfiguredCustomResolver): ConnectionProvider } createConnectionProvider Creates the connection provider\n     * @param {function(args): Session } createSession Creates the a session\n    */\n    function Driver(meta, config, createConnectionProvider, createSession, createQueryExecutor) {\n        if (config === void 0) { config = {}; }\n        if (createSession === void 0) { createSession = function (args) { return new session_1.default(args); }; }\n        if (createQueryExecutor === void 0) { createQueryExecutor = function (createSession) { return new query_executor_1.default(createSession); }; }\n        sanitizeConfig(config);\n        var log = logger_1.Logger.create(config);\n        validateConfig(config, log);\n        this._id = idGenerator++;\n        this._meta = meta;\n        this._config = config;\n        this._log = log;\n        this._createConnectionProvider = createConnectionProvider;\n        this._createSession = createSession;\n        this._defaultExecuteQueryBookmarkManager = (0, bookmark_manager_1.bookmarkManager)();\n        this._queryExecutor = createQueryExecutor(this.session.bind(this));\n        /**\n         * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\n         * @type {ConnectionProvider}\n         * @protected\n         */\n        this._connectionProvider = null;\n        /**\n         * @private\n         */\n        this.homeDatabaseCache = new homedb_cache_1.default(HOMEDB_CACHE_MAX_SIZE);\n        this._afterConstruction();\n    }\n    Object.defineProperty(Driver.prototype, \"executeQueryBookmarkManager\", {\n        /**\n         * The bookmark managed used by {@link Driver.executeQuery}\n         *\n         * @type {BookmarkManager}\n         */\n        get: function () {\n            return this._defaultExecuteQueryBookmarkManager;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Executes a query in a retriable context and returns a {@link EagerResult}.\n     *\n     * This method is a shortcut for a {@link Session#executeRead} and {@link Session#executeWrite}.\n     *\n     * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n     * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n     * {@link Session#run} for these).\n     *\n     * @example\n     * // Run a simple write query\n     * const { keys, records, summary } = await driver.executeQuery('CREATE (p:Person{ name: $name }) RETURN p', { name: 'Person1'})\n     *\n     * @example\n     * // Run a read query\n     * const { keys, records, summary } = await driver.executeQuery(\n     *    'MATCH (p:Person{ name: $name }) RETURN p',\n     *    { name: 'Person1'},\n     *    { routing: neo4j.routing.READ})\n     *\n     * @example\n     * // Run a read query returning a Person Nodes per elementId\n     * const peopleMappedById = await driver.executeQuery(\n     *    'MATCH (p:Person{ name: $name }) RETURN p',\n     *    { name: 'Person1'},\n     *    {\n     *      resultTransformer: neo4j.resultTransformers.mappedResultTransformer({\n     *        map(record) {\n     *          const p = record.get('p')\n     *          return [p.elementId, p]\n     *        },\n     *        collect(elementIdPersonPairArray) {\n     *          return new Map(elementIdPersonPairArray)\n     *        }\n     *      })\n     *    }\n     * )\n     *\n     * const person = peopleMappedById.get(\"<ELEMENT_ID>\")\n     *\n     * @example\n     * // these lines\n     * const transformedResult = await driver.executeQuery(\n     *    \"<QUERY>\",\n     *    <PARAMETERS>,\n     *    {\n     *       routing: neo4j.routing.WRITE,\n     *       resultTransformer: transformer,\n     *       database: \"<DATABASE>\",\n     *       impersonatedUser: \"<USER>\",\n     *       bookmarkManager: bookmarkManager\n     *    })\n     * // are equivalent to those\n     * const session = driver.session({\n     *    database: \"<DATABASE>\",\n     *    impersonatedUser: \"<USER>\",\n     *    bookmarkManager: bookmarkManager\n     * })\n     *\n     * try {\n     *    const transformedResult = await session.executeWrite(tx => {\n     *        const result = tx.run(\"<QUERY>\", <PARAMETERS>)\n     *        return transformer(result)\n     *    })\n     * } finally {\n     *    await session.close()\n     * }\n     *\n     * @public\n     * @param {string | {text: string, parameters?: object}} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in the query\n     * @param {QueryConfig<T>} config - The query configuration\n     * @returns {Promise<T>}\n     *\n     * @see {@link resultTransformers} for provided result transformers.\n     */\n    Driver.prototype.executeQuery = function (query, parameters, config) {\n        var _a, _b, _c;\n        if (config === void 0) { config = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarkManager, resultTransformer, routingConfig;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        bookmarkManager = config.bookmarkManager === null ? undefined : ((_a = config.bookmarkManager) !== null && _a !== void 0 ? _a : this.executeQueryBookmarkManager);\n                        resultTransformer = ((_b = config.resultTransformer) !== null && _b !== void 0 ? _b : result_transformers_1.default.eagerResultTransformer());\n                        routingConfig = (_c = config.routing) !== null && _c !== void 0 ? _c : routing.WRITE;\n                        if (routingConfig !== routing.READ && routingConfig !== routing.WRITE) {\n                            throw (0, error_1.newError)(\"Illegal query routing config: \\\"\".concat(routingConfig, \"\\\"\"));\n                        }\n                        return [4 /*yield*/, this._queryExecutor.execute({\n                                resultTransformer: resultTransformer,\n                                bookmarkManager: bookmarkManager,\n                                routing: routingConfig,\n                                database: config.database,\n                                impersonatedUser: config.impersonatedUser,\n                                transactionConfig: config.transactionConfig,\n                                auth: config.auth,\n                                signal: config.signal\n                            }, query, parameters)];\n                    case 1: return [2 /*return*/, _d.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\n     *\n     * @deprecated This return of this method will change in 6.0.0 to not async return the {@link ServerInfo} and\n     * async return {@link void} instead. If you need to use the server info, use {@link getServerInfo} instead.\n     *\n     * @public\n     * @param {Object} param - The object parameter\n     * @param {string} param.database - The target database to verify connectivity for.\n     * @returns {Promise<ServerInfo>} promise resolved with server info or rejected with error.\n     */\n    Driver.prototype.verifyConnectivity = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.database, database = _c === void 0 ? '' : _c;\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.verifyConnectivityAndGetServerInfo({ database: database, accessMode: READ });\n    };\n    /**\n     * This method verifies the authorization credentials work by trying to acquire a connection\n     * to one of the servers with the given credentials.\n     *\n     * @param {object} param - object parameter\n     * @property {AuthToken} param.auth - the target auth for the to-be-acquired connection\n     * @property {string} param.database - the target database for the to-be-acquired connection\n     *\n     * @returns {Promise<boolean>} promise resolved with true if succeed, false if failed with\n     *  authentication issue and rejected with error if non-authentication error happens.\n     */\n    Driver.prototype.verifyAuthentication = function (_a) {\n        var _b = _a === void 0 ? {} : _a, database = _b.database, auth = _b.auth;\n        return __awaiter(this, void 0, void 0, function () {\n            var connectionProvider;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        connectionProvider = this._getOrCreateConnectionProvider();\n                        return [4 /*yield*/, connectionProvider.verifyAuthentication({\n                                database: database !== null && database !== void 0 ? database : 'system',\n                                auth: auth,\n                                accessMode: READ\n                            })];\n                    case 1: return [2 /*return*/, _c.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Get ServerInfo for the giver database.\n     *\n     * @param {Object} param - The object parameter\n     * @param {string} param.database - The target database to verify connectivity for.\n     * @returns {Promise<ServerInfo>} promise resolved with the ServerInfo or rejected with error.\n     */\n    Driver.prototype.getServerInfo = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.database, database = _c === void 0 ? '' : _c;\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.verifyConnectivityAndGetServerInfo({ database: database, accessMode: READ });\n    };\n    /**\n     * Returns whether the server supports multi database capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsMultiDb = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsMultiDb();\n    };\n    /**\n     * Returns whether the server supports transaction config capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsTransactionConfig = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsTransactionConfig();\n    };\n    /**\n     * Returns whether the server supports user impersonation capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsUserImpersonation = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsUserImpersonation();\n    };\n    /**\n     * Returns whether the driver session re-auth functionality capabilities based on the protocol\n     * version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\n     */\n    Driver.prototype.supportsSessionAuth = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.supportsSessionAuth();\n    };\n    /**\n     * Returns the protocol version negotiated via handshake.\n     *\n     * Note that this function call _always_ causes a round-trip to the server.\n     *\n     * @returns {Promise<number>} the protocol version negotiated via handshake.\n     * @throws {Error} When protocol negotiation fails\n     */\n    Driver.prototype.getNegotiatedProtocolVersion = function () {\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        return connectionProvider.getNegotiatedProtocolVersion();\n    };\n    /**\n     * Returns boolean to indicate if driver has been configured with encryption enabled.\n     *\n     * @returns {boolean}\n     */\n    Driver.prototype.isEncrypted = function () {\n        return this._isEncrypted();\n    };\n    /**\n     * @protected\n     * @returns {boolean}\n     */\n    Driver.prototype._supportsRouting = function () {\n        return this._meta.routing;\n    };\n    /**\n     * Returns boolean to indicate if driver has been configured with encryption enabled.\n     *\n     * @protected\n     * @returns {boolean}\n     */\n    Driver.prototype._isEncrypted = function () {\n        return this._config.encrypted === util_1.ENCRYPTION_ON || this._config.encrypted === true;\n    };\n    /**\n     * Returns the configured trust strategy that the driver has been configured with.\n     *\n     * @protected\n     * @returns {TrustStrategy}\n     */\n    Driver.prototype._getTrust = function () {\n        return this._config.trust;\n    };\n    /**\n     * Acquire a session to communicate with the database. The session will\n     * borrow connections from the underlying connection pool as required and\n     * should be considered lightweight and disposable.\n     *\n     * This comes with some responsibility - make sure you always call\n     * {@link close} when you are done using a session, and likewise,\n     * make sure you don't close your session before you are done using it. Once\n     * it is closed, the underlying connection will be released to the connection\n     * pool and made available for others to use.\n     *\n     * @public\n     * @param {SessionConfig} param - The session configuration\n     * @return {Session} new session.\n     */\n    Driver.prototype.session = function (_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultAccessMode, defaultAccessMode = _c === void 0 ? WRITE : _c, bookmarkOrBookmarks = _b.bookmarks, _d = _b.database, database = _d === void 0 ? '' : _d, impersonatedUser = _b.impersonatedUser, fetchSize = _b.fetchSize, bookmarkManager = _b.bookmarkManager, notificationFilter = _b.notificationFilter, auth = _b.auth;\n        return this._newSession({\n            defaultAccessMode: defaultAccessMode,\n            bookmarkOrBookmarks: bookmarkOrBookmarks,\n            database: database,\n            reactive: false,\n            impersonatedUser: impersonatedUser,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize),\n            bookmarkManager: bookmarkManager,\n            notificationFilter: notificationFilter,\n            auth: auth\n        });\n    };\n    /**\n     * Close all open sessions and other associated resources. You should\n     * make sure to use this when you are done with this driver instance.\n     *\n     * This will interrupt any running connections.\n     * Make sure you are done using the driver object and any resources\n     * spawned from it (such as sessions or transactions) while calling\n     * this method. Failing to do so will result in unspecified behavior.\n     *\n     * @public\n     * @return {Promise<void>} promise resolved when the driver is closed.\n     */\n    Driver.prototype.close = function () {\n        this._log.info(\"Driver \".concat(this._id, \" closing\"));\n        if (this._connectionProvider != null) {\n            return this._connectionProvider.close();\n        }\n        return Promise.resolve();\n    };\n    // eslint-disable-next-line\n    // @ts-ignore\n    Driver.prototype[Symbol.asyncDispose] = function () {\n        return this.close();\n    };\n    /**\n     * @protected\n     * @returns {void}\n     */\n    Driver.prototype._afterConstruction = function () {\n        this._log.info(\"\".concat(this._meta.typename, \" driver \").concat(this._id, \" created for server address \").concat(this._meta.address.toString()));\n    };\n    Driver.prototype._homeDatabaseCallback = function (cacheKey, database) {\n        this.homeDatabaseCache.set(cacheKey, database);\n    };\n    /**\n     * @private\n     */\n    Driver.prototype._newSession = function (_a) {\n        var defaultAccessMode = _a.defaultAccessMode, bookmarkOrBookmarks = _a.bookmarkOrBookmarks, database = _a.database, reactive = _a.reactive, impersonatedUser = _a.impersonatedUser, fetchSize = _a.fetchSize, bookmarkManager = _a.bookmarkManager, notificationFilter = _a.notificationFilter, auth = _a.auth;\n        var sessionMode = session_1.default._validateSessionMode(defaultAccessMode);\n        var connectionProvider = this._getOrCreateConnectionProvider();\n        // eslint-disable-next-line\n        var cachedHomeDatabase = this.homeDatabaseCache.get((0, auth_util_1.cacheKey)(auth, impersonatedUser));\n        var homeDatabaseCallback = this._homeDatabaseCallback.bind(this);\n        var bookmarks = bookmarkOrBookmarks != null\n            ? new bookmarks_1.Bookmarks(bookmarkOrBookmarks)\n            : bookmarks_1.Bookmarks.empty();\n        return this._createSession({\n            mode: sessionMode,\n            database: database !== null && database !== void 0 ? database : '',\n            connectionProvider: connectionProvider,\n            bookmarks: bookmarks,\n            config: __assign({ cachedHomeDatabase: cachedHomeDatabase, routingDriver: this._supportsRouting() }, this._config),\n            reactive: reactive,\n            impersonatedUser: impersonatedUser,\n            fetchSize: fetchSize,\n            bookmarkManager: bookmarkManager,\n            notificationFilter: notificationFilter,\n            auth: auth,\n            log: this._log,\n            homeDatabaseCallback: homeDatabaseCallback\n        });\n    };\n    /**\n     * @private\n     */\n    Driver.prototype._getOrCreateConnectionProvider = function () {\n        if (this._connectionProvider == null) {\n            this._connectionProvider = this._createConnectionProvider(this._id, this._config, this._log, createHostNameResolver(this._config));\n        }\n        return this._connectionProvider;\n    };\n    return Driver;\n}());\nexports.Driver = Driver;\n/**\n * @private\n * @returns {Object} the given config.\n */\nfunction validateConfig(config, log) {\n    var _a, _b;\n    var resolver = config.resolver;\n    if (resolver !== null && resolver !== undefined && typeof resolver !== 'function') {\n        throw new TypeError(\"Configured resolver should be a function. Got: \".concat(typeof resolver));\n    }\n    if (config.connectionAcquisitionTimeout < config.connectionTimeout) {\n        log.warn('Configuration for \"connectionAcquisitionTimeout\" should be greater than ' +\n            'or equal to \"connectionTimeout\". Otherwise, the connection acquisition ' +\n            'timeout will take precedence for over the connection timeout in scenarios ' +\n            'where a new connection is created while it is acquired');\n    }\n    if (((_a = config.notificationFilter) === null || _a === void 0 ? void 0 : _a.disabledCategories) != null && ((_b = config.notificationFilter) === null || _b === void 0 ? void 0 : _b.disabledClassifications) != null) {\n        throw new Error('The notificationFilter can\\'t have both \"disabledCategories\" and  \"disabledClassifications\" configured at the same time.');\n    }\n    return config;\n}\n/**\n * @private\n * @returns {void}\n */\nfunction sanitizeConfig(config) {\n    config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\n    config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, constants_1.DEFAULT_POOL_MAX_SIZE);\n    config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, constants_1.DEFAULT_POOL_ACQUISITION_TIMEOUT);\n    config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\n    config.connectionTimeout = extractConnectionTimeout(config);\n    config.connectionLivenessCheckTimeout =\n        validateConnectionLivenessCheckTimeoutSizeValue(config.connectionLivenessCheckTimeout);\n}\n/**\n * @private\n * @returns {number}\n */\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\n    var sanitizedValue = parseInt(rawValue, 10);\n    if (sanitizedValue > 0 || sanitizedValue === 0) {\n        return sanitizedValue;\n    }\n    else if (sanitizedValue < 0) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n    else {\n        return defaultWhenAbsent;\n    }\n}\n/**\n * @private\n */\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\n    var fetchSize = parseInt(rawValue, 10);\n    if (fetchSize > 0 || fetchSize === constants_1.FETCH_ALL) {\n        return fetchSize;\n    }\n    else if (fetchSize === 0 || fetchSize < 0) {\n        throw new Error(\"The fetch size can only be a positive value or \".concat(constants_1.FETCH_ALL, \" for ALL. However fetchSize = \").concat(fetchSize));\n    }\n    else {\n        return defaultWhenAbsent;\n    }\n}\n/**\n * @private\n */\nfunction extractConnectionTimeout(config) {\n    var configuredTimeout = parseInt(config.connectionTimeout, 10);\n    if (configuredTimeout === 0) {\n        // timeout explicitly configured to 0\n        return null;\n    }\n    else if (!isNaN(configuredTimeout) && configuredTimeout < 0) {\n        // timeout explicitly configured to a negative value\n        return null;\n    }\n    else if (isNaN(configuredTimeout)) {\n        // timeout not configured, use default value\n        return constants_1.DEFAULT_CONNECTION_TIMEOUT_MILLIS;\n    }\n    else {\n        // timeout configured, use the provided value\n        return configuredTimeout;\n    }\n}\n/**\n * @private\n */\nfunction validateConnectionLivenessCheckTimeoutSizeValue(rawValue) {\n    if (rawValue == null) {\n        return undefined;\n    }\n    var connectionLivenessCheckTimeout = parseInt(rawValue, 10);\n    if (connectionLivenessCheckTimeout < 0 || Number.isNaN(connectionLivenessCheckTimeout)) {\n        throw new Error(\"The connectionLivenessCheckTimeout can only be a positive value or 0 for always. However connectionLivenessCheckTimeout = \".concat(connectionLivenessCheckTimeout));\n    }\n    return connectionLivenessCheckTimeout;\n}\n/**\n * @private\n * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.\n *              If resolved function is not specified, it defaults to an identity resolver.\n */\nfunction createHostNameResolver(config) {\n    return new configured_custom_resolver_1.default(config.resolver);\n}\nexports[\"default\"] = Driver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2RyaXZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGNBQWM7QUFDN0csa0JBQWtCLG1CQUFPLENBQUMsOEZBQXNCO0FBQ2hELG1EQUFtRCxtQkFBTyxDQUFDLGtKQUFnRDtBQUMzRyxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDaEQsZUFBZSxtQkFBTyxDQUFDLHdGQUFtQjtBQUMxQyxnQ0FBZ0MsbUJBQU8sQ0FBQyx3RUFBVztBQUNuRCxhQUFhLG1CQUFPLENBQUMsb0ZBQWlCO0FBQ3RDLHlCQUF5QixtQkFBTyxDQUFDLDBGQUFvQjtBQUNyRCw0Q0FBNEMsbUJBQU8sQ0FBQyxnR0FBdUI7QUFDM0UsdUNBQXVDLG1CQUFPLENBQUMsd0dBQTJCO0FBQzFFLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUztBQUMvQixxQ0FBcUMsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDdEUsa0JBQWtCLG1CQUFPLENBQUMsOEZBQXNCO0FBQ2hELHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdUNBQXVDO0FBQ3RGLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSwrQ0FBK0Msd0NBQXdDO0FBQ3ZGLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVksS0FBSyxZQUFZO0FBQzdGLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxnRkFBZ0YsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixzQkFBc0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkYscUVBQXFFLHVCQUF1QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUNBQW1DO0FBQ3RGLG1EQUFtRCxtQ0FBbUM7QUFDdEYsb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0EscUZBQXFGLFlBQVksTUFBTSxvQkFBb0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFlBQVksZUFBZSxvQkFBb0I7QUFDbEk7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFlBQVksZUFBZSxvQkFBb0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0IscUJBQXFCLGtDQUFrQztBQUM1RztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkNBQTZDO0FBQ3ZGLGlEQUFpRCx5Q0FBeUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEYsa0NBQWtDLGtEQUFrRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOEJBQThCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsdUZBQXVGLGlCQUFpQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQjtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0hBQWtIO0FBQ2pJLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsd0NBQXdDLGtDQUFrQztBQUMxRSw4Q0FBOEMsaURBQWlEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxxQ0FBcUM7QUFDN0csa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGO0FBQ0Esd0NBQXdDLDJCQUEyQixLQUFLLDJCQUEyQjtBQUNuRztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCLCtDQUErQyxhQUFhLGVBQWUsZ0JBQWdCO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLDRCQUE0QixhQUFhO0FBQ3pDLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekMsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVSxvQ0FBb0M7QUFDN0QsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGtCQUFrQjtBQUM5RyxxQkFBcUIsWUFBWSxrREFBa0QscUJBQXFCO0FBQ3hHO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHVFQUF1RSxzQ0FBc0M7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0IsV0FBVztBQUM3QixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSx1RUFBdUUsc0NBQXNDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0ZBQWdGO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvZHJpdmVyLmpzP2JjYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWVyeUNvbmZpZyA9IGV4cG9ydHMuU2Vzc2lvbkNvbmZpZyA9IGV4cG9ydHMucm91dGluZyA9IGV4cG9ydHMuV1JJVEUgPSBleHBvcnRzLlJFQUQgPSBleHBvcnRzLkRyaXZlciA9IHZvaWQgMDtcbnZhciBib29rbWFya3NfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2Jvb2ttYXJrc1wiKTtcbnZhciBjb25maWd1cmVkX2N1c3RvbV9yZXNvbHZlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3Jlc29sdmVyL2NvbmZpZ3VyZWQtY3VzdG9tLXJlc29sdmVyXCIpKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2NvbnN0YW50c1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2xvZ2dlclwiKTtcbnZhciBzZXNzaW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2Vzc2lvblwiKSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvdXRpbFwiKTtcbnZhciBib29rbWFya19tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9ib29rbWFyay1tYW5hZ2VyXCIpO1xudmFyIHJlc3VsdF90cmFuc2Zvcm1lcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHQtdHJhbnNmb3JtZXJzXCIpKTtcbnZhciBxdWVyeV9leGVjdXRvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ludGVybmFsL3F1ZXJ5LWV4ZWN1dG9yXCIpKTtcbnZhciBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG52YXIgaG9tZWRiX2NhY2hlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vaW50ZXJuYWwvaG9tZWRiLWNhY2hlXCIpKTtcbnZhciBhdXRoX3V0aWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2F1dGgtdXRpbFwiKTtcbnZhciBERUZBVUxUX01BWF9DT05ORUNUSU9OX0xJRkVUSU1FID0gNjAgKiA2MCAqIDEwMDA7IC8vIDEgaG91clxuLyoqXG4gKiBUaGUgZGVmYXVsdCByZWNvcmQgZmV0Y2ggc2l6ZS4gVGhpcyBpcyB1c2VkIGluIEJvbHQgVjQgcHJvdG9jb2wgdG8gcHVsbCBxdWVyeSBleGVjdXRpb24gcmVzdWx0IGluIGJhdGNoZXMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgREVGQVVMVF9GRVRDSF9TSVpFID0gMTAwMDtcbi8qKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgYWxsb3dlZCBpbiB0aGUgaG9tZSBkYXRhYmFzZSBjYWNoZSBiZWZvcmUgcHJ1bmluZy5cbiAqL1xudmFyIEhPTUVEQl9DQUNIRV9NQVhfU0laRSA9IDEwMDAwO1xuLyoqXG4gKiBDb25zdGFudCB0aGF0IHJlcHJlc2VudHMgcmVhZCBzZXNzaW9uIGFjY2VzcyBtb2RlLlxuICogU2hvdWxkIGJlIHVzZWQgbGlrZSB0aGlzOiBgZHJpdmVyLnNlc3Npb24oeyBkZWZhdWx0QWNjZXNzTW9kZTogbmVvNGouc2Vzc2lvbi5SRUFEIH0pYC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBSRUFEID0gY29uc3RhbnRzXzEuQUNDRVNTX01PREVfUkVBRDtcbmV4cG9ydHMuUkVBRCA9IFJFQUQ7XG4vKipcbiAqIENvbnN0YW50IHRoYXQgcmVwcmVzZW50cyB3cml0ZSBzZXNzaW9uIGFjY2VzcyBtb2RlLlxuICogU2hvdWxkIGJlIHVzZWQgbGlrZSB0aGlzOiBgZHJpdmVyLnNlc3Npb24oeyBkZWZhdWx0QWNjZXNzTW9kZTogbmVvNGouc2Vzc2lvbi5XUklURSB9KWAuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgV1JJVEUgPSBjb25zdGFudHNfMS5BQ0NFU1NfTU9ERV9XUklURTtcbmV4cG9ydHMuV1JJVEUgPSBXUklURTtcbnZhciBpZEdlbmVyYXRvciA9IDA7XG4vKipcbiAqIFRoZSBzZXNzaW9uIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbnZhciBTZXNzaW9uQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2Vzc2lvbkNvbmZpZygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhY2Nlc3MgbW9kZSBvZiB0aGlzIHNlc3Npb24sIGFsbG93ZWQgdmFsdWVzIGFyZSB7QGxpbmsgUkVBRH0gYW5kIHtAbGluayBXUklURX0uXG4gICAgICAgICAqICoqRGVmYXVsdCoqOiB7QGxpbmsgV1JJVEV9XG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRBY2Nlc3NNb2RlID0gV1JJVEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5pdGlhbCByZWZlcmVuY2Ugb3IgcmVmZXJlbmNlcyB0byBzb21lIHByZXZpb3VzXG4gICAgICAgICAqIHRyYW5zYWN0aW9ucy4gVmFsdWUgaXMgb3B0aW9uYWwgYW5kIGFic2VuY2UgaW5kaWNhdGVzIHRoYXQgdGhhdCB0aGUgYm9va21hcmtzIGRvIG5vdCBleGlzdCBvciBhcmUgdW5rbm93bi5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXXx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvb2ttYXJrcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGFiYXNlIHRoaXMgc2Vzc2lvbiB3aWxsIG9wZXJhdGUgb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb3B0aW9uIGhhcyBubyBleHBsaWNpdCB2YWx1ZSBieSBkZWZhdWx0LCBidXQgaXQgaXMgcmVjb21tZW5kZWQgdG8gc2V0XG4gICAgICAgICAqIG9uZSBpZiB0aGUgdGFyZ2V0IGRhdGFiYXNlIGlzIGtub3duIGluIGFkdmFuY2UuIFRoaXMgaGFzIHRoZSBiZW5lZml0IG9mXG4gICAgICAgICAqIGVuc3VyaW5nIGEgY29uc2lzdGVudCB0YXJnZXQgZGF0YWJhc2UgbmFtZSB0aHJvdWdob3V0IHRoZSBzZXNzaW9uIGluIGFcbiAgICAgICAgICogc3RyYWlnaHRmb3J3YXJkIHdheSBhbmQgcG90ZW50aWFsbHkgc2ltcGxpZmllcyBkcml2ZXIgbG9naWMgYXMgd2VsbCBhc1xuICAgICAgICAgKiByZWR1Y2VzIG5ldHdvcmsgY29tbXVuaWNhdGlvbiByZXN1bHRpbmcgaW4gYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2FnZSBvZiBDeXBoZXIgY2xhdXNlcyBsaWtlIFVTRSBpcyBub3QgYSByZXBsYWNlbWVudCBmb3IgdGhpcyBvcHRpb24uXG4gICAgICAgICAqIFRoZSBkcml2ZXIgZG9lcyBub3QgcGFyc2UgYW55IEN5cGhlci5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBubyBleHBsaWNpdCBuYW1lIGlzIHNldCwgdGhlIGRyaXZlciBiZWhhdmlvciBkZXBlbmRzIG9uIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAqIFVSSSBzY2hlbWUgc3VwcGxpZWQgdG8gdGhlIGRyaXZlciBvbiBpbnN0YW50aWF0aW9uIGFuZCBCb2x0IHByb3RvY29sXG4gICAgICAgICAqIHZlcnNpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFNwZWNpZmljYWxseSwgdGhlIGZvbGxvd2luZyBhcHBsaWVzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAtICoqYm9sdCBzY2hlbWVzKiogLSBxdWVyaWVzIGFyZSBkaXNwYXRjaGVkIHRvIHRoZSBzZXJ2ZXIgZm9yIGV4ZWN1dGlvblxuICAgICAgICAgKiAgIHdpdGhvdXQgZXhwbGljaXQgZGF0YWJhc2UgbmFtZSBzdXBwbGllZCwgbWVhbmluZyB0aGF0IHRoZSB0YXJnZXQgZGF0YWJhc2VcbiAgICAgICAgICogICBuYW1lIGZvciBxdWVyeSBleGVjdXRpb24gaXMgZGV0ZXJtaW5lZCBieSB0aGUgc2VydmVyLiBJdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgICogICBub3RlIHRoYXQgdGhlIHRhcmdldCBkYXRhYmFzZSBtYXkgY2hhbmdlIChldmVuIHdpdGhpbiB0aGUgc2FtZSBzZXNzaW9uKSxcbiAgICAgICAgICogICBmb3IgaW5zdGFuY2UgaWYgdGhlIHVzZXIncyBob21lIGRhdGFiYXNlIGlzIGNoYW5nZWQgb24gdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogLSAqKm5lbzRqIHNjaGVtZXMqKiAtIHByb3ZpZGluZyB0aGF0IEJvbHQgcHJvdG9jb2wgdmVyc2lvbiA0LjQsIHdoaWNoIHdhc1xuICAgICAgICAgKiAgIGludHJvZHVjZWQgd2l0aCBOZW80aiBzZXJ2ZXIgNC40LCBvciBhYm92ZSBpcyBhdmFpbGFibGUsIHRoZSBkcml2ZXJcbiAgICAgICAgICogICBmZXRjaGVzIHRoZSB1c2VyJ3MgaG9tZSBkYXRhYmFzZSBuYW1lIGZyb20gdGhlIHNlcnZlciBvbiBmaXJzdCBxdWVyeVxuICAgICAgICAgKiAgIGV4ZWN1dGlvbiB3aXRoaW4gdGhlIHNlc3Npb24gYW5kIHVzZXMgdGhlIGZldGNoZWQgZGF0YWJhc2UgbmFtZVxuICAgICAgICAgKiAgIGV4cGxpY2l0bHkgZm9yIGFsbCBxdWVyaWVzIGV4ZWN1dGVkIHdpdGhpbiB0aGUgc2Vzc2lvbi4gVGhpcyBlbnN1cmVzIHRoYXRcbiAgICAgICAgICogICB0aGUgZGF0YWJhc2UgbmFtZSByZW1haW5zIGNvbnNpc3RlbnQgd2l0aGluIHRoZSBnaXZlbiBzZXNzaW9uLiBGb3JcbiAgICAgICAgICogICBpbnN0YW5jZSwgaWYgdGhlIHVzZXIncyBob21lIGRhdGFiYXNlIG5hbWUgaXMgJ21vdmllcycgYW5kIHRoZSBzZXJ2ZXJcbiAgICAgICAgICogICBzdXBwbGllcyBpdCB0byB0aGUgZHJpdmVyIHVwb24gZGF0YWJhc2UgbmFtZSBmZXRjaGluZyBmb3IgdGhlIHNlc3Npb24sXG4gICAgICAgICAqICAgYWxsIHF1ZXJpZXMgd2l0aGluIHRoYXQgc2Vzc2lvbiBhcmUgZXhlY3V0ZWQgd2l0aCB0aGUgZXhwbGljaXQgZGF0YWJhc2VcbiAgICAgICAgICogICBuYW1lICdtb3ZpZXMnIHN1cHBsaWVkLiBBbnkgY2hhbmdlIHRvIHRoZSB1c2Vy4oCZcyBob21lIGRhdGFiYXNlIGlzXG4gICAgICAgICAqICAgcmVmbGVjdGVkIG9ubHkgaW4gc2Vzc2lvbnMgY3JlYXRlZCBhZnRlciBzdWNoIGNoYW5nZSB0YWtlcyBlZmZlY3QuIFRoaXNcbiAgICAgICAgICogICBiZWhhdmlvciByZXF1aXJlcyBhZGRpdGlvbmFsIG5ldHdvcmsgY29tbXVuaWNhdGlvbi4gSW4gY2x1c3RlcmVkXG4gICAgICAgICAqICAgZW52aXJvbm1lbnRzLCBpdCBpcyBzdHJvbmdseSByZWNvbW1lbmRlZCB0byBhdm9pZCBhIHNpbmdsZSBwb2ludCBvZlxuICAgICAgICAgKiAgIGZhaWx1cmUuIEZvciBpbnN0YW5jZSwgYnkgZW5zdXJpbmcgdGhhdCB0aGUgY29ubmVjdGlvbiBVUkkgcmVzb2x2ZXMgdG9cbiAgICAgICAgICogICBtdWx0aXBsZSBlbmRwb2ludHMuIEZvciBvbGRlciBCb2x0IHByb3RvY29sIHZlcnNpb25zIHRoZSBiZWhhdmlvciBpcyB0aGVcbiAgICAgICAgICogICBzYW1lIGFzIGRlc2NyaWJlZCBmb3IgdGhlICoqYm9sdCBzY2hlbWVzKiogYWJvdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhYmFzZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXJuYW1lIHdoaWNoIHRoZSB1c2VyIHdhbnRzIHRvIGltcGVyc29uYXRlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIHNlc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbXBlcnNvbmF0ZWRVc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHtAbGluayBBdXRoVG9rZW59IHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBzZXNzaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgc2Vzc2lvbiB3aWxsIHVzZSBjb25uZWN0aW9ucyBhdXRoZW50aWNhdGVkIHdpdGggdGhlIHtAbGluayBBdXRoVG9rZW59IGNvbmZpZ3VyZWQgb25cbiAgICAgICAgICogZHJpdmVyIGNyZWF0aW9uLiBUaGlzIGNvbmZpZ3VyYXRpb24gYWxsb3dzIHN3aXRjaGluZyB1c2VyIGFuZC9vciBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIGZvciB0aGVcbiAgICAgICAgICogc2Vzc2lvbiBsaWZldGltZS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipXYXJuaW5nKio6IFRoaXMgb3B0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIGRyaXZlciBpcyBjb25uZWN0ZWQgdG8gTmVvNGogRGF0YWJhc2Ugc2VydmVyc1xuICAgICAgICAgKiB3aGljaCBzdXBwb3J0cyBCb2x0IDUuMSBvciBuZXdlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0F1dGhUb2tlbnx1bmRlZmluZWR9XG4gICAgICAgICAqIEBzZWUge0BsaW5rIGRyaXZlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWNvcmQgZmV0Y2ggc2l6ZSBvZiBlYWNoIGJhdGNoIG9mIHRoaXMgc2Vzc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIHtAbGluayBGRVRDSF9BTEx9IHRvIGFsd2F5cyBwdWxsIGFsbCByZWNvcmRzIGluIG9uZSBiYXRjaC4gVGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBjb25maWcgdmFsdWUgc2V0IG9uIGRyaXZlciBjb25maWcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mZXRjaFNpemUgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmUgYSBCb29rbWFya01hbmFnZXIgZm9yIHRoZSBzZXNzaW9uIHRvIHVzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBBIEJvb2ttYXJrTWFuYWdlciBpcyBhIHBpZWNlIG9mIHNvZnR3YXJlIHJlc3BvbnNpYmxlIGZvciBrZWVwaW5nIGNhc3VhbCBjb25zaXN0ZW5jeSBiZXR3ZWVuIGRpZmZlcmVudCBzZXNzaW9ucyBieSBzaGFyaW5nIGJvb2ttYXJrc1xuICAgICAgICAgKiBiZXR3ZWVuIHRoZSB0aGVtLlxuICAgICAgICAgKiBFbmFibGluZyBpdCBpcyBkb25lIGJ5IHN1cHBseWluZyBhbiBCb29rbWFya01hbmFnZXIgaW1wbGVtZW50YXRpb24gaW5zdGFuY2UgdG8gdGhpcyBwYXJhbS5cbiAgICAgICAgICogQSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGFjcXVpcmVkIGJ5IGNhbGxpbmcgdGhlIGZhY3RvcnkgZnVuY3Rpb24ge0BsaW5rIGJvb2ttYXJrTWFuYWdlcn0uXG4gICAgICAgICAqXG4gICAgICAgICAqICoqV2FybmluZyoqOiBTaGFyaW5nIHRoZSBzYW1lIEJvb2ttYXJrTWFuYWdlciBpbnN0YW5jZSBhY3Jvc3MgbXVsdGlwbGUgc2Vzc2lvbnMgY2FuIGhhdmUgYSBuZWdhdGl2ZSBpbXBhY3RcbiAgICAgICAgICogb24gcGVyZm9ybWFuY2Ugc2luY2UgYWxsIHRoZSBxdWVyaWVzIHdpbGwgd2FpdCBmb3IgdGhlIGxhdGVzdCBjaGFuZ2VzIGJlaW5nIHByb3BhZ2F0ZWQgYWNyb3NzIHRoZSBjbHVzdGVyLlxuICAgICAgICAgKiBGb3Iga2VlcGluZyBjb25zaXN0ZW5jeSBiZXR3ZWVuIGEgZ3JvdXAgb2YgcXVlcmllcywgdXNlIHtAbGluayBTZXNzaW9ufSBmb3IgZ3JvdXBpbmcgdGhlbS5cbiAgICAgICAgICogRm9yIGtlZXBpbmcgY29uc2lzdGVuY3kgYmV0d2VlbiBhIGdyb3VwIG9mIHNlc3Npb25zLCB1c2Uge0BsaW5rIEJvb2ttYXJrTWFuYWdlcn0gaW5zdGFuY2UgZm9yIGdyb3VwaW5nIHRoZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGJvb2ttYXJrTWFuYWdlciA9IG5lbzRqLmJvb2ttYXJrTWFuYWdlcigpXG4gICAgICAgICAqIGNvbnN0IGxpbmtlZFNlc3Npb24xID0gZHJpdmVyLnNlc3Npb24oeyBkYXRhYmFzZTonbmVvNGonLCBib29rbWFya01hbmFnZXIgfSlcbiAgICAgICAgICogY29uc3QgbGlua2VkU2Vzc2lvbjIgPSBkcml2ZXIuc2Vzc2lvbih7IGRhdGFiYXNlOiduZW80aicsIGJvb2ttYXJrTWFuYWdlciB9KVxuICAgICAgICAgKiBjb25zdCB1bmxpbmtlZFNlc3Npb24gPSBkcml2ZXIuc2Vzc2lvbih7IGRhdGFiYXNlOiduZW80aicgfSlcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gQ3JlYXRpbmcgRHJpdmVyIFVzZXJcbiAgICAgICAgICogY29uc3QgY3JlYXRlVXNlclF1ZXJ5UmVzdWx0ID0gYXdhaXQgbGlua2VkU2Vzc2lvbjEucnVuKCdDUkVBVEUgKHA6UGVyc29uIHtuYW1lOiAkbmFtZX0pJywgeyBuYW1lOiAnRHJpdmVyIFVzZXInfSlcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUmVhZGluZyBEcml2ZXIgVXNlciB3aWxsICpOT1QqIHdhaXQgb2YgdGhlIGNoYW5nZXMgYmVpbmcgcHJvcGFnYXRlZCB0byB0aGUgc2VydmVyIGJlZm9yZSBSVU4gdGhlIHF1ZXJ5XG4gICAgICAgICAqIC8vIFNvIHRoZSAnRHJpdmVyIFVzZXInIHBlcnNvbiBtaWdodCBub3QgZXhpc3QgaW4gdGhlIFJlc3VsdFxuICAgICAgICAgKiBjb25zdCB1bmxpbmtlZFJlYWRSZXN1bHQgPSBhd2FpdCB1bmxpbmtlZFNlc3Npb24ucnVuKCdDUkVBVEUgKHA6UGVyc29uIHtuYW1lOiAkbmFtZX0pIFJFVFVSTiBwJywgeyBuYW1lOiAnRHJpdmVyIFVzZXInfSlcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gUmVhZGluZyBEcml2ZXIgVXNlciB3aWxsIHdhaXQgb2YgdGhlIGNoYW5nZXMgYmVpbmcgcHJvcGFnYXRlZCB0byB0aGUgc2VydmVyIGJlZm9yZSBSVU4gdGhlIHF1ZXJ5XG4gICAgICAgICAqIC8vIFNvIHRoZSAnRHJpdmVyIFVzZXInIHBlcnNvbiBzaG91bGQgZXhpc3QgaW4gdGhlIFJlc3VsdCwgdW5sZXNzIGRlbGV0ZWQuXG4gICAgICAgICAqIGNvbnN0IGxpbmtlZFJlc3VsdCA9IGF3YWl0IGxpbmtlZFNlc3Npb24yLnJ1bignQ1JFQVRFIChwOlBlcnNvbiB7bmFtZTogJG5hbWV9KSBSRVRVUk4gcCcsIHsgbmFtZTogJ0RyaXZlciBVc2VyJ30pXG4gICAgICAgICAqXG4gICAgICAgICAqIGF3YWl0IGxpbmtlZFNlc3Npb24xLmNsb3NlKClcbiAgICAgICAgICogYXdhaXQgbGlua2VkU2Vzc2lvbjIuY2xvc2UoKVxuICAgICAgICAgKiBhd2FpdCB1bmxpbmtlZFNlc3Npb24uY2xvc2UoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Qm9va21hcmtNYW5hZ2VyfHVuZGVmaW5lZH1cbiAgICAgICAgICogQHNpbmNlIDUuMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib29rbWFya01hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmUgZmlsdGVyIGZvciB7QGxpbmsgTm90aWZpY2F0aW9ufSBvYmplY3RzIHJldHVybmVkIGluIHtAbGluayBSZXN1bHRTdW1tYXJ5I25vdGlmaWNhdGlvbnN9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGNvbmZpZ3VyYXRpb24gZW5hYmxlcyBmaWx0ZXIgbm90aWZpY2F0aW9ucyBieTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiB0aGUgbWluaW11bSBzZXZlcml0eSBsZXZlbCAoe0BsaW5rIE5vdGlmaWNhdGlvbkZpbHRlck1pbmltdW1TZXZlcml0eUxldmVsfSlcbiAgICAgICAgICogKiBkaXNhYmxpbmcgbm90aWZpY2F0aW9uIGNhdGVnb3JpZXMgKHtAbGluayBOb3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENhdGVnb3J5fSlcbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogRGlzYWJsaW5nIG5vdGlmaWNhdGlvbnMgY2FuIGJlIGRvbmUgYnkgZGVmaW5pbmcgdGhlIG1pbmltdW0gc2V2ZXJpdHkgbGV2ZWwgdG8gJ09GRicuXG4gICAgICAgICAqIEF0IGRyaXZlciBsZXZlbCwgd2hlbiBvbWl0dGVkLCB1c2VzIHRoZSBzZXJ2ZXIncyBkZWZhdWx0LlxuICAgICAgICAgKiBBdCBzZXNzaW9uIGxldmVsLCB3aGVuIG9taXR0ZWQsIGRlZmF1bHRzIHRvIHdoYXQgZmlsdGVycyBoYXZlIGJlZW4gY29uZmlndXJlZCBhdCBkcml2ZXIgbGV2ZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIERpc2FibGluZyBjYXRlZ29yaWVzIG9yIHNldmVyaXRpZXMgYWxsb3dzIHRoZSBzZXJ2ZXIgdG8gc2tpcCBhbmFseXNpcyBmb3IgdGhvc2UsIHdoaWNoIGNhbiBzcGVlZCB1cCBxdWVyeVxuICAgICAgICAgKiBleGVjdXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGVuYWJsaW5nIHdhcm5pbmcgbm90aWZpY2F0aW9uLCBidXQgZGlzYWJsaW5nIGBISU5UYCBhbmQgYERFUFJFQ0FUSU9OYCBub3RpZmljYXRpb25zLlxuICAgICAgICAgKiBjb25zdCBzZXNzaW9uID0gZHJpdmVyLnNlc3Npb24oe1xuICAgICAgICAgKiAgICAgZGF0YWJhc2U6ICduZW80aicsXG4gICAgICAgICAqICAgICBub3RpZmljYXRpb25GaWx0ZXI6IHtcbiAgICAgICAgICogICAgICAgICBtaW5pbXVtU2V2ZXJpdHlMZXZlbDogbmVvNGoubm90aWZpY2F0aW9uRmlsdGVyTWluaW11bVNldmVyaXR5TGV2ZWwuV0FSTklORywgLy8gb3IgJ1dBUk5JTkdcbiAgICAgICAgICogICAgICAgICBkaXNhYmxlZENhdGVnb3JpZXM6IFtcbiAgICAgICAgICogICAgICAgICAgICAgbmVvNGoubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDYXRlZ29yeS5ISU5ULCAvLyBvciAnSElOVCdcbiAgICAgICAgICogICAgICAgICAgICAgbmVvNGoubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDYXRlZ29yeS5ERVBSRUNBVElPTiAvLyBvciAnREVQUkVDQVRJT04nXG4gICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGRpc2FibGluZyBub3RpZmljYXRpb25zIGZvciBhIHNlc3Npb25cbiAgICAgICAgICogY29uc3Qgc2Vzc2lvbiA9IGRyaXZlci5zZXNzaW9uKHtcbiAgICAgICAgICogICAgIGRhdGFiYXNlOiAnbmVvNGonLFxuICAgICAgICAgKiAgICAgbm90aWZpY2F0aW9uRmlsdGVyOiB7XG4gICAgICAgICAqICAgICAgICAgbWluaW11bVNldmVyaXR5TGV2ZWw6IG5lbzRqLm5vdGlmaWNhdGlvbkZpbHRlck1pbmltdW1TZXZlcml0eUxldmVsLk9GRiAvLyBvciAnT0ZGJ1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyB1c2luZyBkZWZhdWx0IHZhbHVlcyBjb25maWd1cmVkIGluIHRoZSBkcml2ZXJcbiAgICAgICAgICogY29uc3Qgc2Vzc2lvbldpdGhEZWZhdWx0VmFsdWVzID0gZHJpdmVyLnNlc3Npb24oeyBkYXRhYmFzZTogJ25lbzRqJyB9KVxuICAgICAgICAgKiAvLyBvciBkcml2ZXIuc2Vzc2lvbih7IGRhdGFiYXNlOiAnbmVvNGonLCBub3RpZmljYXRpb25GaWx0ZXI6IHVuZGVmaW5lZCB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAvLyB1c2luZyBkZWZhdWx0IG1pbmltdW0gc2V2ZXJpdHkgbGV2ZWwsIGJ1dCBkaXNhYmxpbmcgJ0hJTlQnIGFuZCAnVU5SRUNPR05JWkVEJ1xuICAgICAgICAgKiAvLyBub3RpZmljYXRpb24gY2F0ZWdvcmllc1xuICAgICAgICAgKiBjb25zdCBzZXNzaW9uV2l0aERlZmF1bHRTZXZlcml0eUxldmVsID0gZHJpdmVyLnNlc3Npb24oe1xuICAgICAgICAgKiAgICAgZGF0YWJhc2U6ICduZW80aicsXG4gICAgICAgICAqICAgICBub3RpZmljYXRpb25GaWx0ZXI6IHtcbiAgICAgICAgICogICAgICAgICBkaXNhYmxlZENhdGVnb3JpZXM6IFtcbiAgICAgICAgICogICAgICAgICAgICAgbmVvNGoubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDYXRlZ29yeS5ISU5ULCAvLyBvciAnSElOVCdcbiAgICAgICAgICogICAgICAgICAgICAgbmVvNGoubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDYXRlZ29yeS5VTlJFQ09HTklaRUQgLy8gb3IgJ1VOUkVDT0dOSVpFRCdcbiAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICogfSlcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gdXNpbmcgZGVmYXVsdCBkaXNhYmxlZCBjYXRlZ29yaWVzLCBidXQgY29uZmlndXJpbmcgbWluaW11bSBzZXZlcml0eSBsZXZlbCB0byAnV0FSTklORydcbiAgICAgICAgICogY29uc3Qgc2Vzc2lvbldpdGhEZWZhdWx0U2V2ZXJpdHlMZXZlbCA9IGRyaXZlci5zZXNzaW9uKHtcbiAgICAgICAgICogICAgIGRhdGFiYXNlOiAnbmVvNGonLFxuICAgICAgICAgKiAgICAgbm90aWZpY2F0aW9uRmlsdGVyOiB7XG4gICAgICAgICAqICAgICAgICAgbWluaW11bVNldmVyaXR5TGV2ZWw6IG5lbzRqLm5vdGlmaWNhdGlvbkZpbHRlck1pbmltdW1TZXZlcml0eUxldmVsLldBUk5JTkcgLy8gb3IgJ1dBUk5JTkcnXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtOb3RpZmljYXRpb25GaWx0ZXJ8dW5kZWZpbmVkfVxuICAgICAgICAgKiBAc2luY2UgNS43XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbkZpbHRlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIFNlc3Npb25Db25maWc7XG59KCkpO1xuZXhwb3J0cy5TZXNzaW9uQ29uZmlnID0gU2Vzc2lvbkNvbmZpZztcbnZhciBST1VUSU5HX1dSSVRFID0gJ1dSSVRFJztcbnZhciBST1VUSU5HX1JFQUQgPSAnUkVBRCc7XG4vKipcbiAqIEB0eXBlZGVmIHsnV1JJVEUnfCdSRUFEJ30gUm91dGluZ0NvbnRyb2xcbiAqL1xuLyoqXG4gKiBDb25zdGFudHMgdGhhdCByZXByZXNlbnRzIHJvdXRpbmcgbW9kZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGRyaXZlci5leGVjdXRlUXVlcnkoXCI8UVVFUlk+XCIsIDxQQVJBTUVURVJTPiwgeyByb3V0aW5nOiBuZW80ai5yb3V0aW5nLldSSVRFIH0pXG4gKi9cbnZhciByb3V0aW5nID0ge1xuICAgIFdSSVRFOiBST1VUSU5HX1dSSVRFLFxuICAgIFJFQUQ6IFJPVVRJTkdfUkVBRFxufTtcbmV4cG9ydHMucm91dGluZyA9IHJvdXRpbmc7XG5PYmplY3QuZnJlZXplKHJvdXRpbmcpO1xuLyoqXG4gKiBUaGUgcXVlcnkgY29uZmlndXJhdGlvblxuICogQGludGVyZmFjZVxuICovXG52YXIgUXVlcnlDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWVyeUNvbmZpZygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSB0aGUgdHlwZSBvZiBjbHVzdGVyIG1lbWJlciB0aGUgcXVlcnkgd2lsbCBiZSByb3V0ZWQgdG8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtSb3V0aW5nQ29udHJvbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm91dGluZyA9IHJvdXRpbmcuV1JJVEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmUgdGhlIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgUmVzdWx0IGJlZm9yZSByZXR1cm4gZnJvbSB0aGVcbiAgICAgICAgICogcXVlcnkgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7UmVzdWx0VHJhbnNmb3JtZXJ9XG4gICAgICAgICAqIEBzZWUge0BsaW5rIHJlc3VsdFRyYW5zZm9ybWVyc30gZm9yIHByb3ZpZGVkIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzdWx0VHJhbnNmb3JtZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YWJhc2UgdGhpcyBzZXNzaW9uIHdpbGwgb3BlcmF0ZSBvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFiYXNlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdXNlcm5hbWUgd2hpY2ggdGhlIHVzZXIgd2FudHMgdG8gaW1wZXJzb25hdGUgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgcXVlcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbXBlcnNvbmF0ZWRVc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlIGEgQm9va21hcmtNYW5hZ2VyIGZvciB0aGUgc2Vzc2lvbiB0byB1c2VcbiAgICAgICAgICpcbiAgICAgICAgICogQSBCb29rbWFya01hbmFnZXIgaXMgYSBwaWVjZSBvZiBzb2Z0d2FyZSByZXNwb25zaWJsZSBmb3Iga2VlcGluZyBjYXN1YWwgY29uc2lzdGVuY3kgYmV0d2VlbiBkaWZmZXJlbnQgcGllY2VzIG9mIHdvcmsgYnkgc2hhcmluZyBib29rbWFya3NcbiAgICAgICAgICogYmV0d2VlbiB0aGUgdGhlbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgaXQgdXNlcyB0aGUgZHJpdmVyJ3Mgbm9uIG11dGFibGUgZHJpdmVyIGxldmVsIGJvb2ttYXJrIG1hbmFnZXIuIFNlZSwge0BsaW5rIERyaXZlci5leGVjdXRlUXVlcnlCb29rbWFya01hbmFnZXJ9XG4gICAgICAgICAqXG4gICAgICAgICAqIENhbiBiZSBzZXQgdG8gbnVsbCB0byBkaXNhYmxlIGNhdXNhbCBjaGFpbmluZy5cbiAgICAgICAgICogQHR5cGUge0Jvb2ttYXJrTWFuYWdlcnx1bmRlZmluZWR8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm9va21hcmtNYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBmb3IgYWxsIHRyYW5zYWN0aW9ucyBzdGFydGVkIHRvIGV4ZWN1dGUgdGhlIHF1ZXJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7VHJhbnNhY3Rpb25Db25maWd8dW5kZWZpbmVkfVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbkNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB7QGxpbmsgQXV0aFRva2VufSB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGV4ZWN1dGluZyB0aGUgcXVlcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBxdWVyeSBleGVjdXRvciB3aWxsIHVzZSBjb25uZWN0aW9ucyBhdXRoZW50aWNhdGVkIHdpdGggdGhlIHtAbGluayBBdXRoVG9rZW59IGNvbmZpZ3VyZWQgb25cbiAgICAgICAgICogZHJpdmVyIGNyZWF0aW9uLiBUaGlzIGNvbmZpZ3VyYXRpb24gYWxsb3dzIHN3aXRjaGluZyB1c2VyIGFuZC9vciBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIGZvciB0aGVcbiAgICAgICAgICogdW5kZXJseWluZyB0cmFuc2FjdGlvbidzIGxpZmV0aW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKldhcm5pbmcqKjogVGhpcyBvcHRpb24gaXMgb25seSBhdmFpbGFibGUgd2hlbiB0aGUgZHJpdmVyIGlzIGNvbm5lY3RlZCB0byBOZW80aiBEYXRhYmFzZSBzZXJ2ZXJzXG4gICAgICAgICAqIHdoaWNoIHN1cHBvcnQgQm9sdCA1LjEgb3IgbmV3ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtBdXRoVG9rZW58dW5kZWZpbmVkfVxuICAgICAgICAgKiBAc2VlIHtAbGluayBkcml2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dGggPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUge0BsaW5rIEFib3J0U2lnbmFsfSBmb3IgYWJvcnRpbmcgcXVlcnkgZXhlY3V0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIGFib3J0ZWQsIHRoZSBzaWduYWwgdHJpZ2dlcnMgdGhlIHJlc3VsdCBjb25zdW1wdGlvbiBjYW5jZWxhdGlvbiBhbmRcbiAgICAgICAgICogdHJhbnNhY3Rpb25zIGFyZSByZXNldC4gSG93ZXZlciwgZHVlIHRvIHJhY2UgY29uZGl0aW9ucyxcbiAgICAgICAgICogdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJvbGxlZCBiYWNrLlxuICAgICAgICAgKiBFcXVpdmFsZW50IHRvIHtAbGluayBTZXNzaW9uLmNsb3NlfVxuICAgICAgICAgKlxuICAgICAgICAgKiAqKldhcm5pbmcqKjogVGhpcyBvcHRpb24gaXMgb25seSBhdmFpbGFibGUgaW4gcnVudGltZSB3aGljaCBzdXBwb3J0cyBBYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2luY2UgNS4yMi4wXG4gICAgICAgICAqIEB0eXBlIHtBYm9ydFNpZ25hbHx1bmRlZmluZWR9XG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaWduYWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBRdWVyeUNvbmZpZztcbn0oKSk7XG5leHBvcnRzLlF1ZXJ5Q29uZmlnID0gUXVlcnlDb25maWc7XG4vKipcbiAqIEEgZHJpdmVyIG1haW50YWlucyBvbmUgb3IgbW9yZSB7QGxpbmsgU2Vzc2lvbn1zIHdpdGggYSByZW1vdGVcbiAqIE5lbzRqIGluc3RhbmNlLiBUaHJvdWdoIHRoZSB7QGxpbmsgU2Vzc2lvbn1zIHlvdSBjYW4gc2VuZCBxdWVyaWVzXG4gKiBhbmQgcmV0cmlldmUgcmVzdWx0cyBmcm9tIHRoZSBkYXRhYmFzZS5cbiAqXG4gKiBEcml2ZXJzIGFyZSByZWFzb25hYmx5IGV4cGVuc2l2ZSB0byBjcmVhdGUgLSB5b3Ugc2hvdWxkIHN0cml2ZSB0byBrZWVwIG9uZVxuICogZHJpdmVyIGluc3RhbmNlIGFyb3VuZCBwZXIgTmVvNGogSW5zdGFuY2UgeW91IGNvbm5lY3QgdG8uXG4gKlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xudmFyIERyaXZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBZb3Ugc2hvdWxkIG5vdCBiZSBjYWxsaW5nIHRoaXMgZGlyZWN0bHksIGluc3RlYWQgdXNlIHtAbGluayBkcml2ZXJ9LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YSBNZXRhaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRyaXZlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGlkOiBudW1iZXIsIGNvbmZpZzpPYmplY3QsIGxvZzpMb2dnZXIsIGhvc3ROYW1lUmVzb2x2ZXI6IENvbmZpZ3VyZWRDdXN0b21SZXNvbHZlcik6IENvbm5lY3Rpb25Qcm92aWRlciB9IGNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlciBDcmVhdGVzIHRoZSBjb25uZWN0aW9uIHByb3ZpZGVyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihhcmdzKTogU2Vzc2lvbiB9IGNyZWF0ZVNlc3Npb24gQ3JlYXRlcyB0aGUgYSBzZXNzaW9uXG4gICAgKi9cbiAgICBmdW5jdGlvbiBEcml2ZXIobWV0YSwgY29uZmlnLCBjcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIsIGNyZWF0ZVNlc3Npb24sIGNyZWF0ZVF1ZXJ5RXhlY3V0b3IpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIGlmIChjcmVhdGVTZXNzaW9uID09PSB2b2lkIDApIHsgY3JlYXRlU2Vzc2lvbiA9IGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBuZXcgc2Vzc2lvbl8xLmRlZmF1bHQoYXJncyk7IH07IH1cbiAgICAgICAgaWYgKGNyZWF0ZVF1ZXJ5RXhlY3V0b3IgPT09IHZvaWQgMCkgeyBjcmVhdGVRdWVyeUV4ZWN1dG9yID0gZnVuY3Rpb24gKGNyZWF0ZVNlc3Npb24pIHsgcmV0dXJuIG5ldyBxdWVyeV9leGVjdXRvcl8xLmRlZmF1bHQoY3JlYXRlU2Vzc2lvbik7IH07IH1cbiAgICAgICAgc2FuaXRpemVDb25maWcoY29uZmlnKTtcbiAgICAgICAgdmFyIGxvZyA9IGxvZ2dlcl8xLkxvZ2dlci5jcmVhdGUoY29uZmlnKTtcbiAgICAgICAgdmFsaWRhdGVDb25maWcoY29uZmlnLCBsb2cpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkR2VuZXJhdG9yKys7XG4gICAgICAgIHRoaXMuX21ldGEgPSBtZXRhO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuX2xvZyA9IGxvZztcbiAgICAgICAgdGhpcy5fY3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyID0gY3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9jcmVhdGVTZXNzaW9uID0gY3JlYXRlU2Vzc2lvbjtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEV4ZWN1dGVRdWVyeUJvb2ttYXJrTWFuYWdlciA9ICgwLCBib29rbWFya19tYW5hZ2VyXzEuYm9va21hcmtNYW5hZ2VyKSgpO1xuICAgICAgICB0aGlzLl9xdWVyeUV4ZWN1dG9yID0gY3JlYXRlUXVlcnlFeGVjdXRvcih0aGlzLnNlc3Npb24uYmluZCh0aGlzKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvbm5lY3Rpb24gcHJvdmlkZXIuIEluaXRpYWxpemVkIGxhemlseSBieSB7QGxpbmsgX2dldE9yQ3JlYXRlQ29ubmVjdGlvblByb3ZpZGVyfS5cbiAgICAgICAgICogQHR5cGUge0Nvbm5lY3Rpb25Qcm92aWRlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvbWVEYXRhYmFzZUNhY2hlID0gbmV3IGhvbWVkYl9jYWNoZV8xLmRlZmF1bHQoSE9NRURCX0NBQ0hFX01BWF9TSVpFKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJDb25zdHJ1Y3Rpb24oKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERyaXZlci5wcm90b3R5cGUsIFwiZXhlY3V0ZVF1ZXJ5Qm9va21hcmtNYW5hZ2VyXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBib29rbWFyayBtYW5hZ2VkIHVzZWQgYnkge0BsaW5rIERyaXZlci5leGVjdXRlUXVlcnl9XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtCb29rbWFya01hbmFnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0RXhlY3V0ZVF1ZXJ5Qm9va21hcmtNYW5hZ2VyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBxdWVyeSBpbiBhIHJldHJpYWJsZSBjb250ZXh0IGFuZCByZXR1cm5zIGEge0BsaW5rIEVhZ2VyUmVzdWx0fS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGEgc2hvcnRjdXQgZm9yIGEge0BsaW5rIFNlc3Npb24jZXhlY3V0ZVJlYWR9IGFuZCB7QGxpbmsgU2Vzc2lvbiNleGVjdXRlV3JpdGV9LlxuICAgICAqXG4gICAgICogTk9URTogQmVjYXVzZSBpdCBpcyBhbiBleHBsaWNpdCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgcG9pbnQgb2YgdmlldywgQ3lwaGVyIHF1ZXJpZXMgdXNpbmdcbiAgICAgKiBcIkNBTEwge30gSU4gVFJBTlNBQ1RJT05TXCIgb3IgdGhlIG9sZGVyIFwiVVNJTkcgUEVSSU9ESUMgQ09NTUlUXCIgY29uc3RydWN0IHdpbGwgbm90IHdvcmsgKGNhbGxcbiAgICAgKiB7QGxpbmsgU2Vzc2lvbiNydW59IGZvciB0aGVzZSkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFJ1biBhIHNpbXBsZSB3cml0ZSBxdWVyeVxuICAgICAqIGNvbnN0IHsga2V5cywgcmVjb3Jkcywgc3VtbWFyeSB9ID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVRdWVyeSgnQ1JFQVRFIChwOlBlcnNvbnsgbmFtZTogJG5hbWUgfSkgUkVUVVJOIHAnLCB7IG5hbWU6ICdQZXJzb24xJ30pXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFJ1biBhIHJlYWQgcXVlcnlcbiAgICAgKiBjb25zdCB7IGtleXMsIHJlY29yZHMsIHN1bW1hcnkgfSA9IGF3YWl0IGRyaXZlci5leGVjdXRlUXVlcnkoXG4gICAgICogICAgJ01BVENIIChwOlBlcnNvbnsgbmFtZTogJG5hbWUgfSkgUkVUVVJOIHAnLFxuICAgICAqICAgIHsgbmFtZTogJ1BlcnNvbjEnfSxcbiAgICAgKiAgICB7IHJvdXRpbmc6IG5lbzRqLnJvdXRpbmcuUkVBRH0pXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFJ1biBhIHJlYWQgcXVlcnkgcmV0dXJuaW5nIGEgUGVyc29uIE5vZGVzIHBlciBlbGVtZW50SWRcbiAgICAgKiBjb25zdCBwZW9wbGVNYXBwZWRCeUlkID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVRdWVyeShcbiAgICAgKiAgICAnTUFUQ0ggKHA6UGVyc29ueyBuYW1lOiAkbmFtZSB9KSBSRVRVUk4gcCcsXG4gICAgICogICAgeyBuYW1lOiAnUGVyc29uMSd9LFxuICAgICAqICAgIHtcbiAgICAgKiAgICAgIHJlc3VsdFRyYW5zZm9ybWVyOiBuZW80ai5yZXN1bHRUcmFuc2Zvcm1lcnMubWFwcGVkUmVzdWx0VHJhbnNmb3JtZXIoe1xuICAgICAqICAgICAgICBtYXAocmVjb3JkKSB7XG4gICAgICogICAgICAgICAgY29uc3QgcCA9IHJlY29yZC5nZXQoJ3AnKVxuICAgICAqICAgICAgICAgIHJldHVybiBbcC5lbGVtZW50SWQsIHBdXG4gICAgICogICAgICAgIH0sXG4gICAgICogICAgICAgIGNvbGxlY3QoZWxlbWVudElkUGVyc29uUGFpckFycmF5KSB7XG4gICAgICogICAgICAgICAgcmV0dXJuIG5ldyBNYXAoZWxlbWVudElkUGVyc29uUGFpckFycmF5KVxuICAgICAqICAgICAgICB9XG4gICAgICogICAgICB9KVxuICAgICAqICAgIH1cbiAgICAgKiApXG4gICAgICpcbiAgICAgKiBjb25zdCBwZXJzb24gPSBwZW9wbGVNYXBwZWRCeUlkLmdldChcIjxFTEVNRU5UX0lEPlwiKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB0aGVzZSBsaW5lc1xuICAgICAqIGNvbnN0IHRyYW5zZm9ybWVkUmVzdWx0ID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVRdWVyeShcbiAgICAgKiAgICBcIjxRVUVSWT5cIixcbiAgICAgKiAgICA8UEFSQU1FVEVSUz4sXG4gICAgICogICAge1xuICAgICAqICAgICAgIHJvdXRpbmc6IG5lbzRqLnJvdXRpbmcuV1JJVEUsXG4gICAgICogICAgICAgcmVzdWx0VHJhbnNmb3JtZXI6IHRyYW5zZm9ybWVyLFxuICAgICAqICAgICAgIGRhdGFiYXNlOiBcIjxEQVRBQkFTRT5cIixcbiAgICAgKiAgICAgICBpbXBlcnNvbmF0ZWRVc2VyOiBcIjxVU0VSPlwiLFxuICAgICAqICAgICAgIGJvb2ttYXJrTWFuYWdlcjogYm9va21hcmtNYW5hZ2VyXG4gICAgICogICAgfSlcbiAgICAgKiAvLyBhcmUgZXF1aXZhbGVudCB0byB0aG9zZVxuICAgICAqIGNvbnN0IHNlc3Npb24gPSBkcml2ZXIuc2Vzc2lvbih7XG4gICAgICogICAgZGF0YWJhc2U6IFwiPERBVEFCQVNFPlwiLFxuICAgICAqICAgIGltcGVyc29uYXRlZFVzZXI6IFwiPFVTRVI+XCIsXG4gICAgICogICAgYm9va21hcmtNYW5hZ2VyOiBib29rbWFya01hbmFnZXJcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogdHJ5IHtcbiAgICAgKiAgICBjb25zdCB0cmFuc2Zvcm1lZFJlc3VsdCA9IGF3YWl0IHNlc3Npb24uZXhlY3V0ZVdyaXRlKHR4ID0+IHtcbiAgICAgKiAgICAgICAgY29uc3QgcmVzdWx0ID0gdHgucnVuKFwiPFFVRVJZPlwiLCA8UEFSQU1FVEVSUz4pXG4gICAgICogICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcihyZXN1bHQpXG4gICAgICogICAgfSlcbiAgICAgKiB9IGZpbmFsbHkge1xuICAgICAqICAgIGF3YWl0IHNlc3Npb24uY2xvc2UoKVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IHt0ZXh0OiBzdHJpbmcsIHBhcmFtZXRlcnM/OiBvYmplY3R9fSBxdWVyeSAtIEN5cGhlciBxdWVyeSB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBNYXAgd2l0aCBwYXJhbWV0ZXJzIHRvIHVzZSBpbiB0aGUgcXVlcnlcbiAgICAgKiBAcGFyYW0ge1F1ZXJ5Q29uZmlnPFQ+fSBjb25maWcgLSBUaGUgcXVlcnkgY29uZmlndXJhdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFQ+fVxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgcmVzdWx0VHJhbnNmb3JtZXJzfSBmb3IgcHJvdmlkZWQgcmVzdWx0IHRyYW5zZm9ybWVycy5cbiAgICAgKi9cbiAgICBEcml2ZXIucHJvdG90eXBlLmV4ZWN1dGVRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeSwgcGFyYW1ldGVycywgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJvb2ttYXJrTWFuYWdlciwgcmVzdWx0VHJhbnNmb3JtZXIsIHJvdXRpbmdDb25maWc7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rbWFya01hbmFnZXIgPSBjb25maWcuYm9va21hcmtNYW5hZ2VyID09PSBudWxsID8gdW5kZWZpbmVkIDogKChfYSA9IGNvbmZpZy5ib29rbWFya01hbmFnZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZXhlY3V0ZVF1ZXJ5Qm9va21hcmtNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFRyYW5zZm9ybWVyID0gKChfYiA9IGNvbmZpZy5yZXN1bHRUcmFuc2Zvcm1lcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcmVzdWx0X3RyYW5zZm9ybWVyc18xLmRlZmF1bHQuZWFnZXJSZXN1bHRUcmFuc2Zvcm1lcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRpbmdDb25maWcgPSAoX2MgPSBjb25maWcucm91dGluZykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcm91dGluZy5XUklURTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0aW5nQ29uZmlnICE9PSByb3V0aW5nLlJFQUQgJiYgcm91dGluZ0NvbmZpZyAhPT0gcm91dGluZy5XUklURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKShcIklsbGVnYWwgcXVlcnkgcm91dGluZyBjb25maWc6IFxcXCJcIi5jb25jYXQocm91dGluZ0NvbmZpZywgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3F1ZXJ5RXhlY3V0b3IuZXhlY3V0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFRyYW5zZm9ybWVyOiByZXN1bHRUcmFuc2Zvcm1lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9va21hcmtNYW5hZ2VyOiBib29rbWFya01hbmFnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRpbmc6IHJvdXRpbmdDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcGVyc29uYXRlZFVzZXI6IGNvbmZpZy5pbXBlcnNvbmF0ZWRVc2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkNvbmZpZzogY29uZmlnLnRyYW5zYWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoOiBjb25maWcuYXV0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBjb25maWcuc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcXVlcnksIHBhcmFtZXRlcnMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Quc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBjb25uZWN0aXZpdHkgb2YgdGhpcyBkcml2ZXIgYnkgdHJ5aW5nIHRvIG9wZW4gYSBjb25uZWN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGRyaXZlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyByZXR1cm4gb2YgdGhpcyBtZXRob2Qgd2lsbCBjaGFuZ2UgaW4gNi4wLjAgdG8gbm90IGFzeW5jIHJldHVybiB0aGUge0BsaW5rIFNlcnZlckluZm99IGFuZFxuICAgICAqIGFzeW5jIHJldHVybiB7QGxpbmsgdm9pZH0gaW5zdGVhZC4gSWYgeW91IG5lZWQgdG8gdXNlIHRoZSBzZXJ2ZXIgaW5mbywgdXNlIHtAbGluayBnZXRTZXJ2ZXJJbmZvfSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSAtIFRoZSBvYmplY3QgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtLmRhdGFiYXNlIC0gVGhlIHRhcmdldCBkYXRhYmFzZSB0byB2ZXJpZnkgY29ubmVjdGl2aXR5IGZvci5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXJ2ZXJJbmZvPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIHNlcnZlciBpbmZvIG9yIHJlamVjdGVkIHdpdGggZXJyb3IuXG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS52ZXJpZnlDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGF0YWJhc2UsIGRhdGFiYXNlID0gX2MgPT09IHZvaWQgMCA/ICcnIDogX2M7XG4gICAgICAgIHZhciBjb25uZWN0aW9uUHJvdmlkZXIgPSB0aGlzLl9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcigpO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvblByb3ZpZGVyLnZlcmlmeUNvbm5lY3Rpdml0eUFuZEdldFNlcnZlckluZm8oeyBkYXRhYmFzZTogZGF0YWJhc2UsIGFjY2Vzc01vZGU6IFJFQUQgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB2ZXJpZmllcyB0aGUgYXV0aG9yaXphdGlvbiBjcmVkZW50aWFscyB3b3JrIGJ5IHRyeWluZyB0byBhY3F1aXJlIGEgY29ubmVjdGlvblxuICAgICAqIHRvIG9uZSBvZiB0aGUgc2VydmVycyB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbSAtIG9iamVjdCBwYXJhbWV0ZXJcbiAgICAgKiBAcHJvcGVydHkge0F1dGhUb2tlbn0gcGFyYW0uYXV0aCAtIHRoZSB0YXJnZXQgYXV0aCBmb3IgdGhlIHRvLWJlLWFjcXVpcmVkIGNvbm5lY3Rpb25cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcGFyYW0uZGF0YWJhc2UgLSB0aGUgdGFyZ2V0IGRhdGFiYXNlIGZvciB0aGUgdG8tYmUtYWNxdWlyZWQgY29ubmVjdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCB0cnVlIGlmIHN1Y2NlZWQsIGZhbHNlIGlmIGZhaWxlZCB3aXRoXG4gICAgICogIGF1dGhlbnRpY2F0aW9uIGlzc3VlIGFuZCByZWplY3RlZCB3aXRoIGVycm9yIGlmIG5vbi1hdXRoZW50aWNhdGlvbiBlcnJvciBoYXBwZW5zLlxuICAgICAqL1xuICAgIERyaXZlci5wcm90b3R5cGUudmVyaWZ5QXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGRhdGFiYXNlID0gX2IuZGF0YWJhc2UsIGF1dGggPSBfYi5hdXRoO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvblByb3ZpZGVyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0T3JDcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbm5lY3Rpb25Qcm92aWRlci52ZXJpZnlBdXRoZW50aWNhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSAhPT0gbnVsbCAmJiBkYXRhYmFzZSAhPT0gdm9pZCAwID8gZGF0YWJhc2UgOiAnc3lzdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aDogYXV0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzTW9kZTogUkVBRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgU2VydmVySW5mbyBmb3IgdGhlIGdpdmVyIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIC0gVGhlIG9iamVjdCBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0uZGF0YWJhc2UgLSBUaGUgdGFyZ2V0IGRhdGFiYXNlIHRvIHZlcmlmeSBjb25uZWN0aXZpdHkgZm9yLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcnZlckluZm8+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggdGhlIFNlcnZlckluZm8gb3IgcmVqZWN0ZWQgd2l0aCBlcnJvci5cbiAgICAgKi9cbiAgICBEcml2ZXIucHJvdG90eXBlLmdldFNlcnZlckluZm8gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZGF0YWJhc2UsIGRhdGFiYXNlID0gX2MgPT09IHZvaWQgMCA/ICcnIDogX2M7XG4gICAgICAgIHZhciBjb25uZWN0aW9uUHJvdmlkZXIgPSB0aGlzLl9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcigpO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvblByb3ZpZGVyLnZlcmlmeUNvbm5lY3Rpdml0eUFuZEdldFNlcnZlckluZm8oeyBkYXRhYmFzZTogZGF0YWJhc2UsIGFjY2Vzc01vZGU6IFJFQUQgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNlcnZlciBzdXBwb3J0cyBtdWx0aSBkYXRhYmFzZSBjYXBhYmlsaXRpZXMgYmFzZWQgb24gdGhlIHByb3RvY29sXG4gICAgICogdmVyc2lvbiBuZWdvdGlhdGVkIHZpYSBoYW5kc2hha2UuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBjYWxsIF9hbHdheXNfIGNhdXNlcyBhIHJvdW5kLXRyaXAgdG8gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggYSBib29sZWFuIG9yIHJlamVjdGVkIHdpdGggZXJyb3IuXG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5zdXBwb3J0c011bHRpRGIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uUHJvdmlkZXIgPSB0aGlzLl9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcigpO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvblByb3ZpZGVyLnN1cHBvcnRzTXVsdGlEYigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgdHJhbnNhY3Rpb24gY29uZmlnIGNhcGFiaWxpdGllcyBiYXNlZCBvbiB0aGUgcHJvdG9jb2xcbiAgICAgKiB2ZXJzaW9uIG5lZ290aWF0ZWQgdmlhIGhhbmRzaGFrZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbGwgX2Fsd2F5c18gY2F1c2VzIGEgcm91bmQtdHJpcCB0byB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGJvb2xlYW4gb3IgcmVqZWN0ZWQgd2l0aCBlcnJvci5cbiAgICAgKi9cbiAgICBEcml2ZXIucHJvdG90eXBlLnN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uUHJvdmlkZXIgPSB0aGlzLl9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlcigpO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvblByb3ZpZGVyLnN1cHBvcnRzVHJhbnNhY3Rpb25Db25maWcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgc2VydmVyIHN1cHBvcnRzIHVzZXIgaW1wZXJzb25hdGlvbiBjYXBhYmlsaXRpZXMgYmFzZWQgb24gdGhlIHByb3RvY29sXG4gICAgICogdmVyc2lvbiBuZWdvdGlhdGVkIHZpYSBoYW5kc2hha2UuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBjYWxsIF9hbHdheXNfIGNhdXNlcyBhIHJvdW5kLXRyaXAgdG8gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggYSBib29sZWFuIG9yIHJlamVjdGVkIHdpdGggZXJyb3IuXG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5zdXBwb3J0c1VzZXJJbXBlcnNvbmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0T3JDcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Qcm92aWRlci5zdXBwb3J0c1VzZXJJbXBlcnNvbmF0aW9uKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGRyaXZlciBzZXNzaW9uIHJlLWF1dGggZnVuY3Rpb25hbGl0eSBjYXBhYmlsaXRpZXMgYmFzZWQgb24gdGhlIHByb3RvY29sXG4gICAgICogdmVyc2lvbiBuZWdvdGlhdGVkIHZpYSBoYW5kc2hha2UuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBjYWxsIF9hbHdheXNfIGNhdXNlcyBhIHJvdW5kLXRyaXAgdG8gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBwcm9taXNlIHJlc29sdmVkIHdpdGggYSBib29sZWFuIG9yIHJlamVjdGVkIHdpdGggZXJyb3IuXG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5zdXBwb3J0c1Nlc3Npb25BdXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0T3JDcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Qcm92aWRlci5zdXBwb3J0c1Nlc3Npb25BdXRoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm90b2NvbCB2ZXJzaW9uIG5lZ290aWF0ZWQgdmlhIGhhbmRzaGFrZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbGwgX2Fsd2F5c18gY2F1c2VzIGEgcm91bmQtdHJpcCB0byB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gdGhlIHByb3RvY29sIHZlcnNpb24gbmVnb3RpYXRlZCB2aWEgaGFuZHNoYWtlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIHByb3RvY29sIG5lZ290aWF0aW9uIGZhaWxzXG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5nZXROZWdvdGlhdGVkUHJvdG9jb2xWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0T3JDcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Qcm92aWRlci5nZXROZWdvdGlhdGVkUHJvdG9jb2xWZXJzaW9uKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgZHJpdmVyIGhhcyBiZWVuIGNvbmZpZ3VyZWQgd2l0aCBlbmNyeXB0aW9uIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBEcml2ZXIucHJvdG90eXBlLmlzRW5jcnlwdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNFbmNyeXB0ZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBEcml2ZXIucHJvdG90eXBlLl9zdXBwb3J0c1JvdXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhLnJvdXRpbmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgZHJpdmVyIGhhcyBiZWVuIGNvbmZpZ3VyZWQgd2l0aCBlbmNyeXB0aW9uIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5faXNFbmNyeXB0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuZW5jcnlwdGVkID09PSB1dGlsXzEuRU5DUllQVElPTl9PTiB8fCB0aGlzLl9jb25maWcuZW5jcnlwdGVkID09PSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlndXJlZCB0cnVzdCBzdHJhdGVneSB0aGF0IHRoZSBkcml2ZXIgaGFzIGJlZW4gY29uZmlndXJlZCB3aXRoLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm5zIHtUcnVzdFN0cmF0ZWd5fVxuICAgICAqL1xuICAgIERyaXZlci5wcm90b3R5cGUuX2dldFRydXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnRydXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWNxdWlyZSBhIHNlc3Npb24gdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgZGF0YWJhc2UuIFRoZSBzZXNzaW9uIHdpbGxcbiAgICAgKiBib3Jyb3cgY29ubmVjdGlvbnMgZnJvbSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIHBvb2wgYXMgcmVxdWlyZWQgYW5kXG4gICAgICogc2hvdWxkIGJlIGNvbnNpZGVyZWQgbGlnaHR3ZWlnaHQgYW5kIGRpc3Bvc2FibGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbWVzIHdpdGggc29tZSByZXNwb25zaWJpbGl0eSAtIG1ha2Ugc3VyZSB5b3UgYWx3YXlzIGNhbGxcbiAgICAgKiB7QGxpbmsgY2xvc2V9IHdoZW4geW91IGFyZSBkb25lIHVzaW5nIGEgc2Vzc2lvbiwgYW5kIGxpa2V3aXNlLFxuICAgICAqIG1ha2Ugc3VyZSB5b3UgZG9uJ3QgY2xvc2UgeW91ciBzZXNzaW9uIGJlZm9yZSB5b3UgYXJlIGRvbmUgdXNpbmcgaXQuIE9uY2VcbiAgICAgKiBpdCBpcyBjbG9zZWQsIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gd2lsbCBiZSByZWxlYXNlZCB0byB0aGUgY29ubmVjdGlvblxuICAgICAqIHBvb2wgYW5kIG1hZGUgYXZhaWxhYmxlIGZvciBvdGhlcnMgdG8gdXNlLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7U2Vzc2lvbkNvbmZpZ30gcGFyYW0gLSBUaGUgc2Vzc2lvbiBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybiB7U2Vzc2lvbn0gbmV3IHNlc3Npb24uXG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5zZXNzaW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmRlZmF1bHRBY2Nlc3NNb2RlLCBkZWZhdWx0QWNjZXNzTW9kZSA9IF9jID09PSB2b2lkIDAgPyBXUklURSA6IF9jLCBib29rbWFya09yQm9va21hcmtzID0gX2IuYm9va21hcmtzLCBfZCA9IF9iLmRhdGFiYXNlLCBkYXRhYmFzZSA9IF9kID09PSB2b2lkIDAgPyAnJyA6IF9kLCBpbXBlcnNvbmF0ZWRVc2VyID0gX2IuaW1wZXJzb25hdGVkVXNlciwgZmV0Y2hTaXplID0gX2IuZmV0Y2hTaXplLCBib29rbWFya01hbmFnZXIgPSBfYi5ib29rbWFya01hbmFnZXIsIG5vdGlmaWNhdGlvbkZpbHRlciA9IF9iLm5vdGlmaWNhdGlvbkZpbHRlciwgYXV0aCA9IF9iLmF1dGg7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXdTZXNzaW9uKHtcbiAgICAgICAgICAgIGRlZmF1bHRBY2Nlc3NNb2RlOiBkZWZhdWx0QWNjZXNzTW9kZSxcbiAgICAgICAgICAgIGJvb2ttYXJrT3JCb29rbWFya3M6IGJvb2ttYXJrT3JCb29rbWFya3MsXG4gICAgICAgICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICAgICAgICByZWFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBpbXBlcnNvbmF0ZWRVc2VyOiBpbXBlcnNvbmF0ZWRVc2VyLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZldGNoU2l6ZTogdmFsaWRhdGVGZXRjaFNpemVWYWx1ZShmZXRjaFNpemUsIHRoaXMuX2NvbmZpZy5mZXRjaFNpemUpLFxuICAgICAgICAgICAgYm9va21hcmtNYW5hZ2VyOiBib29rbWFya01hbmFnZXIsXG4gICAgICAgICAgICBub3RpZmljYXRpb25GaWx0ZXI6IG5vdGlmaWNhdGlvbkZpbHRlcixcbiAgICAgICAgICAgIGF1dGg6IGF1dGhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbGwgb3BlbiBzZXNzaW9ucyBhbmQgb3RoZXIgYXNzb2NpYXRlZCByZXNvdXJjZXMuIFlvdSBzaG91bGRcbiAgICAgKiBtYWtlIHN1cmUgdG8gdXNlIHRoaXMgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGRyaXZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBpbnRlcnJ1cHQgYW55IHJ1bm5pbmcgY29ubmVjdGlvbnMuXG4gICAgICogTWFrZSBzdXJlIHlvdSBhcmUgZG9uZSB1c2luZyB0aGUgZHJpdmVyIG9iamVjdCBhbmQgYW55IHJlc291cmNlc1xuICAgICAqIHNwYXduZWQgZnJvbSBpdCAoc3VjaCBhcyBzZXNzaW9ucyBvciB0cmFuc2FjdGlvbnMpIHdoaWxlIGNhbGxpbmdcbiAgICAgKiB0aGlzIG1ldGhvZC4gRmFpbGluZyB0byBkbyBzbyB3aWxsIHJlc3VsdCBpbiB1bnNwZWNpZmllZCBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBwcm9taXNlIHJlc29sdmVkIHdoZW4gdGhlIGRyaXZlciBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9nLmluZm8oXCJEcml2ZXIgXCIuY29uY2F0KHRoaXMuX2lkLCBcIiBjbG9zaW5nXCIpKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblByb3ZpZGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIERyaXZlci5wcm90b3R5cGVbU3ltYm9sLmFzeW5jRGlzcG9zZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5fYWZ0ZXJDb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvZy5pbmZvKFwiXCIuY29uY2F0KHRoaXMuX21ldGEudHlwZW5hbWUsIFwiIGRyaXZlciBcIikuY29uY2F0KHRoaXMuX2lkLCBcIiBjcmVhdGVkIGZvciBzZXJ2ZXIgYWRkcmVzcyBcIikuY29uY2F0KHRoaXMuX21ldGEuYWRkcmVzcy50b1N0cmluZygpKSk7XG4gICAgfTtcbiAgICBEcml2ZXIucHJvdG90eXBlLl9ob21lRGF0YWJhc2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWNoZUtleSwgZGF0YWJhc2UpIHtcbiAgICAgICAgdGhpcy5ob21lRGF0YWJhc2VDYWNoZS5zZXQoY2FjaGVLZXksIGRhdGFiYXNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRHJpdmVyLnByb3RvdHlwZS5fbmV3U2Vzc2lvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZGVmYXVsdEFjY2Vzc01vZGUgPSBfYS5kZWZhdWx0QWNjZXNzTW9kZSwgYm9va21hcmtPckJvb2ttYXJrcyA9IF9hLmJvb2ttYXJrT3JCb29rbWFya3MsIGRhdGFiYXNlID0gX2EuZGF0YWJhc2UsIHJlYWN0aXZlID0gX2EucmVhY3RpdmUsIGltcGVyc29uYXRlZFVzZXIgPSBfYS5pbXBlcnNvbmF0ZWRVc2VyLCBmZXRjaFNpemUgPSBfYS5mZXRjaFNpemUsIGJvb2ttYXJrTWFuYWdlciA9IF9hLmJvb2ttYXJrTWFuYWdlciwgbm90aWZpY2F0aW9uRmlsdGVyID0gX2Eubm90aWZpY2F0aW9uRmlsdGVyLCBhdXRoID0gX2EuYXV0aDtcbiAgICAgICAgdmFyIHNlc3Npb25Nb2RlID0gc2Vzc2lvbl8xLmRlZmF1bHQuX3ZhbGlkYXRlU2Vzc2lvbk1vZGUoZGVmYXVsdEFjY2Vzc01vZGUpO1xuICAgICAgICB2YXIgY29ubmVjdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0T3JDcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHZhciBjYWNoZWRIb21lRGF0YWJhc2UgPSB0aGlzLmhvbWVEYXRhYmFzZUNhY2hlLmdldCgoMCwgYXV0aF91dGlsXzEuY2FjaGVLZXkpKGF1dGgsIGltcGVyc29uYXRlZFVzZXIpKTtcbiAgICAgICAgdmFyIGhvbWVEYXRhYmFzZUNhbGxiYWNrID0gdGhpcy5faG9tZURhdGFiYXNlQ2FsbGJhY2suYmluZCh0aGlzKTtcbiAgICAgICAgdmFyIGJvb2ttYXJrcyA9IGJvb2ttYXJrT3JCb29rbWFya3MgIT0gbnVsbFxuICAgICAgICAgICAgPyBuZXcgYm9va21hcmtzXzEuQm9va21hcmtzKGJvb2ttYXJrT3JCb29rbWFya3MpXG4gICAgICAgICAgICA6IGJvb2ttYXJrc18xLkJvb2ttYXJrcy5lbXB0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlU2Vzc2lvbih7XG4gICAgICAgICAgICBtb2RlOiBzZXNzaW9uTW9kZSxcbiAgICAgICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSAhPT0gbnVsbCAmJiBkYXRhYmFzZSAhPT0gdm9pZCAwID8gZGF0YWJhc2UgOiAnJyxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qcm92aWRlcjogY29ubmVjdGlvblByb3ZpZGVyLFxuICAgICAgICAgICAgYm9va21hcmtzOiBib29rbWFya3MsXG4gICAgICAgICAgICBjb25maWc6IF9fYXNzaWduKHsgY2FjaGVkSG9tZURhdGFiYXNlOiBjYWNoZWRIb21lRGF0YWJhc2UsIHJvdXRpbmdEcml2ZXI6IHRoaXMuX3N1cHBvcnRzUm91dGluZygpIH0sIHRoaXMuX2NvbmZpZyksXG4gICAgICAgICAgICByZWFjdGl2ZTogcmVhY3RpdmUsXG4gICAgICAgICAgICBpbXBlcnNvbmF0ZWRVc2VyOiBpbXBlcnNvbmF0ZWRVc2VyLFxuICAgICAgICAgICAgZmV0Y2hTaXplOiBmZXRjaFNpemUsXG4gICAgICAgICAgICBib29rbWFya01hbmFnZXI6IGJvb2ttYXJrTWFuYWdlcixcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbkZpbHRlcjogbm90aWZpY2F0aW9uRmlsdGVyLFxuICAgICAgICAgICAgYXV0aDogYXV0aCxcbiAgICAgICAgICAgIGxvZzogdGhpcy5fbG9nLFxuICAgICAgICAgICAgaG9tZURhdGFiYXNlQ2FsbGJhY2s6IGhvbWVEYXRhYmFzZUNhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEcml2ZXIucHJvdG90eXBlLl9nZXRPckNyZWF0ZUNvbm5lY3Rpb25Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIgPSB0aGlzLl9jcmVhdGVDb25uZWN0aW9uUHJvdmlkZXIodGhpcy5faWQsIHRoaXMuX2NvbmZpZywgdGhpcy5fbG9nLCBjcmVhdGVIb3N0TmFtZVJlc29sdmVyKHRoaXMuX2NvbmZpZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXI7XG4gICAgfTtcbiAgICByZXR1cm4gRHJpdmVyO1xufSgpKTtcbmV4cG9ydHMuRHJpdmVyID0gRHJpdmVyO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge09iamVjdH0gdGhlIGdpdmVuIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb25maWcoY29uZmlnLCBsb2cpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciByZXNvbHZlciA9IGNvbmZpZy5yZXNvbHZlcjtcbiAgICBpZiAocmVzb2x2ZXIgIT09IG51bGwgJiYgcmVzb2x2ZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbmZpZ3VyZWQgcmVzb2x2ZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24uIEdvdDogXCIuY29uY2F0KHR5cGVvZiByZXNvbHZlcikpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmNvbm5lY3Rpb25BY3F1aXNpdGlvblRpbWVvdXQgPCBjb25maWcuY29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgbG9nLndhcm4oJ0NvbmZpZ3VyYXRpb24gZm9yIFwiY29ubmVjdGlvbkFjcXVpc2l0aW9uVGltZW91dFwiIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICAnb3IgZXF1YWwgdG8gXCJjb25uZWN0aW9uVGltZW91dFwiLiBPdGhlcndpc2UsIHRoZSBjb25uZWN0aW9uIGFjcXVpc2l0aW9uICcgK1xuICAgICAgICAgICAgJ3RpbWVvdXQgd2lsbCB0YWtlIHByZWNlZGVuY2UgZm9yIG92ZXIgdGhlIGNvbm5lY3Rpb24gdGltZW91dCBpbiBzY2VuYXJpb3MgJyArXG4gICAgICAgICAgICAnd2hlcmUgYSBuZXcgY29ubmVjdGlvbiBpcyBjcmVhdGVkIHdoaWxlIGl0IGlzIGFjcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICgoKF9hID0gY29uZmlnLm5vdGlmaWNhdGlvbkZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2FibGVkQ2F0ZWdvcmllcykgIT0gbnVsbCAmJiAoKF9iID0gY29uZmlnLm5vdGlmaWNhdGlvbkZpbHRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2FibGVkQ2xhc3NpZmljYXRpb25zKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG5vdGlmaWNhdGlvbkZpbHRlciBjYW5cXCd0IGhhdmUgYm90aCBcImRpc2FibGVkQ2F0ZWdvcmllc1wiIGFuZCAgXCJkaXNhYmxlZENsYXNzaWZpY2F0aW9uc1wiIGNvbmZpZ3VyZWQgYXQgdGhlIHNhbWUgdGltZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBzYW5pdGl6ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcubWF4Q29ubmVjdGlvbkxpZmV0aW1lID0gc2FuaXRpemVJbnRWYWx1ZShjb25maWcubWF4Q29ubmVjdGlvbkxpZmV0aW1lLCBERUZBVUxUX01BWF9DT05ORUNUSU9OX0xJRkVUSU1FKTtcbiAgICBjb25maWcubWF4Q29ubmVjdGlvblBvb2xTaXplID0gc2FuaXRpemVJbnRWYWx1ZShjb25maWcubWF4Q29ubmVjdGlvblBvb2xTaXplLCBjb25zdGFudHNfMS5ERUZBVUxUX1BPT0xfTUFYX1NJWkUpO1xuICAgIGNvbmZpZy5jb25uZWN0aW9uQWNxdWlzaXRpb25UaW1lb3V0ID0gc2FuaXRpemVJbnRWYWx1ZShjb25maWcuY29ubmVjdGlvbkFjcXVpc2l0aW9uVGltZW91dCwgY29uc3RhbnRzXzEuREVGQVVMVF9QT09MX0FDUVVJU0lUSU9OX1RJTUVPVVQpO1xuICAgIGNvbmZpZy5mZXRjaFNpemUgPSB2YWxpZGF0ZUZldGNoU2l6ZVZhbHVlKGNvbmZpZy5mZXRjaFNpemUsIERFRkFVTFRfRkVUQ0hfU0laRSk7XG4gICAgY29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0ID0gZXh0cmFjdENvbm5lY3Rpb25UaW1lb3V0KGNvbmZpZyk7XG4gICAgY29uZmlnLmNvbm5lY3Rpb25MaXZlbmVzc0NoZWNrVGltZW91dCA9XG4gICAgICAgIHZhbGlkYXRlQ29ubmVjdGlvbkxpdmVuZXNzQ2hlY2tUaW1lb3V0U2l6ZVZhbHVlKGNvbmZpZy5jb25uZWN0aW9uTGl2ZW5lc3NDaGVja1RpbWVvdXQpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVJbnRWYWx1ZShyYXdWYWx1ZSwgZGVmYXVsdFdoZW5BYnNlbnQpIHtcbiAgICB2YXIgc2FuaXRpemVkVmFsdWUgPSBwYXJzZUludChyYXdWYWx1ZSwgMTApO1xuICAgIGlmIChzYW5pdGl6ZWRWYWx1ZSA+IDAgfHwgc2FuaXRpemVkVmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNhbml0aXplZFZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChzYW5pdGl6ZWRWYWx1ZSA8IDApIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRXaGVuQWJzZW50O1xuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGZXRjaFNpemVWYWx1ZShyYXdWYWx1ZSwgZGVmYXVsdFdoZW5BYnNlbnQpIHtcbiAgICB2YXIgZmV0Y2hTaXplID0gcGFyc2VJbnQocmF3VmFsdWUsIDEwKTtcbiAgICBpZiAoZmV0Y2hTaXplID4gMCB8fCBmZXRjaFNpemUgPT09IGNvbnN0YW50c18xLkZFVENIX0FMTCkge1xuICAgICAgICByZXR1cm4gZmV0Y2hTaXplO1xuICAgIH1cbiAgICBlbHNlIGlmIChmZXRjaFNpemUgPT09IDAgfHwgZmV0Y2hTaXplIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmV0Y2ggc2l6ZSBjYW4gb25seSBiZSBhIHBvc2l0aXZlIHZhbHVlIG9yIFwiLmNvbmNhdChjb25zdGFudHNfMS5GRVRDSF9BTEwsIFwiIGZvciBBTEwuIEhvd2V2ZXIgZmV0Y2hTaXplID0gXCIpLmNvbmNhdChmZXRjaFNpemUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0V2hlbkFic2VudDtcbiAgICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb25uZWN0aW9uVGltZW91dChjb25maWcpIHtcbiAgICB2YXIgY29uZmlndXJlZFRpbWVvdXQgPSBwYXJzZUludChjb25maWcuY29ubmVjdGlvblRpbWVvdXQsIDEwKTtcbiAgICBpZiAoY29uZmlndXJlZFRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgLy8gdGltZW91dCBleHBsaWNpdGx5IGNvbmZpZ3VyZWQgdG8gMFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzTmFOKGNvbmZpZ3VyZWRUaW1lb3V0KSAmJiBjb25maWd1cmVkVGltZW91dCA8IDApIHtcbiAgICAgICAgLy8gdGltZW91dCBleHBsaWNpdGx5IGNvbmZpZ3VyZWQgdG8gYSBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOYU4oY29uZmlndXJlZFRpbWVvdXQpKSB7XG4gICAgICAgIC8vIHRpbWVvdXQgbm90IGNvbmZpZ3VyZWQsIHVzZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIHJldHVybiBjb25zdGFudHNfMS5ERUZBVUxUX0NPTk5FQ1RJT05fVElNRU9VVF9NSUxMSVM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB0aW1lb3V0IGNvbmZpZ3VyZWQsIHVzZSB0aGUgcHJvdmlkZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuIGNvbmZpZ3VyZWRUaW1lb3V0O1xuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb25uZWN0aW9uTGl2ZW5lc3NDaGVja1RpbWVvdXRTaXplVmFsdWUocmF3VmFsdWUpIHtcbiAgICBpZiAocmF3VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgY29ubmVjdGlvbkxpdmVuZXNzQ2hlY2tUaW1lb3V0ID0gcGFyc2VJbnQocmF3VmFsdWUsIDEwKTtcbiAgICBpZiAoY29ubmVjdGlvbkxpdmVuZXNzQ2hlY2tUaW1lb3V0IDwgMCB8fCBOdW1iZXIuaXNOYU4oY29ubmVjdGlvbkxpdmVuZXNzQ2hlY2tUaW1lb3V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29ubmVjdGlvbkxpdmVuZXNzQ2hlY2tUaW1lb3V0IGNhbiBvbmx5IGJlIGEgcG9zaXRpdmUgdmFsdWUgb3IgMCBmb3IgYWx3YXlzLiBIb3dldmVyIGNvbm5lY3Rpb25MaXZlbmVzc0NoZWNrVGltZW91dCA9IFwiLmNvbmNhdChjb25uZWN0aW9uTGl2ZW5lc3NDaGVja1RpbWVvdXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25MaXZlbmVzc0NoZWNrVGltZW91dDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtDb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXJ9IG5ldyBjdXN0b20gcmVzb2x2ZXIgdGhhdCB3cmFwcyB0aGUgcGFzc2VkLWluIHJlc29sdmVyIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgIElmIHJlc29sdmVkIGZ1bmN0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGl0IGRlZmF1bHRzIHRvIGFuIGlkZW50aXR5IHJlc29sdmVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVIb3N0TmFtZVJlc29sdmVyKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgY29uZmlndXJlZF9jdXN0b21fcmVzb2x2ZXJfMS5kZWZhdWx0KGNvbmZpZy5yZXNvbHZlcik7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcml2ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/driver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/error.js":
/*!*****************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/error.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PROTOCOL_ERROR = exports.SESSION_EXPIRED = exports.SERVICE_UNAVAILABLE = exports.GQLError = exports.Neo4jError = exports.isRetriableError = exports.newGQLError = exports.newError = void 0;\n// A common place for constructing error objects, to keep them\n// uniform across the driver surface.\nvar json = __importStar(__webpack_require__(/*! ./json */ \"(rsc)/./node_modules/neo4j-driver-core/lib/json.js\"));\nvar gql_constants_1 = __webpack_require__(/*! ./gql-constants */ \"(rsc)/./node_modules/neo4j-driver-core/lib/gql-constants.js\");\n/**\n * @typedef { 'DATABASE_ERROR' | 'CLIENT_ERROR' | 'TRANSIENT_ERROR' | 'UNKNOWN' } ErrorClassification\n * @experimental this is part of the preview of GQL-compliant errors\n */\nvar errorClassification = {\n    DATABASE_ERROR: 'DATABASE_ERROR',\n    CLIENT_ERROR: 'CLIENT_ERROR',\n    TRANSIENT_ERROR: 'TRANSIENT_ERROR',\n    UNKNOWN: 'UNKNOWN'\n};\nObject.freeze(errorClassification);\nvar classifications = Object.values(errorClassification);\n/**\n * Error code representing complete loss of service. Used by {@link Neo4jError#code}.\n * @type {string}\n */\nvar SERVICE_UNAVAILABLE = 'ServiceUnavailable';\nexports.SERVICE_UNAVAILABLE = SERVICE_UNAVAILABLE;\n/**\n * Error code representing transient loss of service. Used by {@link Neo4jError#code}.\n * @type {string}\n */\nvar SESSION_EXPIRED = 'SessionExpired';\nexports.SESSION_EXPIRED = SESSION_EXPIRED;\n/**\n * Error code representing serialization/deserialization issue in the Bolt protocol. Used by {@link Neo4jError#code}.\n * @type {string}\n */\nvar PROTOCOL_ERROR = 'ProtocolError';\nexports.PROTOCOL_ERROR = PROTOCOL_ERROR;\n/**\n * Error code representing an no classified error. Used by {@link Neo4jError#code}.\n * @type {string}\n */\nvar NOT_AVAILABLE = 'N/A';\n/// TODO: Remove definitions of this.constructor and this.__proto__\n/**\n * Class for nested errors, to be used as causes in {@link Neo4jError}\n * @experimental this class is part of the preview of GQL-compliant errors\n */\nvar GQLError = /** @class */ (function (_super) {\n    __extends(GQLError, _super);\n    /**\n     * @constructor\n     * @param {string} message - the error message\n     * @param {string} gqlStatus - the GQL status code of the error\n     * @param {string} gqlStatusDescription - the GQL status description of the error\n     * @param {ErrorDiagnosticRecord} diagnosticRecord - the error diagnostic record\n     * @param {Error} cause - Optional nested error, the cause of the error\n     */\n    function GQLError(message, gqlStatus, gqlStatusDescription, diagnosticRecord, cause) {\n        var _this = this;\n        var _a;\n        // eslint-disable-next-line\n        // @ts-ignore: not available in ES6 yet\n        _this = _super.call(this, message, cause != null ? { cause: cause } : undefined) || this;\n        _this.constructor = GQLError;\n        // eslint-disable-next-line no-proto\n        _this.__proto__ = GQLError.prototype;\n        /**\n         * Optional, nested error which caused the error\n         *\n         * @type {Error?}\n         * @public\n         */\n        _this.cause = cause != null ? cause : undefined;\n        /**\n         * The GQL Status code\n         *\n         * @type {string}\n         * @experimental this property is part of the preview of GQL-compliant errors\n         * @public\n         */\n        _this.gqlStatus = gqlStatus;\n        /**\n         * The GQL Status Description\n         *\n         * @type {string}\n         * @experimental this property is part of the preview of GQL-compliant errors\n         * @public\n         */\n        _this.gqlStatusDescription = gqlStatusDescription;\n        /**\n         * The GQL diagnostic record\n         *\n         * @type {DiagnosticRecord}\n         * @experimental this property is part of the preview of GQL-compliant errors\n         * @public\n         */\n        _this.diagnosticRecord = diagnosticRecord;\n        /**\n         * The GQL error classification, extracted from the diagnostic record\n         *\n         * @type {ErrorClassification}\n         * @experimental this property is part of the preview of GQL-compliant errors\n         * @public\n         */\n        _this.classification = _extractClassification(_this.diagnosticRecord);\n        /**\n         * The GQL error classification, extracted from the diagnostic record as a raw string\n         *\n         * @type {string}\n         * @experimental this property is part of the preview of GQL-compliant errors\n         * @public\n         */\n        _this.rawClassification = (_a = diagnosticRecord === null || diagnosticRecord === void 0 ? void 0 : diagnosticRecord._classification) !== null && _a !== void 0 ? _a : undefined;\n        /**\n         * Represents the name for the type of error, inherited from base JavaScript {@link Error}.\n         * Will be 'GQLError' for {@link GQLError}s and 'Neo4jError' for {@link Neo4jError}s.\n         *\n         * @type {string}\n         * @public\n         */\n        _this.name = 'GQLError';\n        return _this;\n    }\n    Object.defineProperty(GQLError.prototype, \"diagnosticRecordAsJsonString\", {\n        /**\n         * The json string representation of the diagnostic record.\n         * The goal of this method is provide a serialized object for human inspection.\n         *\n         * @type {string}\n         * @experimental this is part of the preview of GQL-compliant errors\n         * @public\n         */\n        get: function () {\n            return json.stringify(this.diagnosticRecord, { useCustomToString: true });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return GQLError;\n}(Error));\nexports.GQLError = GQLError;\n/**\n * Class for all errors thrown/returned by the driver.\n */\nvar Neo4jError = /** @class */ (function (_super) {\n    __extends(Neo4jError, _super);\n    /**\n     * @constructor\n     * @param {string} message - the error message\n     * @param {string} code - Optional error code. Will be populated when error originates in the database.\n     * @param {string} gqlStatus - the GQL status code of the error\n     * @param {string} gqlStatusDescription - the GQL status description of the error\n     * @param {DiagnosticRecord} diagnosticRecord - the error diagnostic record\n     * @param {Error} cause - Optional nested error, the cause of the error\n     */\n    function Neo4jError(message, code, gqlStatus, gqlStatusDescription, diagnosticRecord, cause) {\n        var _this = _super.call(this, message, gqlStatus, gqlStatusDescription, diagnosticRecord, cause) || this;\n        _this.constructor = Neo4jError;\n        // eslint-disable-next-line no-proto\n        _this.__proto__ = Neo4jError.prototype;\n        /**\n         * The Neo4j Error code\n         *\n         * @type {string}\n         * @public\n         */\n        _this.code = code;\n        /**\n         * The name of the type of error.\n         *\n         * @type {string}\n         * @public\n         */\n        _this.name = 'Neo4jError';\n        /**\n         * If the error is considered retriable.\n         * This does not apply when running auto-commit transactions using {@link Session#run}\n         *\n         * @type {boolean}\n         * @public\n         */\n        _this.retriable = _isRetriableCode(code);\n        return _this;\n    }\n    /**\n     * Verifies if the given error is retriable.\n     *\n     * @param {object|undefined|null} error the error object\n     * @returns {boolean} true if the error is retriable\n     */\n    Neo4jError.isRetriable = function (error) {\n        return error !== null &&\n            error !== undefined &&\n            error instanceof Neo4jError &&\n            error.retriable;\n    };\n    return Neo4jError;\n}(GQLError));\nexports.Neo4jError = Neo4jError;\n/**\n * Create a new error from a message and optional data\n * @param message the error message\n * @param {Neo4jErrorCode} [code] the error code\n * @param {Neo4jError} [cause]\n * @param {String} [gqlStatus]\n * @param {String} [gqlStatusDescription]\n * @param {DiagnosticRecord} diagnosticRecord - the error message\n * @return {Neo4jError} an {@link Neo4jError}\n * @private\n */\nfunction newError(message, code, cause, gqlStatus, gqlStatusDescription, diagnosticRecord) {\n    return new Neo4jError(message, code !== null && code !== void 0 ? code : NOT_AVAILABLE, gqlStatus !== null && gqlStatus !== void 0 ? gqlStatus : '50N42', gqlStatusDescription !== null && gqlStatusDescription !== void 0 ? gqlStatusDescription : 'error: general processing exception - unexpected error. ' + message, diagnosticRecord !== null && diagnosticRecord !== void 0 ? diagnosticRecord : gql_constants_1.rawPolyfilledDiagnosticRecord, cause);\n}\nexports.newError = newError;\n/**\n * Create a new GQL error from a message and optional data\n * @param message the error message\n * @param {Neo4jError} [cause]\n * @param {String} [gqlStatus]\n * @param {String} [gqlStatusDescription]\n * @param {DiagnosticRecord} diagnosticRecord - the error message\n * @return {Neo4jError} an {@link Neo4jError}\n * @experimental this is part of the preview of GQL-compliant errors\n * @private\n */\nfunction newGQLError(message, cause, gqlStatus, gqlStatusDescription, diagnosticRecord) {\n    return new GQLError(message, gqlStatus !== null && gqlStatus !== void 0 ? gqlStatus : '50N42', gqlStatusDescription !== null && gqlStatusDescription !== void 0 ? gqlStatusDescription : 'error: general processing exception - unexpected error. ' + message, diagnosticRecord !== null && diagnosticRecord !== void 0 ? diagnosticRecord : gql_constants_1.rawPolyfilledDiagnosticRecord, cause);\n}\nexports.newGQLError = newGQLError;\n/**\n * Verifies if the given error is retriable.\n *\n * @public\n * @param {object|undefined|null} error the error object\n * @returns {boolean} true if the error is retriable\n */\nvar isRetriableError = Neo4jError.isRetriable;\nexports.isRetriableError = isRetriableError;\n/**\n * @private\n * @param {string} code the error code\n * @returns {boolean} true if the error is a retriable error\n */\nfunction _isRetriableCode(code) {\n    return code === SERVICE_UNAVAILABLE ||\n        code === SESSION_EXPIRED ||\n        _isAuthorizationExpired(code) ||\n        _isTransientError(code);\n}\n/**\n * @private\n * @param {string} code the error to check\n * @return {boolean} true if the error is a transient error\n */\nfunction _isTransientError(code) {\n    return (code === null || code === void 0 ? void 0 : code.includes('TransientError')) === true;\n}\n/**\n * @private\n * @param {string} code the error to check\n * @returns {boolean} true if the error is a service unavailable error\n */\nfunction _isAuthorizationExpired(code) {\n    return code === 'Neo.ClientError.Security.AuthorizationExpired';\n}\n/**\n * extracts a typed classification from the diagnostic record.\n */\nfunction _extractClassification(diagnosticRecord) {\n    if (diagnosticRecord === undefined || diagnosticRecord._classification === undefined) {\n        return 'UNKNOWN';\n    }\n    return classifications.includes(diagnosticRecord._classification) ? diagnosticRecord === null || diagnosticRecord === void 0 ? void 0 : diagnosticRecord._classification : 'UNKNOWN';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2Vycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQjtBQUMxTDtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsa0VBQVE7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQWlCO0FBQy9DO0FBQ0EsY0FBYyxvRUFBb0U7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxzQkFBc0I7QUFDcEYsVUFBVTtBQUNWO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwrREFBK0Qsc0JBQXNCO0FBQ3JGLFVBQVU7QUFDVjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsOEZBQThGLHNCQUFzQjtBQUNwSCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHNCQUFzQjtB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QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9lcnJvci5qcz83YTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUFJPVE9DT0xfRVJST1IgPSBleHBvcnRzLlNFU1NJT05fRVhQSVJFRCA9IGV4cG9ydHMuU0VSVklDRV9VTkFWQUlMQUJMRSA9IGV4cG9ydHMuR1FMRXJyb3IgPSBleHBvcnRzLk5lbzRqRXJyb3IgPSBleHBvcnRzLmlzUmV0cmlhYmxlRXJyb3IgPSBleHBvcnRzLm5ld0dRTEVycm9yID0gZXhwb3J0cy5uZXdFcnJvciA9IHZvaWQgMDtcbi8vIEEgY29tbW9uIHBsYWNlIGZvciBjb25zdHJ1Y3RpbmcgZXJyb3Igb2JqZWN0cywgdG8ga2VlcCB0aGVtXG4vLyB1bmlmb3JtIGFjcm9zcyB0aGUgZHJpdmVyIHN1cmZhY2UuXG52YXIganNvbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9qc29uXCIpKTtcbnZhciBncWxfY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9ncWwtY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBAdHlwZWRlZiB7ICdEQVRBQkFTRV9FUlJPUicgfCAnQ0xJRU5UX0VSUk9SJyB8ICdUUkFOU0lFTlRfRVJST1InIHwgJ1VOS05PV04nIH0gRXJyb3JDbGFzc2lmaWNhdGlvblxuICogQGV4cGVyaW1lbnRhbCB0aGlzIGlzIHBhcnQgb2YgdGhlIHByZXZpZXcgb2YgR1FMLWNvbXBsaWFudCBlcnJvcnNcbiAqL1xudmFyIGVycm9yQ2xhc3NpZmljYXRpb24gPSB7XG4gICAgREFUQUJBU0VfRVJST1I6ICdEQVRBQkFTRV9FUlJPUicsXG4gICAgQ0xJRU5UX0VSUk9SOiAnQ0xJRU5UX0VSUk9SJyxcbiAgICBUUkFOU0lFTlRfRVJST1I6ICdUUkFOU0lFTlRfRVJST1InLFxuICAgIFVOS05PV046ICdVTktOT1dOJ1xufTtcbk9iamVjdC5mcmVlemUoZXJyb3JDbGFzc2lmaWNhdGlvbik7XG52YXIgY2xhc3NpZmljYXRpb25zID0gT2JqZWN0LnZhbHVlcyhlcnJvckNsYXNzaWZpY2F0aW9uKTtcbi8qKlxuICogRXJyb3IgY29kZSByZXByZXNlbnRpbmcgY29tcGxldGUgbG9zcyBvZiBzZXJ2aWNlLiBVc2VkIGJ5IHtAbGluayBOZW80akVycm9yI2NvZGV9LlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIFNFUlZJQ0VfVU5BVkFJTEFCTEUgPSAnU2VydmljZVVuYXZhaWxhYmxlJztcbmV4cG9ydHMuU0VSVklDRV9VTkFWQUlMQUJMRSA9IFNFUlZJQ0VfVU5BVkFJTEFCTEU7XG4vKipcbiAqIEVycm9yIGNvZGUgcmVwcmVzZW50aW5nIHRyYW5zaWVudCBsb3NzIG9mIHNlcnZpY2UuIFVzZWQgYnkge0BsaW5rIE5lbzRqRXJyb3IjY29kZX0uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgU0VTU0lPTl9FWFBJUkVEID0gJ1Nlc3Npb25FeHBpcmVkJztcbmV4cG9ydHMuU0VTU0lPTl9FWFBJUkVEID0gU0VTU0lPTl9FWFBJUkVEO1xuLyoqXG4gKiBFcnJvciBjb2RlIHJlcHJlc2VudGluZyBzZXJpYWxpemF0aW9uL2Rlc2VyaWFsaXphdGlvbiBpc3N1ZSBpbiB0aGUgQm9sdCBwcm90b2NvbC4gVXNlZCBieSB7QGxpbmsgTmVvNGpFcnJvciNjb2RlfS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBQUk9UT0NPTF9FUlJPUiA9ICdQcm90b2NvbEVycm9yJztcbmV4cG9ydHMuUFJPVE9DT0xfRVJST1IgPSBQUk9UT0NPTF9FUlJPUjtcbi8qKlxuICogRXJyb3IgY29kZSByZXByZXNlbnRpbmcgYW4gbm8gY2xhc3NpZmllZCBlcnJvci4gVXNlZCBieSB7QGxpbmsgTmVvNGpFcnJvciNjb2RlfS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciBOT1RfQVZBSUxBQkxFID0gJ04vQSc7XG4vLy8gVE9ETzogUmVtb3ZlIGRlZmluaXRpb25zIG9mIHRoaXMuY29uc3RydWN0b3IgYW5kIHRoaXMuX19wcm90b19fXG4vKipcbiAqIENsYXNzIGZvciBuZXN0ZWQgZXJyb3JzLCB0byBiZSB1c2VkIGFzIGNhdXNlcyBpbiB7QGxpbmsgTmVvNGpFcnJvcn1cbiAqIEBleHBlcmltZW50YWwgdGhpcyBjbGFzcyBpcyBwYXJ0IG9mIHRoZSBwcmV2aWV3IG9mIEdRTC1jb21wbGlhbnQgZXJyb3JzXG4gKi9cbnZhciBHUUxFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR1FMRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSB0aGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncWxTdGF0dXMgLSB0aGUgR1FMIHN0YXR1cyBjb2RlIG9mIHRoZSBlcnJvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncWxTdGF0dXNEZXNjcmlwdGlvbiAtIHRoZSBHUUwgc3RhdHVzIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvclxuICAgICAqIEBwYXJhbSB7RXJyb3JEaWFnbm9zdGljUmVjb3JkfSBkaWFnbm9zdGljUmVjb3JkIC0gdGhlIGVycm9yIGRpYWdub3N0aWMgcmVjb3JkXG4gICAgICogQHBhcmFtIHtFcnJvcn0gY2F1c2UgLSBPcHRpb25hbCBuZXN0ZWQgZXJyb3IsIHRoZSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHUUxFcnJvcihtZXNzYWdlLCBncWxTdGF0dXMsIGdxbFN0YXR1c0Rlc2NyaXB0aW9uLCBkaWFnbm9zdGljUmVjb3JkLCBjYXVzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAvLyBAdHMtaWdub3JlOiBub3QgYXZhaWxhYmxlIGluIEVTNiB5ZXRcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlLCBjYXVzZSAhPSBudWxsID8geyBjYXVzZTogY2F1c2UgfSA6IHVuZGVmaW5lZCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uc3RydWN0b3IgPSBHUUxFcnJvcjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvXG4gICAgICAgIF90aGlzLl9fcHJvdG9fXyA9IEdRTEVycm9yLnByb3RvdHlwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsLCBuZXN0ZWQgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBlcnJvclxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7RXJyb3I/fVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jYXVzZSA9IGNhdXNlICE9IG51bGwgPyBjYXVzZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBHUUwgU3RhdHVzIGNvZGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCB0aGlzIHByb3BlcnR5IGlzIHBhcnQgb2YgdGhlIHByZXZpZXcgb2YgR1FMLWNvbXBsaWFudCBlcnJvcnNcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZ3FsU3RhdHVzID0gZ3FsU3RhdHVzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEdRTCBTdGF0dXMgRGVzY3JpcHRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCB0aGlzIHByb3BlcnR5IGlzIHBhcnQgb2YgdGhlIHByZXZpZXcgb2YgR1FMLWNvbXBsaWFudCBlcnJvcnNcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZ3FsU3RhdHVzRGVzY3JpcHRpb24gPSBncWxTdGF0dXNEZXNjcmlwdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBHUUwgZGlhZ25vc3RpYyByZWNvcmRcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0RpYWdub3N0aWNSZWNvcmR9XG4gICAgICAgICAqIEBleHBlcmltZW50YWwgdGhpcyBwcm9wZXJ0eSBpcyBwYXJ0IG9mIHRoZSBwcmV2aWV3IG9mIEdRTC1jb21wbGlhbnQgZXJyb3JzXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmRpYWdub3N0aWNSZWNvcmQgPSBkaWFnbm9zdGljUmVjb3JkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEdRTCBlcnJvciBjbGFzc2lmaWNhdGlvbiwgZXh0cmFjdGVkIGZyb20gdGhlIGRpYWdub3N0aWMgcmVjb3JkXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtFcnJvckNsYXNzaWZpY2F0aW9ufVxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsIHRoaXMgcHJvcGVydHkgaXMgcGFydCBvZiB0aGUgcHJldmlldyBvZiBHUUwtY29tcGxpYW50IGVycm9yc1xuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5jbGFzc2lmaWNhdGlvbiA9IF9leHRyYWN0Q2xhc3NpZmljYXRpb24oX3RoaXMuZGlhZ25vc3RpY1JlY29yZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgR1FMIGVycm9yIGNsYXNzaWZpY2F0aW9uLCBleHRyYWN0ZWQgZnJvbSB0aGUgZGlhZ25vc3RpYyByZWNvcmQgYXMgYSByYXcgc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBleHBlcmltZW50YWwgdGhpcyBwcm9wZXJ0eSBpcyBwYXJ0IG9mIHRoZSBwcmV2aWV3IG9mIEdRTC1jb21wbGlhbnQgZXJyb3JzXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnJhd0NsYXNzaWZpY2F0aW9uID0gKF9hID0gZGlhZ25vc3RpY1JlY29yZCA9PT0gbnVsbCB8fCBkaWFnbm9zdGljUmVjb3JkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaWFnbm9zdGljUmVjb3JkLl9jbGFzc2lmaWNhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgbmFtZSBmb3IgdGhlIHR5cGUgb2YgZXJyb3IsIGluaGVyaXRlZCBmcm9tIGJhc2UgSmF2YVNjcmlwdCB7QGxpbmsgRXJyb3J9LlxuICAgICAgICAgKiBXaWxsIGJlICdHUUxFcnJvcicgZm9yIHtAbGluayBHUUxFcnJvcn1zIGFuZCAnTmVvNGpFcnJvcicgZm9yIHtAbGluayBOZW80akVycm9yfXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm5hbWUgPSAnR1FMRXJyb3InO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHUUxFcnJvci5wcm90b3R5cGUsIFwiZGlhZ25vc3RpY1JlY29yZEFzSnNvblN0cmluZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUganNvbiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRpYWdub3N0aWMgcmVjb3JkLlxuICAgICAgICAgKiBUaGUgZ29hbCBvZiB0aGlzIG1ldGhvZCBpcyBwcm92aWRlIGEgc2VyaWFsaXplZCBvYmplY3QgZm9yIGh1bWFuIGluc3BlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBleHBlcmltZW50YWwgdGhpcyBpcyBwYXJ0IG9mIHRoZSBwcmV2aWV3IG9mIEdRTC1jb21wbGlhbnQgZXJyb3JzXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uc3RyaW5naWZ5KHRoaXMuZGlhZ25vc3RpY1JlY29yZCwgeyB1c2VDdXN0b21Ub1N0cmluZzogdHJ1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBHUUxFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuR1FMRXJyb3IgPSBHUUxFcnJvcjtcbi8qKlxuICogQ2xhc3MgZm9yIGFsbCBlcnJvcnMgdGhyb3duL3JldHVybmVkIGJ5IHRoZSBkcml2ZXIuXG4gKi9cbnZhciBOZW80akVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZW80akVycm9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gdGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSAtIE9wdGlvbmFsIGVycm9yIGNvZGUuIFdpbGwgYmUgcG9wdWxhdGVkIHdoZW4gZXJyb3Igb3JpZ2luYXRlcyBpbiB0aGUgZGF0YWJhc2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdxbFN0YXR1cyAtIHRoZSBHUUwgc3RhdHVzIGNvZGUgb2YgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdxbFN0YXR1c0Rlc2NyaXB0aW9uIC0gdGhlIEdRTCBzdGF0dXMgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIHtEaWFnbm9zdGljUmVjb3JkfSBkaWFnbm9zdGljUmVjb3JkIC0gdGhlIGVycm9yIGRpYWdub3N0aWMgcmVjb3JkXG4gICAgICogQHBhcmFtIHtFcnJvcn0gY2F1c2UgLSBPcHRpb25hbCBuZXN0ZWQgZXJyb3IsIHRoZSBjYXVzZSBvZiB0aGUgZXJyb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZW80akVycm9yKG1lc3NhZ2UsIGNvZGUsIGdxbFN0YXR1cywgZ3FsU3RhdHVzRGVzY3JpcHRpb24sIGRpYWdub3N0aWNSZWNvcmQsIGNhdXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UsIGdxbFN0YXR1cywgZ3FsU3RhdHVzRGVzY3JpcHRpb24sIGRpYWdub3N0aWNSZWNvcmQsIGNhdXNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25zdHJ1Y3RvciA9IE5lbzRqRXJyb3I7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b1xuICAgICAgICBfdGhpcy5fX3Byb3RvX18gPSBOZW80akVycm9yLnByb3RvdHlwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBOZW80aiBFcnJvciBjb2RlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTmVvNGpFcnJvcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZXJyb3IgaXMgY29uc2lkZXJlZCByZXRyaWFibGUuXG4gICAgICAgICAqIFRoaXMgZG9lcyBub3QgYXBwbHkgd2hlbiBydW5uaW5nIGF1dG8tY29tbWl0IHRyYW5zYWN0aW9ucyB1c2luZyB7QGxpbmsgU2Vzc2lvbiNydW59XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yZXRyaWFibGUgPSBfaXNSZXRyaWFibGVDb2RlKGNvZGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyByZXRyaWFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHx1bmRlZmluZWR8bnVsbH0gZXJyb3IgdGhlIGVycm9yIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBlcnJvciBpcyByZXRyaWFibGVcbiAgICAgKi9cbiAgICBOZW80akVycm9yLmlzUmV0cmlhYmxlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgZXJyb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBOZW80akVycm9yICYmXG4gICAgICAgICAgICBlcnJvci5yZXRyaWFibGU7XG4gICAgfTtcbiAgICByZXR1cm4gTmVvNGpFcnJvcjtcbn0oR1FMRXJyb3IpKTtcbmV4cG9ydHMuTmVvNGpFcnJvciA9IE5lbzRqRXJyb3I7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlcnJvciBmcm9tIGEgbWVzc2FnZSBhbmQgb3B0aW9uYWwgZGF0YVxuICogQHBhcmFtIG1lc3NhZ2UgdGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7TmVvNGpFcnJvckNvZGV9IFtjb2RlXSB0aGUgZXJyb3IgY29kZVxuICogQHBhcmFtIHtOZW80akVycm9yfSBbY2F1c2VdXG4gKiBAcGFyYW0ge1N0cmluZ30gW2dxbFN0YXR1c11cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZ3FsU3RhdHVzRGVzY3JpcHRpb25dXG4gKiBAcGFyYW0ge0RpYWdub3N0aWNSZWNvcmR9IGRpYWdub3N0aWNSZWNvcmQgLSB0aGUgZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7TmVvNGpFcnJvcn0gYW4ge0BsaW5rIE5lbzRqRXJyb3J9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihtZXNzYWdlLCBjb2RlLCBjYXVzZSwgZ3FsU3RhdHVzLCBncWxTdGF0dXNEZXNjcmlwdGlvbiwgZGlhZ25vc3RpY1JlY29yZCkge1xuICAgIHJldHVybiBuZXcgTmVvNGpFcnJvcihtZXNzYWdlLCBjb2RlICE9PSBudWxsICYmIGNvZGUgIT09IHZvaWQgMCA/IGNvZGUgOiBOT1RfQVZBSUxBQkxFLCBncWxTdGF0dXMgIT09IG51bGwgJiYgZ3FsU3RhdHVzICE9PSB2b2lkIDAgPyBncWxTdGF0dXMgOiAnNTBONDInLCBncWxTdGF0dXNEZXNjcmlwdGlvbiAhPT0gbnVsbCAmJiBncWxTdGF0dXNEZXNjcmlwdGlvbiAhPT0gdm9pZCAwID8gZ3FsU3RhdHVzRGVzY3JpcHRpb24gOiAnZXJyb3I6IGdlbmVyYWwgcHJvY2Vzc2luZyBleGNlcHRpb24gLSB1bmV4cGVjdGVkIGVycm9yLiAnICsgbWVzc2FnZSwgZGlhZ25vc3RpY1JlY29yZCAhPT0gbnVsbCAmJiBkaWFnbm9zdGljUmVjb3JkICE9PSB2b2lkIDAgPyBkaWFnbm9zdGljUmVjb3JkIDogZ3FsX2NvbnN0YW50c18xLnJhd1BvbHlmaWxsZWREaWFnbm9zdGljUmVjb3JkLCBjYXVzZSk7XG59XG5leHBvcnRzLm5ld0Vycm9yID0gbmV3RXJyb3I7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBHUUwgZXJyb3IgZnJvbSBhIG1lc3NhZ2UgYW5kIG9wdGlvbmFsIGRhdGFcbiAqIEBwYXJhbSBtZXNzYWdlIHRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge05lbzRqRXJyb3J9IFtjYXVzZV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZ3FsU3RhdHVzXVxuICogQHBhcmFtIHtTdHJpbmd9IFtncWxTdGF0dXNEZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7RGlhZ25vc3RpY1JlY29yZH0gZGlhZ25vc3RpY1JlY29yZCAtIHRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtOZW80akVycm9yfSBhbiB7QGxpbmsgTmVvNGpFcnJvcn1cbiAqIEBleHBlcmltZW50YWwgdGhpcyBpcyBwYXJ0IG9mIHRoZSBwcmV2aWV3IG9mIEdRTC1jb21wbGlhbnQgZXJyb3JzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXdHUUxFcnJvcihtZXNzYWdlLCBjYXVzZSwgZ3FsU3RhdHVzLCBncWxTdGF0dXNEZXNjcmlwdGlvbiwgZGlhZ25vc3RpY1JlY29yZCkge1xuICAgIHJldHVybiBuZXcgR1FMRXJyb3IobWVzc2FnZSwgZ3FsU3RhdHVzICE9PSBudWxsICYmIGdxbFN0YXR1cyAhPT0gdm9pZCAwID8gZ3FsU3RhdHVzIDogJzUwTjQyJywgZ3FsU3RhdHVzRGVzY3JpcHRpb24gIT09IG51bGwgJiYgZ3FsU3RhdHVzRGVzY3JpcHRpb24gIT09IHZvaWQgMCA/IGdxbFN0YXR1c0Rlc2NyaXB0aW9uIDogJ2Vycm9yOiBnZW5lcmFsIHByb2Nlc3NpbmcgZXhjZXB0aW9uIC0gdW5leHBlY3RlZCBlcnJvci4gJyArIG1lc3NhZ2UsIGRpYWdub3N0aWNSZWNvcmQgIT09IG51bGwgJiYgZGlhZ25vc3RpY1JlY29yZCAhPT0gdm9pZCAwID8gZGlhZ25vc3RpY1JlY29yZCA6IGdxbF9jb25zdGFudHNfMS5yYXdQb2x5ZmlsbGVkRGlhZ25vc3RpY1JlY29yZCwgY2F1c2UpO1xufVxuZXhwb3J0cy5uZXdHUUxFcnJvciA9IG5ld0dRTEVycm9yO1xuLyoqXG4gKiBWZXJpZmllcyBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgcmV0cmlhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7b2JqZWN0fHVuZGVmaW5lZHxudWxsfSBlcnJvciB0aGUgZXJyb3Igb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgcmV0cmlhYmxlXG4gKi9cbnZhciBpc1JldHJpYWJsZUVycm9yID0gTmVvNGpFcnJvci5pc1JldHJpYWJsZTtcbmV4cG9ydHMuaXNSZXRyaWFibGVFcnJvciA9IGlzUmV0cmlhYmxlRXJyb3I7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSB0aGUgZXJyb3IgY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVycm9yIGlzIGEgcmV0cmlhYmxlIGVycm9yXG4gKi9cbmZ1bmN0aW9uIF9pc1JldHJpYWJsZUNvZGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBTRVJWSUNFX1VOQVZBSUxBQkxFIHx8XG4gICAgICAgIGNvZGUgPT09IFNFU1NJT05fRVhQSVJFRCB8fFxuICAgICAgICBfaXNBdXRob3JpemF0aW9uRXhwaXJlZChjb2RlKSB8fFxuICAgICAgICBfaXNUcmFuc2llbnRFcnJvcihjb2RlKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIHRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSB0cmFuc2llbnQgZXJyb3JcbiAqL1xuZnVuY3Rpb24gX2lzVHJhbnNpZW50RXJyb3IoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlLmluY2x1ZGVzKCdUcmFuc2llbnRFcnJvcicpKSA9PT0gdHJ1ZTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIHRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVycm9yIGlzIGEgc2VydmljZSB1bmF2YWlsYWJsZSBlcnJvclxuICovXG5mdW5jdGlvbiBfaXNBdXRob3JpemF0aW9uRXhwaXJlZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09ICdOZW8uQ2xpZW50RXJyb3IuU2VjdXJpdHkuQXV0aG9yaXphdGlvbkV4cGlyZWQnO1xufVxuLyoqXG4gKiBleHRyYWN0cyBhIHR5cGVkIGNsYXNzaWZpY2F0aW9uIGZyb20gdGhlIGRpYWdub3N0aWMgcmVjb3JkLlxuICovXG5mdW5jdGlvbiBfZXh0cmFjdENsYXNzaWZpY2F0aW9uKGRpYWdub3N0aWNSZWNvcmQpIHtcbiAgICBpZiAoZGlhZ25vc3RpY1JlY29yZCA9PT0gdW5kZWZpbmVkIHx8IGRpYWdub3N0aWNSZWNvcmQuX2NsYXNzaWZpY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICdVTktOT1dOJztcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzaWZpY2F0aW9ucy5pbmNsdWRlcyhkaWFnbm9zdGljUmVjb3JkLl9jbGFzc2lmaWNhdGlvbikgPyBkaWFnbm9zdGljUmVjb3JkID09PSBudWxsIHx8IGRpYWdub3N0aWNSZWNvcmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpYWdub3N0aWNSZWNvcmQuX2NsYXNzaWZpY2F0aW9uIDogJ1VOS05PV04nO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/gql-constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/gql-constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rawPolyfilledDiagnosticRecord = void 0;\nexports.rawPolyfilledDiagnosticRecord = {\n    OPERATION: '',\n    OPERATION_CODE: '0',\n    CURRENT_SCHEMA: '/'\n};\nObject.freeze(exports.rawPolyfilledDiagnosticRecord);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2dxbC1jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvZ3FsLWNvbnN0YW50cy5qcz8xY2I0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYXdQb2x5ZmlsbGVkRGlhZ25vc3RpY1JlY29yZCA9IHZvaWQgMDtcbmV4cG9ydHMucmF3UG9seWZpbGxlZERpYWdub3N0aWNSZWNvcmQgPSB7XG4gICAgT1BFUkFUSU9OOiAnJyxcbiAgICBPUEVSQVRJT05fQ09ERTogJzAnLFxuICAgIENVUlJFTlRfU0NIRU1BOiAnLydcbn07XG5PYmplY3QuZnJlZXplKGV4cG9ydHMucmF3UG9seWZpbGxlZERpYWdub3N0aWNSZWNvcmQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/gql-constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/graph-types.js":
/*!***********************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/graph-types.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = void 0;\nvar json_1 = __webpack_require__(/*! ./json */ \"(rsc)/./node_modules/neo4j-driver-core/lib/json.js\");\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n    value: true,\n    enumerable: false,\n    configurable: false,\n    writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\nfunction hasIdentifierProperty(obj, property) {\n    return obj != null && obj[property] === true;\n}\n/**\n * Class for Node Type.\n */\nvar Node = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {Array<string>} labels - Array for all labels\n     * @param {Properties} properties - Map with node properties\n     * @param {string} elementId - Node element identifier\n     */\n    function Node(identity, labels, properties, elementId) {\n        /**\n         * Identity of the node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Node#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Labels of the node.\n         * @type {string[]}\n         */\n        this.labels = labels;\n        /**\n         * Properties of the node.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Node element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n    }\n    /**\n     * @ignore\n     */\n    Node.prototype.toString = function () {\n        var s = '(' + this.elementId;\n        for (var i = 0; i < this.labels.length; i++) {\n            s += ':' + this.labels[i];\n        }\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ')';\n        return s;\n    };\n    return Node;\n}());\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Node} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\n */\nfunction isNode(obj) {\n    return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\nexports.isNode = isNode;\n/**\n * Class for Relationship Type.\n */\nvar Relationship = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {NumberOrInteger} start - Identity of start Node\n     * @param {NumberOrInteger} end - Identity of end Node\n     * @param {string} type - Relationship type\n     * @param {Properties} properties - Map with relationship properties\n     * @param {string} elementId - Relationship element identifier\n     * @param {string} startNodeElementId - Start Node element identifier\n     * @param {string} endNodeElementId - End Node element identifier\n     */\n    function Relationship(identity, start, end, type, properties, elementId, startNodeElementId, endNodeElementId) {\n        /**\n         * Identity of the relationship.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Identity of the start node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#startNodeElementId} instead\n         */\n        this.start = start;\n        /**\n         * Identity of the end node.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link Relationship#endNodeElementId} instead\n         */\n        this.end = end;\n        /**\n         * Type of the relationship.\n         * @type {string}\n         */\n        this.type = type;\n        /**\n         * Properties of the relationship.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Relationship element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n        /**\n         * The Start Node element identifier.\n         * @type {string}\n         */\n        this.startNodeElementId = _valueOrGetDefault(startNodeElementId, function () { return start.toString(); });\n        /**\n         * The End Node element identifier.\n         * @type {string}\n         */\n        this.endNodeElementId = _valueOrGetDefault(endNodeElementId, function () { return end.toString(); });\n    }\n    /**\n     * @ignore\n     */\n    Relationship.prototype.toString = function () {\n        var s = '(' + this.startNodeElementId + ')-[:' + this.type;\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ']->(' + this.endNodeElementId + ')';\n        return s;\n    };\n    return Relationship;\n}());\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Relationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\n */\nfunction isRelationship(obj) {\n    return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isRelationship = isRelationship;\n/**\n * Class for UnboundRelationship Type.\n * @access private\n */\nvar UnboundRelationship = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {NumberOrInteger} identity - Unique identity\n     * @param {string} type - Relationship type\n     * @param {Properties} properties - Map with relationship properties\n     * @param {string} elementId - Relationship element identifier\n     */\n    function UnboundRelationship(identity, type, properties, elementId) {\n        /**\n         * Identity of the relationship.\n         * @type {NumberOrInteger}\n         * @deprecated use {@link UnboundRelationship#elementId} instead\n         */\n        this.identity = identity;\n        /**\n         * Type of the relationship.\n         * @type {string}\n         */\n        this.type = type;\n        /**\n         * Properties of the relationship.\n         * @type {Properties}\n         */\n        this.properties = properties;\n        /**\n         * The Relationship element identifier.\n         * @type {string}\n         */\n        this.elementId = _valueOrGetDefault(elementId, function () { return identity.toString(); });\n    }\n    /**\n     * Bind relationship\n     *\n     * @protected\n     * @deprecated use {@link UnboundRelationship#bindTo} instead\n     * @param {Integer} start - Identity of start node\n     * @param {Integer} end - Identity of end node\n     * @return {Relationship} - Created relationship\n     */\n    UnboundRelationship.prototype.bind = function (start, end) {\n        return new Relationship(this.identity, start, end, this.type, this.properties, this.elementId);\n    };\n    /**\n     * Bind relationship\n     *\n     * @protected\n     * @param {Node} start - Start Node\n     * @param {Node} end - End Node\n     * @return {Relationship} - Created relationship\n     */\n    UnboundRelationship.prototype.bindTo = function (start, end) {\n        return new Relationship(this.identity, start.identity, end.identity, this.type, this.properties, this.elementId, start.elementId, end.elementId);\n    };\n    /**\n     * @ignore\n     */\n    UnboundRelationship.prototype.toString = function () {\n        var s = '-[:' + this.type;\n        var keys = Object.keys(this.properties);\n        if (keys.length > 0) {\n            s += ' {';\n            for (var i = 0; i < keys.length; i++) {\n                if (i > 0)\n                    s += ',';\n                s += keys[i] + ':' + (0, json_1.stringify)(this.properties[keys[i]]);\n            }\n            s += '}';\n        }\n        s += ']->';\n        return s;\n    };\n    return UnboundRelationship;\n}());\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link UnboundRelationship} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\n * @access private\n */\nfunction isUnboundRelationship(obj) {\n    return hasIdentifierProperty(obj, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\nexports.isUnboundRelationship = isUnboundRelationship;\n/**\n * Class for PathSegment Type.\n */\nvar PathSegment = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Node} start - start node\n     * @param {Relationship} rel - relationship that connects start and end node\n     * @param {Node} end - end node\n     */\n    function PathSegment(start, rel, end) {\n        /**\n         * Start node.\n         * @type {Node}\n         */\n        this.start = start;\n        /**\n         * Relationship.\n         * @type {Relationship}\n         */\n        this.relationship = rel;\n        /**\n         * End node.\n         * @type {Node}\n         */\n        this.end = end;\n    }\n    return PathSegment;\n}());\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link PathSegment} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\n */\nfunction isPathSegment(obj) {\n    return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\nexports.isPathSegment = isPathSegment;\n/**\n * Class for Path Type.\n */\nvar Path = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Node} start  - start node\n     * @param {Node} end - end node\n     * @param {Array<PathSegment>} segments - Array of Segments\n     */\n    function Path(start, end, segments) {\n        /**\n         * Start node.\n         * @type {Node}\n         */\n        this.start = start;\n        /**\n         * End node.\n         * @type {Node}\n         */\n        this.end = end;\n        /**\n         * Segments.\n         * @type {Array<PathSegment>}\n         */\n        this.segments = segments;\n        /**\n         * Length of the segments.\n         * @type {Number}\n         */\n        this.length = segments.length;\n    }\n    return Path;\n}());\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Path} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\n */\nfunction isPath(obj) {\n    return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}\nexports.isPath = isPath;\nfunction _valueOrGetDefault(value, getDefault) {\n    return value === undefined || value === null ? getDefault() : value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2dyYXBoLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLFlBQVk7QUFDek4sYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsZUFBZTtBQUM5QixlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxRUFBcUUsNkJBQTZCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVk7QUFDWjtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUyw2QkFBNkIsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFD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Q0FBMkMsbUJBQW1CO0FBQzlELFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVMsNkJBQTZCLGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixlQUFlLE1BQU07QUFDckIsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWTtBQUNaO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RCxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTLDZCQUE2QixXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2dyYXBoLXR5cGVzLmpzPzQ2NDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzUGF0aFNlZ21lbnQgPSBleHBvcnRzLlBhdGhTZWdtZW50ID0gZXhwb3J0cy5pc1BhdGggPSBleHBvcnRzLlBhdGggPSBleHBvcnRzLmlzVW5ib3VuZFJlbGF0aW9uc2hpcCA9IGV4cG9ydHMuVW5ib3VuZFJlbGF0aW9uc2hpcCA9IGV4cG9ydHMuaXNSZWxhdGlvbnNoaXAgPSBleHBvcnRzLlJlbGF0aW9uc2hpcCA9IGV4cG9ydHMuaXNOb2RlID0gZXhwb3J0cy5Ob2RlID0gdm9pZCAwO1xudmFyIGpzb25fMSA9IHJlcXVpcmUoXCIuL2pzb25cIik7XG52YXIgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTID0ge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG59O1xudmFyIE5PREVfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzTm9kZV9fJztcbnZhciBSRUxBVElPTlNISVBfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzUmVsYXRpb25zaGlwX18nO1xudmFyIFVOQk9VTkRfUkVMQVRJT05TSElQX0lERU5USUZJRVJfUFJPUEVSVFkgPSAnX19pc1VuYm91bmRSZWxhdGlvbnNoaXBfXyc7XG52YXIgUEFUSF9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNQYXRoX18nO1xudmFyIFBBVEhfU0VHTUVOVF9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNQYXRoU2VnbWVudF9fJztcbmZ1bmN0aW9uIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9ialtwcm9wZXJ0eV0gPT09IHRydWU7XG59XG4vKipcbiAqIENsYXNzIGZvciBOb2RlIFR5cGUuXG4gKi9cbnZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gaWRlbnRpdHkgLSBVbmlxdWUgaWRlbnRpdHlcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGxhYmVscyAtIEFycmF5IGZvciBhbGwgbGFiZWxzXG4gICAgICogQHBhcmFtIHtQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzIC0gTWFwIHdpdGggbm9kZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRJZCAtIE5vZGUgZWxlbWVudCBpZGVudGlmaWVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm9kZShpZGVudGl0eSwgbGFiZWxzLCBwcm9wZXJ0aWVzLCBlbGVtZW50SWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aXR5IG9mIHRoZSBub2RlLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIE5vZGUjZWxlbWVudElkfSBpbnN0ZWFkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYWJlbHMgb2YgdGhlIG5vZGUuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxzID0gbGFiZWxzO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiB0aGUgbm9kZS5cbiAgICAgICAgICogQHR5cGUge1Byb3BlcnRpZXN9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIE5vZGUgZWxlbWVudCBpZGVudGlmaWVyLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50SWQgPSBfdmFsdWVPckdldERlZmF1bHQoZWxlbWVudElkLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpZGVudGl0eS50b1N0cmluZygpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9ICcoJyArIHRoaXMuZWxlbWVudElkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzICs9ICc6JyArIHRoaXMubGFiZWxzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5wcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcyArPSAnIHsnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgICAgICAgICBzICs9ICcsJztcbiAgICAgICAgICAgICAgICBzICs9IGtleXNbaV0gKyAnOicgKyAoMCwganNvbl8xLnN0cmluZ2lmeSkodGhpcy5wcm9wZXJ0aWVzW2tleXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgKz0gJ30nO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gJyknO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsIE5PREVfSURFTlRJRklFUl9QUk9QRVJUWSwgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTKTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIE5vZGV9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIE5vZGV9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iaikge1xuICAgIHJldHVybiBoYXNJZGVudGlmaWVyUHJvcGVydHkob2JqLCBOT0RFX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuZXhwb3J0cy5pc05vZGUgPSBpc05vZGU7XG4vKipcbiAqIENsYXNzIGZvciBSZWxhdGlvbnNoaXAgVHlwZS5cbiAqL1xudmFyIFJlbGF0aW9uc2hpcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IGlkZW50aXR5IC0gVW5pcXVlIGlkZW50aXR5XG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IHN0YXJ0IC0gSWRlbnRpdHkgb2Ygc3RhcnQgTm9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBlbmQgLSBJZGVudGl0eSBvZiBlbmQgTm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gUmVsYXRpb25zaGlwIHR5cGVcbiAgICAgKiBAcGFyYW0ge1Byb3BlcnRpZXN9IHByb3BlcnRpZXMgLSBNYXAgd2l0aCByZWxhdGlvbnNoaXAgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50SWQgLSBSZWxhdGlvbnNoaXAgZWxlbWVudCBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0Tm9kZUVsZW1lbnRJZCAtIFN0YXJ0IE5vZGUgZWxlbWVudCBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZE5vZGVFbGVtZW50SWQgLSBFbmQgTm9kZSBlbGVtZW50IGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWxhdGlvbnNoaXAoaWRlbnRpdHksIHN0YXJ0LCBlbmQsIHR5cGUsIHByb3BlcnRpZXMsIGVsZW1lbnRJZCwgc3RhcnROb2RlRWxlbWVudElkLCBlbmROb2RlRWxlbWVudElkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGl0eSBvZiB0aGUgcmVsYXRpb25zaGlwLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIFJlbGF0aW9uc2hpcCNlbGVtZW50SWR9IGluc3RlYWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aXR5IG9mIHRoZSBzdGFydCBub2RlLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIFJlbGF0aW9uc2hpcCNzdGFydE5vZGVFbGVtZW50SWR9IGluc3RlYWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aXR5IG9mIHRoZSBlbmQgbm9kZS5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBSZWxhdGlvbnNoaXAjZW5kTm9kZUVsZW1lbnRJZH0gaW5zdGVhZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlIG9mIHRoZSByZWxhdGlvbnNoaXAuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiB0aGUgcmVsYXRpb25zaGlwLlxuICAgICAgICAgKiBAdHlwZSB7UHJvcGVydGllc31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgUmVsYXRpb25zaGlwIGVsZW1lbnQgaWRlbnRpZmllci5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWxlbWVudElkID0gX3ZhbHVlT3JHZXREZWZhdWx0KGVsZW1lbnRJZCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaWRlbnRpdHkudG9TdHJpbmcoKTsgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgU3RhcnQgTm9kZSBlbGVtZW50IGlkZW50aWZpZXIuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0Tm9kZUVsZW1lbnRJZCA9IF92YWx1ZU9yR2V0RGVmYXVsdChzdGFydE5vZGVFbGVtZW50SWQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXJ0LnRvU3RyaW5nKCk7IH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEVuZCBOb2RlIGVsZW1lbnQgaWRlbnRpZmllci5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kTm9kZUVsZW1lbnRJZCA9IF92YWx1ZU9yR2V0RGVmYXVsdChlbmROb2RlRWxlbWVudElkLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmQudG9TdHJpbmcoKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBSZWxhdGlvbnNoaXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9ICcoJyArIHRoaXMuc3RhcnROb2RlRWxlbWVudElkICsgJyktWzonICsgdGhpcy50eXBlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcGVydGllcyk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHMgKz0gJyB7JztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgICAgICAgICAgcyArPSAnLCc7XG4gICAgICAgICAgICAgICAgcyArPSBrZXlzW2ldICsgJzonICsgKDAsIGpzb25fMS5zdHJpbmdpZnkpKHRoaXMucHJvcGVydGllc1trZXlzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzICs9ICd9JztcbiAgICAgICAgfVxuICAgICAgICBzICs9ICddLT4oJyArIHRoaXMuZW5kTm9kZUVsZW1lbnRJZCArICcpJztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICByZXR1cm4gUmVsYXRpb25zaGlwO1xufSgpKTtcbmV4cG9ydHMuUmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbGF0aW9uc2hpcC5wcm90b3R5cGUsIFJFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgUmVsYXRpb25zaGlwfSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBSZWxhdGlvbnNoaXB9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNSZWxhdGlvbnNoaXAob2JqKSB7XG4gICAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIFJFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbmV4cG9ydHMuaXNSZWxhdGlvbnNoaXAgPSBpc1JlbGF0aW9uc2hpcDtcbi8qKlxuICogQ2xhc3MgZm9yIFVuYm91bmRSZWxhdGlvbnNoaXAgVHlwZS5cbiAqIEBhY2Nlc3MgcHJpdmF0ZVxuICovXG52YXIgVW5ib3VuZFJlbGF0aW9uc2hpcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IGlkZW50aXR5IC0gVW5pcXVlIGlkZW50aXR5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBSZWxhdGlvbnNoaXAgdHlwZVxuICAgICAqIEBwYXJhbSB7UHJvcGVydGllc30gcHJvcGVydGllcyAtIE1hcCB3aXRoIHJlbGF0aW9uc2hpcCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRJZCAtIFJlbGF0aW9uc2hpcCBlbGVtZW50IGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbmJvdW5kUmVsYXRpb25zaGlwKGlkZW50aXR5LCB0eXBlLCBwcm9wZXJ0aWVzLCBlbGVtZW50SWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZW50aXR5IG9mIHRoZSByZWxhdGlvbnNoaXAuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgVW5ib3VuZFJlbGF0aW9uc2hpcCNlbGVtZW50SWR9IGluc3RlYWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGUgb2YgdGhlIHJlbGF0aW9uc2hpcC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIHRoZSByZWxhdGlvbnNoaXAuXG4gICAgICAgICAqIEB0eXBlIHtQcm9wZXJ0aWVzfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBSZWxhdGlvbnNoaXAgZWxlbWVudCBpZGVudGlmaWVyLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50SWQgPSBfdmFsdWVPckdldERlZmF1bHQoZWxlbWVudElkLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpZGVudGl0eS50b1N0cmluZygpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCByZWxhdGlvbnNoaXBcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIFVuYm91bmRSZWxhdGlvbnNoaXAjYmluZFRvfSBpbnN0ZWFkXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzdGFydCAtIElkZW50aXR5IG9mIHN0YXJ0IG5vZGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGVuZCAtIElkZW50aXR5IG9mIGVuZCBub2RlXG4gICAgICogQHJldHVybiB7UmVsYXRpb25zaGlwfSAtIENyZWF0ZWQgcmVsYXRpb25zaGlwXG4gICAgICovXG4gICAgVW5ib3VuZFJlbGF0aW9uc2hpcC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVsYXRpb25zaGlwKHRoaXMuaWRlbnRpdHksIHN0YXJ0LCBlbmQsIHRoaXMudHlwZSwgdGhpcy5wcm9wZXJ0aWVzLCB0aGlzLmVsZW1lbnRJZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCaW5kIHJlbGF0aW9uc2hpcFxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnQgLSBTdGFydCBOb2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbmQgLSBFbmQgTm9kZVxuICAgICAqIEByZXR1cm4ge1JlbGF0aW9uc2hpcH0gLSBDcmVhdGVkIHJlbGF0aW9uc2hpcFxuICAgICAqL1xuICAgIFVuYm91bmRSZWxhdGlvbnNoaXAucHJvdG90eXBlLmJpbmRUbyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVsYXRpb25zaGlwKHRoaXMuaWRlbnRpdHksIHN0YXJ0LmlkZW50aXR5LCBlbmQuaWRlbnRpdHksIHRoaXMudHlwZSwgdGhpcy5wcm9wZXJ0aWVzLCB0aGlzLmVsZW1lbnRJZCwgc3RhcnQuZWxlbWVudElkLCBlbmQuZWxlbWVudElkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBVbmJvdW5kUmVsYXRpb25zaGlwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHMgPSAnLVs6JyArIHRoaXMudHlwZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BlcnRpZXMpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzICs9ICcgeyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICAgICAgICAgIHMgKz0gJywnO1xuICAgICAgICAgICAgICAgIHMgKz0ga2V5c1tpXSArICc6JyArICgwLCBqc29uXzEuc3RyaW5naWZ5KSh0aGlzLnByb3BlcnRpZXNba2V5c1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyArPSAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSAnXS0+JztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICByZXR1cm4gVW5ib3VuZFJlbGF0aW9uc2hpcDtcbn0oKSk7XG5leHBvcnRzLlVuYm91bmRSZWxhdGlvbnNoaXAgPSBVbmJvdW5kUmVsYXRpb25zaGlwO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVuYm91bmRSZWxhdGlvbnNoaXAucHJvdG90eXBlLCBVTkJPVU5EX1JFTEFUSU9OU0hJUF9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVW5ib3VuZFJlbGF0aW9uc2hpcH0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgVW5ib3VuZFJlbGF0aW9uc2hpcH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQGFjY2VzcyBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVW5ib3VuZFJlbGF0aW9uc2hpcChvYmopIHtcbiAgICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgVU5CT1VORF9SRUxBVElPTlNISVBfSURFTlRJRklFUl9QUk9QRVJUWSk7XG59XG5leHBvcnRzLmlzVW5ib3VuZFJlbGF0aW9uc2hpcCA9IGlzVW5ib3VuZFJlbGF0aW9uc2hpcDtcbi8qKlxuICogQ2xhc3MgZm9yIFBhdGhTZWdtZW50IFR5cGUuXG4gKi9cbnZhciBQYXRoU2VnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtOb2RlfSBzdGFydCAtIHN0YXJ0IG5vZGVcbiAgICAgKiBAcGFyYW0ge1JlbGF0aW9uc2hpcH0gcmVsIC0gcmVsYXRpb25zaGlwIHRoYXQgY29ubmVjdHMgc3RhcnQgYW5kIGVuZCBub2RlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbmQgLSBlbmQgbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhdGhTZWdtZW50KHN0YXJ0LCByZWwsIGVuZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgbm9kZS5cbiAgICAgICAgICogQHR5cGUge05vZGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWxhdGlvbnNoaXAuXG4gICAgICAgICAqIEB0eXBlIHtSZWxhdGlvbnNoaXB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbGF0aW9uc2hpcCA9IHJlbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuZCBub2RlLlxuICAgICAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gUGF0aFNlZ21lbnQ7XG59KCkpO1xuZXhwb3J0cy5QYXRoU2VnbWVudCA9IFBhdGhTZWdtZW50O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhdGhTZWdtZW50LnByb3RvdHlwZSwgUEFUSF9TRUdNRU5UX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBQYXRoU2VnbWVudH0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgUGF0aFNlZ21lbnR9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNQYXRoU2VnbWVudChvYmopIHtcbiAgICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgUEFUSF9TRUdNRU5UX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuZXhwb3J0cy5pc1BhdGhTZWdtZW50ID0gaXNQYXRoU2VnbWVudDtcbi8qKlxuICogQ2xhc3MgZm9yIFBhdGggVHlwZS5cbiAqL1xudmFyIFBhdGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnQgIC0gc3RhcnQgbm9kZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kIC0gZW5kIG5vZGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PFBhdGhTZWdtZW50Pn0gc2VnbWVudHMgLSBBcnJheSBvZiBTZWdtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhdGgoc3RhcnQsIGVuZCwgc2VnbWVudHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IG5vZGUuXG4gICAgICAgICAqIEB0eXBlIHtOb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5kIG5vZGUuXG4gICAgICAgICAqIEB0eXBlIHtOb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWdtZW50cy5cbiAgICAgICAgICogQHR5cGUge0FycmF5PFBhdGhTZWdtZW50Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExlbmd0aCBvZiB0aGUgc2VnbWVudHMuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIFBhdGg7XG59KCkpO1xuZXhwb3J0cy5QYXRoID0gUGF0aDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXRoLnByb3RvdHlwZSwgUEFUSF9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgUGF0aH0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgUGF0aH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1BhdGgob2JqKSB7XG4gICAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIFBBVEhfSURFTlRJRklFUl9QUk9QRVJUWSk7XG59XG5leHBvcnRzLmlzUGF0aCA9IGlzUGF0aDtcbmZ1bmN0aW9uIF92YWx1ZU9yR2V0RGVmYXVsdCh2YWx1ZSwgZ2V0RGVmYXVsdCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsID8gZ2V0RGVmYXVsdCgpIDogdmFsdWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/graph-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EagerResult = exports.Result = exports.Stats = exports.QueryStatistics = exports.ProfiledPlan = exports.Plan = exports.GqlStatusObject = exports.Notification = exports.ServerInfo = exports.queryType = exports.ResultSummary = exports.Record = exports.isPathSegment = exports.PathSegment = exports.isPath = exports.Path = exports.isUnboundRelationship = exports.UnboundRelationship = exports.isRelationship = exports.Relationship = exports.isNode = exports.Node = exports.Time = exports.LocalTime = exports.LocalDateTime = exports.isTime = exports.isLocalTime = exports.isLocalDateTime = exports.isDuration = exports.isDateTime = exports.isDate = exports.Duration = exports.DateTime = exports.Date = exports.Point = exports.isPoint = exports.internal = exports.toString = exports.toNumber = exports.inSafeRange = exports.isInt = exports.int = exports.Integer = exports.error = exports.isRetriableError = exports.GQLError = exports.newGQLError = exports.Neo4jError = exports.newError = exports.authTokenManagers = void 0;\nexports.resolveCertificateProvider = exports.clientCertificateProviders = exports.notificationFilterMinimumSeverityLevel = exports.notificationFilterDisabledClassification = exports.notificationFilterDisabledCategory = exports.notificationSeverityLevel = exports.notificationClassification = exports.notificationCategory = exports.resultTransformers = exports.routing = exports.staticAuthTokenManager = exports.bookmarkManager = exports.auth = exports.json = exports.driver = exports.types = exports.Driver = exports.Session = exports.TransactionPromise = exports.ManagedTransaction = exports.Transaction = exports.Connection = exports.Releasable = exports.ConnectionProvider = void 0;\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nObject.defineProperty(exports, \"newError\", ({ enumerable: true, get: function () { return error_1.newError; } }));\nObject.defineProperty(exports, \"Neo4jError\", ({ enumerable: true, get: function () { return error_1.Neo4jError; } }));\nObject.defineProperty(exports, \"newGQLError\", ({ enumerable: true, get: function () { return error_1.newGQLError; } }));\nObject.defineProperty(exports, \"GQLError\", ({ enumerable: true, get: function () { return error_1.GQLError; } }));\nObject.defineProperty(exports, \"isRetriableError\", ({ enumerable: true, get: function () { return error_1.isRetriableError; } }));\nvar integer_1 = __importStar(__webpack_require__(/*! ./integer */ \"(rsc)/./node_modules/neo4j-driver-core/lib/integer.js\"));\nexports.Integer = integer_1.default;\nObject.defineProperty(exports, \"int\", ({ enumerable: true, get: function () { return integer_1.int; } }));\nObject.defineProperty(exports, \"isInt\", ({ enumerable: true, get: function () { return integer_1.isInt; } }));\nObject.defineProperty(exports, \"inSafeRange\", ({ enumerable: true, get: function () { return integer_1.inSafeRange; } }));\nObject.defineProperty(exports, \"toNumber\", ({ enumerable: true, get: function () { return integer_1.toNumber; } }));\nObject.defineProperty(exports, \"toString\", ({ enumerable: true, get: function () { return integer_1.toString; } }));\nvar temporal_types_1 = __webpack_require__(/*! ./temporal-types */ \"(rsc)/./node_modules/neo4j-driver-core/lib/temporal-types.js\");\nObject.defineProperty(exports, \"Date\", ({ enumerable: true, get: function () { return temporal_types_1.Date; } }));\nObject.defineProperty(exports, \"DateTime\", ({ enumerable: true, get: function () { return temporal_types_1.DateTime; } }));\nObject.defineProperty(exports, \"Duration\", ({ enumerable: true, get: function () { return temporal_types_1.Duration; } }));\nObject.defineProperty(exports, \"isDate\", ({ enumerable: true, get: function () { return temporal_types_1.isDate; } }));\nObject.defineProperty(exports, \"isDateTime\", ({ enumerable: true, get: function () { return temporal_types_1.isDateTime; } }));\nObject.defineProperty(exports, \"isDuration\", ({ enumerable: true, get: function () { return temporal_types_1.isDuration; } }));\nObject.defineProperty(exports, \"isLocalDateTime\", ({ enumerable: true, get: function () { return temporal_types_1.isLocalDateTime; } }));\nObject.defineProperty(exports, \"isLocalTime\", ({ enumerable: true, get: function () { return temporal_types_1.isLocalTime; } }));\nObject.defineProperty(exports, \"isTime\", ({ enumerable: true, get: function () { return temporal_types_1.isTime; } }));\nObject.defineProperty(exports, \"LocalDateTime\", ({ enumerable: true, get: function () { return temporal_types_1.LocalDateTime; } }));\nObject.defineProperty(exports, \"LocalTime\", ({ enumerable: true, get: function () { return temporal_types_1.LocalTime; } }));\nObject.defineProperty(exports, \"Time\", ({ enumerable: true, get: function () { return temporal_types_1.Time; } }));\nvar graph_types_1 = __webpack_require__(/*! ./graph-types */ \"(rsc)/./node_modules/neo4j-driver-core/lib/graph-types.js\");\nObject.defineProperty(exports, \"Node\", ({ enumerable: true, get: function () { return graph_types_1.Node; } }));\nObject.defineProperty(exports, \"isNode\", ({ enumerable: true, get: function () { return graph_types_1.isNode; } }));\nObject.defineProperty(exports, \"Relationship\", ({ enumerable: true, get: function () { return graph_types_1.Relationship; } }));\nObject.defineProperty(exports, \"isRelationship\", ({ enumerable: true, get: function () { return graph_types_1.isRelationship; } }));\nObject.defineProperty(exports, \"UnboundRelationship\", ({ enumerable: true, get: function () { return graph_types_1.UnboundRelationship; } }));\nObject.defineProperty(exports, \"isUnboundRelationship\", ({ enumerable: true, get: function () { return graph_types_1.isUnboundRelationship; } }));\nObject.defineProperty(exports, \"Path\", ({ enumerable: true, get: function () { return graph_types_1.Path; } }));\nObject.defineProperty(exports, \"isPath\", ({ enumerable: true, get: function () { return graph_types_1.isPath; } }));\nObject.defineProperty(exports, \"PathSegment\", ({ enumerable: true, get: function () { return graph_types_1.PathSegment; } }));\nObject.defineProperty(exports, \"isPathSegment\", ({ enumerable: true, get: function () { return graph_types_1.isPathSegment; } }));\nvar record_1 = __importDefault(__webpack_require__(/*! ./record */ \"(rsc)/./node_modules/neo4j-driver-core/lib/record.js\"));\nexports.Record = record_1.default;\nvar spatial_types_1 = __webpack_require__(/*! ./spatial-types */ \"(rsc)/./node_modules/neo4j-driver-core/lib/spatial-types.js\");\nObject.defineProperty(exports, \"isPoint\", ({ enumerable: true, get: function () { return spatial_types_1.isPoint; } }));\nObject.defineProperty(exports, \"Point\", ({ enumerable: true, get: function () { return spatial_types_1.Point; } }));\nvar result_summary_1 = __importStar(__webpack_require__(/*! ./result-summary */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result-summary.js\"));\nexports.ResultSummary = result_summary_1.default;\nObject.defineProperty(exports, \"queryType\", ({ enumerable: true, get: function () { return result_summary_1.queryType; } }));\nObject.defineProperty(exports, \"ServerInfo\", ({ enumerable: true, get: function () { return result_summary_1.ServerInfo; } }));\nObject.defineProperty(exports, \"Plan\", ({ enumerable: true, get: function () { return result_summary_1.Plan; } }));\nObject.defineProperty(exports, \"ProfiledPlan\", ({ enumerable: true, get: function () { return result_summary_1.ProfiledPlan; } }));\nObject.defineProperty(exports, \"QueryStatistics\", ({ enumerable: true, get: function () { return result_summary_1.QueryStatistics; } }));\nObject.defineProperty(exports, \"Stats\", ({ enumerable: true, get: function () { return result_summary_1.Stats; } }));\nvar notification_1 = __importStar(__webpack_require__(/*! ./notification */ \"(rsc)/./node_modules/neo4j-driver-core/lib/notification.js\"));\nexports.Notification = notification_1.default;\nObject.defineProperty(exports, \"GqlStatusObject\", ({ enumerable: true, get: function () { return notification_1.GqlStatusObject; } }));\nObject.defineProperty(exports, \"notificationCategory\", ({ enumerable: true, get: function () { return notification_1.notificationCategory; } }));\nObject.defineProperty(exports, \"notificationClassification\", ({ enumerable: true, get: function () { return notification_1.notificationClassification; } }));\nObject.defineProperty(exports, \"notificationSeverityLevel\", ({ enumerable: true, get: function () { return notification_1.notificationSeverityLevel; } }));\nvar notification_filter_1 = __webpack_require__(/*! ./notification-filter */ \"(rsc)/./node_modules/neo4j-driver-core/lib/notification-filter.js\");\nObject.defineProperty(exports, \"notificationFilterDisabledCategory\", ({ enumerable: true, get: function () { return notification_filter_1.notificationFilterDisabledCategory; } }));\nObject.defineProperty(exports, \"notificationFilterDisabledClassification\", ({ enumerable: true, get: function () { return notification_filter_1.notificationFilterDisabledClassification; } }));\nObject.defineProperty(exports, \"notificationFilterMinimumSeverityLevel\", ({ enumerable: true, get: function () { return notification_filter_1.notificationFilterMinimumSeverityLevel; } }));\nvar result_1 = __importDefault(__webpack_require__(/*! ./result */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result.js\"));\nexports.Result = result_1.default;\nvar result_eager_1 = __importDefault(__webpack_require__(/*! ./result-eager */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result-eager.js\"));\nexports.EagerResult = result_eager_1.default;\nvar connection_provider_1 = __importStar(__webpack_require__(/*! ./connection-provider */ \"(rsc)/./node_modules/neo4j-driver-core/lib/connection-provider.js\"));\nexports.ConnectionProvider = connection_provider_1.default;\nObject.defineProperty(exports, \"Releasable\", ({ enumerable: true, get: function () { return connection_provider_1.Releasable; } }));\nvar connection_1 = __importDefault(__webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/neo4j-driver-core/lib/connection.js\"));\nexports.Connection = connection_1.default;\nvar transaction_1 = __importDefault(__webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/neo4j-driver-core/lib/transaction.js\"));\nexports.Transaction = transaction_1.default;\nvar transaction_managed_1 = __importDefault(__webpack_require__(/*! ./transaction-managed */ \"(rsc)/./node_modules/neo4j-driver-core/lib/transaction-managed.js\"));\nexports.ManagedTransaction = transaction_managed_1.default;\nvar transaction_promise_1 = __importDefault(__webpack_require__(/*! ./transaction-promise */ \"(rsc)/./node_modules/neo4j-driver-core/lib/transaction-promise.js\"));\nexports.TransactionPromise = transaction_promise_1.default;\nvar session_1 = __importDefault(__webpack_require__(/*! ./session */ \"(rsc)/./node_modules/neo4j-driver-core/lib/session.js\"));\nexports.Session = session_1.default;\nvar driver_1 = __importStar(__webpack_require__(/*! ./driver */ \"(rsc)/./node_modules/neo4j-driver-core/lib/driver.js\")), driver = driver_1;\nexports.Driver = driver_1.default;\nexports.driver = driver;\nvar auth_1 = __importDefault(__webpack_require__(/*! ./auth */ \"(rsc)/./node_modules/neo4j-driver-core/lib/auth.js\"));\nexports.auth = auth_1.default;\nvar bookmark_manager_1 = __webpack_require__(/*! ./bookmark-manager */ \"(rsc)/./node_modules/neo4j-driver-core/lib/bookmark-manager.js\");\nObject.defineProperty(exports, \"bookmarkManager\", ({ enumerable: true, get: function () { return bookmark_manager_1.bookmarkManager; } }));\nvar auth_token_manager_1 = __webpack_require__(/*! ./auth-token-manager */ \"(rsc)/./node_modules/neo4j-driver-core/lib/auth-token-manager.js\");\nObject.defineProperty(exports, \"authTokenManagers\", ({ enumerable: true, get: function () { return auth_token_manager_1.authTokenManagers; } }));\nObject.defineProperty(exports, \"staticAuthTokenManager\", ({ enumerable: true, get: function () { return auth_token_manager_1.staticAuthTokenManager; } }));\nvar driver_2 = __webpack_require__(/*! ./driver */ \"(rsc)/./node_modules/neo4j-driver-core/lib/driver.js\");\nObject.defineProperty(exports, \"routing\", ({ enumerable: true, get: function () { return driver_2.routing; } }));\nvar types = __importStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/neo4j-driver-core/lib/types.js\"));\nexports.types = types;\nvar json = __importStar(__webpack_require__(/*! ./json */ \"(rsc)/./node_modules/neo4j-driver-core/lib/json.js\"));\nexports.json = json;\nvar result_transformers_1 = __importDefault(__webpack_require__(/*! ./result-transformers */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result-transformers.js\"));\nexports.resultTransformers = result_transformers_1.default;\nvar client_certificate_1 = __webpack_require__(/*! ./client-certificate */ \"(rsc)/./node_modules/neo4j-driver-core/lib/client-certificate.js\");\nObject.defineProperty(exports, \"clientCertificateProviders\", ({ enumerable: true, get: function () { return client_certificate_1.clientCertificateProviders; } }));\nObject.defineProperty(exports, \"resolveCertificateProvider\", ({ enumerable: true, get: function () { return client_certificate_1.resolveCertificateProvider; } }));\nvar internal = __importStar(__webpack_require__(/*! ./internal */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/index.js\")); // todo: removed afterwards\nexports.internal = internal;\n/**\n * Object containing string constants representing predefined {@link Neo4jError} codes.\n */\nvar error = {\n    SERVICE_UNAVAILABLE: error_1.SERVICE_UNAVAILABLE,\n    SESSION_EXPIRED: error_1.SESSION_EXPIRED,\n    PROTOCOL_ERROR: error_1.PROTOCOL_ERROR\n};\nexports.error = error;\n/**\n * @private\n */\nvar forExport = {\n    authTokenManagers: auth_token_manager_1.authTokenManagers,\n    newError: error_1.newError,\n    Neo4jError: error_1.Neo4jError,\n    newGQLError: error_1.newGQLError,\n    GQLError: error_1.GQLError,\n    isRetriableError: error_1.isRetriableError,\n    error: error,\n    Integer: integer_1.default,\n    int: integer_1.int,\n    isInt: integer_1.isInt,\n    inSafeRange: integer_1.inSafeRange,\n    toNumber: integer_1.toNumber,\n    toString: integer_1.toString,\n    internal: internal,\n    isPoint: spatial_types_1.isPoint,\n    Point: spatial_types_1.Point,\n    Date: temporal_types_1.Date,\n    DateTime: temporal_types_1.DateTime,\n    Duration: temporal_types_1.Duration,\n    isDate: temporal_types_1.isDate,\n    isDateTime: temporal_types_1.isDateTime,\n    isDuration: temporal_types_1.isDuration,\n    isLocalDateTime: temporal_types_1.isLocalDateTime,\n    isLocalTime: temporal_types_1.isLocalTime,\n    isTime: temporal_types_1.isTime,\n    LocalDateTime: temporal_types_1.LocalDateTime,\n    LocalTime: temporal_types_1.LocalTime,\n    Time: temporal_types_1.Time,\n    Node: graph_types_1.Node,\n    isNode: graph_types_1.isNode,\n    Relationship: graph_types_1.Relationship,\n    isRelationship: graph_types_1.isRelationship,\n    UnboundRelationship: graph_types_1.UnboundRelationship,\n    isUnboundRelationship: graph_types_1.isUnboundRelationship,\n    Path: graph_types_1.Path,\n    isPath: graph_types_1.isPath,\n    PathSegment: graph_types_1.PathSegment,\n    isPathSegment: graph_types_1.isPathSegment,\n    Record: record_1.default,\n    ResultSummary: result_summary_1.default,\n    queryType: result_summary_1.queryType,\n    ServerInfo: result_summary_1.ServerInfo,\n    Notification: notification_1.default,\n    GqlStatusObject: notification_1.GqlStatusObject,\n    Plan: result_summary_1.Plan,\n    ProfiledPlan: result_summary_1.ProfiledPlan,\n    QueryStatistics: result_summary_1.QueryStatistics,\n    Stats: result_summary_1.Stats,\n    Result: result_1.default,\n    EagerResult: result_eager_1.default,\n    Transaction: transaction_1.default,\n    ManagedTransaction: transaction_managed_1.default,\n    TransactionPromise: transaction_promise_1.default,\n    Session: session_1.default,\n    Driver: driver_1.default,\n    Connection: connection_1.default,\n    Releasable: connection_provider_1.Releasable,\n    types: types,\n    driver: driver,\n    json: json,\n    auth: auth_1.default,\n    bookmarkManager: bookmark_manager_1.bookmarkManager,\n    routing: driver_2.routing,\n    resultTransformers: result_transformers_1.default,\n    notificationCategory: notification_1.notificationCategory,\n    notificationClassification: notification_1.notificationClassification,\n    notificationSeverityLevel: notification_1.notificationSeverityLevel,\n    notificationFilterDisabledCategory: notification_filter_1.notificationFilterDisabledCategory,\n    notificationFilterDisabledClassification: notification_filter_1.notificationFilterDisabledClassification,\n    notificationFilterMinimumSeverityLevel: notification_filter_1.notificationFilterMinimumSeverityLevel,\n    clientCertificateProviders: client_certificate_1.clientCertificateProviders,\n    resolveCertificateProvider: client_certificate_1.resolveCertificateProvider\n};\nexports[\"default\"] = forExport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxZQUFZLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsY0FBYyxHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxtQkFBbUIsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsd0JBQXdCLEdBQUcsZ0JBQWdC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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2luZGV4LmpzP2E0OGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVhZ2VyUmVzdWx0ID0gZXhwb3J0cy5SZXN1bHQgPSBleHBvcnRzLlN0YXRzID0gZXhwb3J0cy5RdWVyeVN0YXRpc3RpY3MgPSBleHBvcnRzLlByb2ZpbGVkUGxhbiA9IGV4cG9ydHMuUGxhbiA9IGV4cG9ydHMuR3FsU3RhdHVzT2JqZWN0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb24gPSBleHBvcnRzLlNlcnZlckluZm8gPSBleHBvcnRzLnF1ZXJ5VHlwZSA9IGV4cG9ydHMuUmVzdWx0U3VtbWFyeSA9IGV4cG9ydHMuUmVjb3JkID0gZXhwb3J0cy5pc1BhdGhTZWdtZW50ID0gZXhwb3J0cy5QYXRoU2VnbWVudCA9IGV4cG9ydHMuaXNQYXRoID0gZXhwb3J0cy5QYXRoID0gZXhwb3J0cy5pc1VuYm91bmRSZWxhdGlvbnNoaXAgPSBleHBvcnRzLlVuYm91bmRSZWxhdGlvbnNoaXAgPSBleHBvcnRzLmlzUmVsYXRpb25zaGlwID0gZXhwb3J0cy5SZWxhdGlvbnNoaXAgPSBleHBvcnRzLmlzTm9kZSA9IGV4cG9ydHMuTm9kZSA9IGV4cG9ydHMuVGltZSA9IGV4cG9ydHMuTG9jYWxUaW1lID0gZXhwb3J0cy5Mb2NhbERhdGVUaW1lID0gZXhwb3J0cy5pc1RpbWUgPSBleHBvcnRzLmlzTG9jYWxUaW1lID0gZXhwb3J0cy5pc0xvY2FsRGF0ZVRpbWUgPSBleHBvcnRzLmlzRHVyYXRpb24gPSBleHBvcnRzLmlzRGF0ZVRpbWUgPSBleHBvcnRzLmlzRGF0ZSA9IGV4cG9ydHMuRHVyYXRpb24gPSBleHBvcnRzLkRhdGVUaW1lID0gZXhwb3J0cy5EYXRlID0gZXhwb3J0cy5Qb2ludCA9IGV4cG9ydHMuaXNQb2ludCA9IGV4cG9ydHMuaW50ZXJuYWwgPSBleHBvcnRzLnRvU3RyaW5nID0gZXhwb3J0cy50b051bWJlciA9IGV4cG9ydHMuaW5TYWZlUmFuZ2UgPSBleHBvcnRzLmlzSW50ID0gZXhwb3J0cy5pbnQgPSBleHBvcnRzLkludGVnZXIgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5pc1JldHJpYWJsZUVycm9yID0gZXhwb3J0cy5HUUxFcnJvciA9IGV4cG9ydHMubmV3R1FMRXJyb3IgPSBleHBvcnRzLk5lbzRqRXJyb3IgPSBleHBvcnRzLm5ld0Vycm9yID0gZXhwb3J0cy5hdXRoVG9rZW5NYW5hZ2VycyA9IHZvaWQgMDtcbmV4cG9ydHMucmVzb2x2ZUNlcnRpZmljYXRlUHJvdmlkZXIgPSBleHBvcnRzLmNsaWVudENlcnRpZmljYXRlUHJvdmlkZXJzID0gZXhwb3J0cy5ub3RpZmljYXRpb25GaWx0ZXJNaW5pbXVtU2V2ZXJpdHlMZXZlbCA9IGV4cG9ydHMubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDbGFzc2lmaWNhdGlvbiA9IGV4cG9ydHMubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDYXRlZ29yeSA9IGV4cG9ydHMubm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbCA9IGV4cG9ydHMubm90aWZpY2F0aW9uQ2xhc3NpZmljYXRpb24gPSBleHBvcnRzLm5vdGlmaWNhdGlvbkNhdGVnb3J5ID0gZXhwb3J0cy5yZXN1bHRUcmFuc2Zvcm1lcnMgPSBleHBvcnRzLnJvdXRpbmcgPSBleHBvcnRzLnN0YXRpY0F1dGhUb2tlbk1hbmFnZXIgPSBleHBvcnRzLmJvb2ttYXJrTWFuYWdlciA9IGV4cG9ydHMuYXV0aCA9IGV4cG9ydHMuanNvbiA9IGV4cG9ydHMuZHJpdmVyID0gZXhwb3J0cy50eXBlcyA9IGV4cG9ydHMuRHJpdmVyID0gZXhwb3J0cy5TZXNzaW9uID0gZXhwb3J0cy5UcmFuc2FjdGlvblByb21pc2UgPSBleHBvcnRzLk1hbmFnZWRUcmFuc2FjdGlvbiA9IGV4cG9ydHMuVHJhbnNhY3Rpb24gPSBleHBvcnRzLkNvbm5lY3Rpb24gPSBleHBvcnRzLlJlbGVhc2FibGUgPSBleHBvcnRzLkNvbm5lY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbnZhciBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuZXdFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JfMS5uZXdFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5lbzRqRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yXzEuTmVvNGpFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5ld0dRTEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcl8xLm5ld0dRTEVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR1FMRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yXzEuR1FMRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1JldHJpYWJsZUVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcl8xLmlzUmV0cmlhYmxlRXJyb3I7IH0gfSk7XG52YXIgaW50ZWdlcl8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVnZXJcIikpO1xuZXhwb3J0cy5JbnRlZ2VyID0gaW50ZWdlcl8xLmRlZmF1bHQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVnZXJfMS5pbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZWdlcl8xLmlzSW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5TYWZlUmFuZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVnZXJfMS5pblNhZmVSYW5nZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvTnVtYmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlZ2VyXzEudG9OdW1iZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1N0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZWdlcl8xLnRvU3RyaW5nOyB9IH0pO1xudmFyIHRlbXBvcmFsX3R5cGVzXzEgPSByZXF1aXJlKFwiLi90ZW1wb3JhbC10eXBlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBvcmFsX3R5cGVzXzEuRGF0ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVUaW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wb3JhbF90eXBlc18xLkRhdGVUaW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRHVyYXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBvcmFsX3R5cGVzXzEuRHVyYXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBvcmFsX3R5cGVzXzEuaXNEYXRlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNEYXRlVGltZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcG9yYWxfdHlwZXNfMS5pc0RhdGVUaW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNEdXJhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcG9yYWxfdHlwZXNfMS5pc0R1cmF0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMb2NhbERhdGVUaW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wb3JhbF90eXBlc18xLmlzTG9jYWxEYXRlVGltZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTG9jYWxUaW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wb3JhbF90eXBlc18xLmlzTG9jYWxUaW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNUaW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wb3JhbF90eXBlc18xLmlzVGltZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvY2FsRGF0ZVRpbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlbXBvcmFsX3R5cGVzXzEuTG9jYWxEYXRlVGltZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvY2FsVGltZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGVtcG9yYWxfdHlwZXNfMS5Mb2NhbFRpbWU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZW1wb3JhbF90eXBlc18xLlRpbWU7IH0gfSk7XG52YXIgZ3JhcGhfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2dyYXBoLXR5cGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3JhcGhfdHlwZXNfMS5Ob2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNOb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBncmFwaF90eXBlc18xLmlzTm9kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlbGF0aW9uc2hpcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3JhcGhfdHlwZXNfMS5SZWxhdGlvbnNoaXA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1JlbGF0aW9uc2hpcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3JhcGhfdHlwZXNfMS5pc1JlbGF0aW9uc2hpcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuYm91bmRSZWxhdGlvbnNoaXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdyYXBoX3R5cGVzXzEuVW5ib3VuZFJlbGF0aW9uc2hpcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVW5ib3VuZFJlbGF0aW9uc2hpcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3JhcGhfdHlwZXNfMS5pc1VuYm91bmRSZWxhdGlvbnNoaXA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXRoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBncmFwaF90eXBlc18xLlBhdGg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1BhdGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdyYXBoX3R5cGVzXzEuaXNQYXRoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGF0aFNlZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdyYXBoX3R5cGVzXzEuUGF0aFNlZ21lbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1BhdGhTZWdtZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBncmFwaF90eXBlc18xLmlzUGF0aFNlZ21lbnQ7IH0gfSk7XG52YXIgcmVjb3JkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVjb3JkXCIpKTtcbmV4cG9ydHMuUmVjb3JkID0gcmVjb3JkXzEuZGVmYXVsdDtcbnZhciBzcGF0aWFsX3R5cGVzXzEgPSByZXF1aXJlKFwiLi9zcGF0aWFsLXR5cGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNQb2ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3BhdGlhbF90eXBlc18xLmlzUG9pbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb2ludFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3BhdGlhbF90eXBlc18xLlBvaW50OyB9IH0pO1xudmFyIHJlc3VsdF9zdW1tYXJ5XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcmVzdWx0LXN1bW1hcnlcIikpO1xuZXhwb3J0cy5SZXN1bHRTdW1tYXJ5ID0gcmVzdWx0X3N1bW1hcnlfMS5kZWZhdWx0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicXVlcnlUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXN1bHRfc3VtbWFyeV8xLnF1ZXJ5VHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlckluZm9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdF9zdW1tYXJ5XzEuU2VydmVySW5mbzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBsYW5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdF9zdW1tYXJ5XzEuUGxhbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb2ZpbGVkUGxhblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzdWx0X3N1bW1hcnlfMS5Qcm9maWxlZFBsYW47IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWVyeVN0YXRpc3RpY3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdF9zdW1tYXJ5XzEuUXVlcnlTdGF0aXN0aWNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc3VsdF9zdW1tYXJ5XzEuU3RhdHM7IH0gfSk7XG52YXIgbm90aWZpY2F0aW9uXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbm90aWZpY2F0aW9uXCIpKTtcbmV4cG9ydHMuTm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uXzEuZGVmYXVsdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdxbFN0YXR1c09iamVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm90aWZpY2F0aW9uXzEuR3FsU3RhdHVzT2JqZWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm90aWZpY2F0aW9uQ2F0ZWdvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vdGlmaWNhdGlvbl8xLm5vdGlmaWNhdGlvbkNhdGVnb3J5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm90aWZpY2F0aW9uQ2xhc3NpZmljYXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vdGlmaWNhdGlvbl8xLm5vdGlmaWNhdGlvbkNsYXNzaWZpY2F0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm90aWZpY2F0aW9uXzEubm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbDsgfSB9KTtcbnZhciBub3RpZmljYXRpb25fZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9ub3RpZmljYXRpb24tZmlsdGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDYXRlZ29yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm90aWZpY2F0aW9uX2ZpbHRlcl8xLm5vdGlmaWNhdGlvbkZpbHRlckRpc2FibGVkQ2F0ZWdvcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENsYXNzaWZpY2F0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZmljYXRpb25fZmlsdGVyXzEubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDbGFzc2lmaWNhdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vdGlmaWNhdGlvbkZpbHRlck1pbmltdW1TZXZlcml0eUxldmVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBub3RpZmljYXRpb25fZmlsdGVyXzEubm90aWZpY2F0aW9uRmlsdGVyTWluaW11bVNldmVyaXR5TGV2ZWw7IH0gfSk7XG52YXIgcmVzdWx0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0XCIpKTtcbmV4cG9ydHMuUmVzdWx0ID0gcmVzdWx0XzEuZGVmYXVsdDtcbnZhciByZXN1bHRfZWFnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHQtZWFnZXJcIikpO1xuZXhwb3J0cy5FYWdlclJlc3VsdCA9IHJlc3VsdF9lYWdlcl8xLmRlZmF1bHQ7XG52YXIgY29ubmVjdGlvbl9wcm92aWRlcl8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tcHJvdmlkZXJcIikpO1xuZXhwb3J0cy5Db25uZWN0aW9uUHJvdmlkZXIgPSBjb25uZWN0aW9uX3Byb3ZpZGVyXzEuZGVmYXVsdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlbGVhc2FibGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fcHJvdmlkZXJfMS5SZWxlYXNhYmxlOyB9IH0pO1xudmFyIGNvbm5lY3Rpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb25uZWN0aW9uXCIpKTtcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IGNvbm5lY3Rpb25fMS5kZWZhdWx0O1xudmFyIHRyYW5zYWN0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIikpO1xuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXzEuZGVmYXVsdDtcbnZhciB0cmFuc2FjdGlvbl9tYW5hZ2VkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24tbWFuYWdlZFwiKSk7XG5leHBvcnRzLk1hbmFnZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uX21hbmFnZWRfMS5kZWZhdWx0O1xudmFyIHRyYW5zYWN0aW9uX3Byb21pc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi1wcm9taXNlXCIpKTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25Qcm9taXNlID0gdHJhbnNhY3Rpb25fcHJvbWlzZV8xLmRlZmF1bHQ7XG52YXIgc2Vzc2lvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Nlc3Npb25cIikpO1xuZXhwb3J0cy5TZXNzaW9uID0gc2Vzc2lvbl8xLmRlZmF1bHQ7XG52YXIgZHJpdmVyXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZHJpdmVyXCIpKSwgZHJpdmVyID0gZHJpdmVyXzE7XG5leHBvcnRzLkRyaXZlciA9IGRyaXZlcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRyaXZlciA9IGRyaXZlcjtcbnZhciBhdXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXV0aFwiKSk7XG5leHBvcnRzLmF1dGggPSBhdXRoXzEuZGVmYXVsdDtcbnZhciBib29rbWFya19tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9ib29rbWFyay1tYW5hZ2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYm9va21hcmtNYW5hZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib29rbWFya19tYW5hZ2VyXzEuYm9va21hcmtNYW5hZ2VyOyB9IH0pO1xudmFyIGF1dGhfdG9rZW5fbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vYXV0aC10b2tlbi1tYW5hZ2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXV0aFRva2VuTWFuYWdlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1dGhfdG9rZW5fbWFuYWdlcl8xLmF1dGhUb2tlbk1hbmFnZXJzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RhdGljQXV0aFRva2VuTWFuYWdlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXV0aF90b2tlbl9tYW5hZ2VyXzEuc3RhdGljQXV0aFRva2VuTWFuYWdlcjsgfSB9KTtcbnZhciBkcml2ZXJfMiA9IHJlcXVpcmUoXCIuL2RyaXZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJvdXRpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRyaXZlcl8yLnJvdXRpbmc7IH0gfSk7XG52YXIgdHlwZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIikpO1xuZXhwb3J0cy50eXBlcyA9IHR5cGVzO1xudmFyIGpzb24gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vanNvblwiKSk7XG5leHBvcnRzLmpzb24gPSBqc29uO1xudmFyIHJlc3VsdF90cmFuc2Zvcm1lcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHQtdHJhbnNmb3JtZXJzXCIpKTtcbmV4cG9ydHMucmVzdWx0VHJhbnNmb3JtZXJzID0gcmVzdWx0X3RyYW5zZm9ybWVyc18xLmRlZmF1bHQ7XG52YXIgY2xpZW50X2NlcnRpZmljYXRlXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtY2VydGlmaWNhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2NlcnRpZmljYXRlXzEuY2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlQ2VydGlmaWNhdGVQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2NlcnRpZmljYXRlXzEucmVzb2x2ZUNlcnRpZmljYXRlUHJvdmlkZXI7IH0gfSk7XG52YXIgaW50ZXJuYWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJuYWxcIikpOyAvLyB0b2RvOiByZW1vdmVkIGFmdGVyd2FyZHNcbmV4cG9ydHMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgc3RyaW5nIGNvbnN0YW50cyByZXByZXNlbnRpbmcgcHJlZGVmaW5lZCB7QGxpbmsgTmVvNGpFcnJvcn0gY29kZXMuXG4gKi9cbnZhciBlcnJvciA9IHtcbiAgICBTRVJWSUNFX1VOQVZBSUxBQkxFOiBlcnJvcl8xLlNFUlZJQ0VfVU5BVkFJTEFCTEUsXG4gICAgU0VTU0lPTl9FWFBJUkVEOiBlcnJvcl8xLlNFU1NJT05fRVhQSVJFRCxcbiAgICBQUk9UT0NPTF9FUlJPUjogZXJyb3JfMS5QUk9UT0NPTF9FUlJPUlxufTtcbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGZvckV4cG9ydCA9IHtcbiAgICBhdXRoVG9rZW5NYW5hZ2VyczogYXV0aF90b2tlbl9tYW5hZ2VyXzEuYXV0aFRva2VuTWFuYWdlcnMsXG4gICAgbmV3RXJyb3I6IGVycm9yXzEubmV3RXJyb3IsXG4gICAgTmVvNGpFcnJvcjogZXJyb3JfMS5OZW80akVycm9yLFxuICAgIG5ld0dRTEVycm9yOiBlcnJvcl8xLm5ld0dRTEVycm9yLFxuICAgIEdRTEVycm9yOiBlcnJvcl8xLkdRTEVycm9yLFxuICAgIGlzUmV0cmlhYmxlRXJyb3I6IGVycm9yXzEuaXNSZXRyaWFibGVFcnJvcixcbiAgICBlcnJvcjogZXJyb3IsXG4gICAgSW50ZWdlcjogaW50ZWdlcl8xLmRlZmF1bHQsXG4gICAgaW50OiBpbnRlZ2VyXzEuaW50LFxuICAgIGlzSW50OiBpbnRlZ2VyXzEuaXNJbnQsXG4gICAgaW5TYWZlUmFuZ2U6IGludGVnZXJfMS5pblNhZmVSYW5nZSxcbiAgICB0b051bWJlcjogaW50ZWdlcl8xLnRvTnVtYmVyLFxuICAgIHRvU3RyaW5nOiBpbnRlZ2VyXzEudG9TdHJpbmcsXG4gICAgaW50ZXJuYWw6IGludGVybmFsLFxuICAgIGlzUG9pbnQ6IHNwYXRpYWxfdHlwZXNfMS5pc1BvaW50LFxuICAgIFBvaW50OiBzcGF0aWFsX3R5cGVzXzEuUG9pbnQsXG4gICAgRGF0ZTogdGVtcG9yYWxfdHlwZXNfMS5EYXRlLFxuICAgIERhdGVUaW1lOiB0ZW1wb3JhbF90eXBlc18xLkRhdGVUaW1lLFxuICAgIER1cmF0aW9uOiB0ZW1wb3JhbF90eXBlc18xLkR1cmF0aW9uLFxuICAgIGlzRGF0ZTogdGVtcG9yYWxfdHlwZXNfMS5pc0RhdGUsXG4gICAgaXNEYXRlVGltZTogdGVtcG9yYWxfdHlwZXNfMS5pc0RhdGVUaW1lLFxuICAgIGlzRHVyYXRpb246IHRlbXBvcmFsX3R5cGVzXzEuaXNEdXJhdGlvbixcbiAgICBpc0xvY2FsRGF0ZVRpbWU6IHRlbXBvcmFsX3R5cGVzXzEuaXNMb2NhbERhdGVUaW1lLFxuICAgIGlzTG9jYWxUaW1lOiB0ZW1wb3JhbF90eXBlc18xLmlzTG9jYWxUaW1lLFxuICAgIGlzVGltZTogdGVtcG9yYWxfdHlwZXNfMS5pc1RpbWUsXG4gICAgTG9jYWxEYXRlVGltZTogdGVtcG9yYWxfdHlwZXNfMS5Mb2NhbERhdGVUaW1lLFxuICAgIExvY2FsVGltZTogdGVtcG9yYWxfdHlwZXNfMS5Mb2NhbFRpbWUsXG4gICAgVGltZTogdGVtcG9yYWxfdHlwZXNfMS5UaW1lLFxuICAgIE5vZGU6IGdyYXBoX3R5cGVzXzEuTm9kZSxcbiAgICBpc05vZGU6IGdyYXBoX3R5cGVzXzEuaXNOb2RlLFxuICAgIFJlbGF0aW9uc2hpcDogZ3JhcGhfdHlwZXNfMS5SZWxhdGlvbnNoaXAsXG4gICAgaXNSZWxhdGlvbnNoaXA6IGdyYXBoX3R5cGVzXzEuaXNSZWxhdGlvbnNoaXAsXG4gICAgVW5ib3VuZFJlbGF0aW9uc2hpcDogZ3JhcGhfdHlwZXNfMS5VbmJvdW5kUmVsYXRpb25zaGlwLFxuICAgIGlzVW5ib3VuZFJlbGF0aW9uc2hpcDogZ3JhcGhfdHlwZXNfMS5pc1VuYm91bmRSZWxhdGlvbnNoaXAsXG4gICAgUGF0aDogZ3JhcGhfdHlwZXNfMS5QYXRoLFxuICAgIGlzUGF0aDogZ3JhcGhfdHlwZXNfMS5pc1BhdGgsXG4gICAgUGF0aFNlZ21lbnQ6IGdyYXBoX3R5cGVzXzEuUGF0aFNlZ21lbnQsXG4gICAgaXNQYXRoU2VnbWVudDogZ3JhcGhfdHlwZXNfMS5pc1BhdGhTZWdtZW50LFxuICAgIFJlY29yZDogcmVjb3JkXzEuZGVmYXVsdCxcbiAgICBSZXN1bHRTdW1tYXJ5OiByZXN1bHRfc3VtbWFyeV8xLmRlZmF1bHQsXG4gICAgcXVlcnlUeXBlOiByZXN1bHRfc3VtbWFyeV8xLnF1ZXJ5VHlwZSxcbiAgICBTZXJ2ZXJJbmZvOiByZXN1bHRfc3VtbWFyeV8xLlNlcnZlckluZm8sXG4gICAgTm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25fMS5kZWZhdWx0LFxuICAgIEdxbFN0YXR1c09iamVjdDogbm90aWZpY2F0aW9uXzEuR3FsU3RhdHVzT2JqZWN0LFxuICAgIFBsYW46IHJlc3VsdF9zdW1tYXJ5XzEuUGxhbixcbiAgICBQcm9maWxlZFBsYW46IHJlc3VsdF9zdW1tYXJ5XzEuUHJvZmlsZWRQbGFuLFxuICAgIFF1ZXJ5U3RhdGlzdGljczogcmVzdWx0X3N1bW1hcnlfMS5RdWVyeVN0YXRpc3RpY3MsXG4gICAgU3RhdHM6IHJlc3VsdF9zdW1tYXJ5XzEuU3RhdHMsXG4gICAgUmVzdWx0OiByZXN1bHRfMS5kZWZhdWx0LFxuICAgIEVhZ2VyUmVzdWx0OiByZXN1bHRfZWFnZXJfMS5kZWZhdWx0LFxuICAgIFRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbl8xLmRlZmF1bHQsXG4gICAgTWFuYWdlZFRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbl9tYW5hZ2VkXzEuZGVmYXVsdCxcbiAgICBUcmFuc2FjdGlvblByb21pc2U6IHRyYW5zYWN0aW9uX3Byb21pc2VfMS5kZWZhdWx0LFxuICAgIFNlc3Npb246IHNlc3Npb25fMS5kZWZhdWx0LFxuICAgIERyaXZlcjogZHJpdmVyXzEuZGVmYXVsdCxcbiAgICBDb25uZWN0aW9uOiBjb25uZWN0aW9uXzEuZGVmYXVsdCxcbiAgICBSZWxlYXNhYmxlOiBjb25uZWN0aW9uX3Byb3ZpZGVyXzEuUmVsZWFzYWJsZSxcbiAgICB0eXBlczogdHlwZXMsXG4gICAgZHJpdmVyOiBkcml2ZXIsXG4gICAganNvbjoganNvbixcbiAgICBhdXRoOiBhdXRoXzEuZGVmYXVsdCxcbiAgICBib29rbWFya01hbmFnZXI6IGJvb2ttYXJrX21hbmFnZXJfMS5ib29rbWFya01hbmFnZXIsXG4gICAgcm91dGluZzogZHJpdmVyXzIucm91dGluZyxcbiAgICByZXN1bHRUcmFuc2Zvcm1lcnM6IHJlc3VsdF90cmFuc2Zvcm1lcnNfMS5kZWZhdWx0LFxuICAgIG5vdGlmaWNhdGlvbkNhdGVnb3J5OiBub3RpZmljYXRpb25fMS5ub3RpZmljYXRpb25DYXRlZ29yeSxcbiAgICBub3RpZmljYXRpb25DbGFzc2lmaWNhdGlvbjogbm90aWZpY2F0aW9uXzEubm90aWZpY2F0aW9uQ2xhc3NpZmljYXRpb24sXG4gICAgbm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbDogbm90aWZpY2F0aW9uXzEubm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbCxcbiAgICBub3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENhdGVnb3J5OiBub3RpZmljYXRpb25fZmlsdGVyXzEubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDYXRlZ29yeSxcbiAgICBub3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENsYXNzaWZpY2F0aW9uOiBub3RpZmljYXRpb25fZmlsdGVyXzEubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDbGFzc2lmaWNhdGlvbixcbiAgICBub3RpZmljYXRpb25GaWx0ZXJNaW5pbXVtU2V2ZXJpdHlMZXZlbDogbm90aWZpY2F0aW9uX2ZpbHRlcl8xLm5vdGlmaWNhdGlvbkZpbHRlck1pbmltdW1TZXZlcml0eUxldmVsLFxuICAgIGNsaWVudENlcnRpZmljYXRlUHJvdmlkZXJzOiBjbGllbnRfY2VydGlmaWNhdGVfMS5jbGllbnRDZXJ0aWZpY2F0ZVByb3ZpZGVycyxcbiAgICByZXNvbHZlQ2VydGlmaWNhdGVQcm92aWRlcjogY2xpZW50X2NlcnRpZmljYXRlXzEucmVzb2x2ZUNlcnRpZmljYXRlUHJvdmlkZXJcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JFeHBvcnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/integer.js":
/*!*******************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/integer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toString = exports.toNumber = exports.inSafeRange = exports.isInt = exports.int = void 0;\n// 64-bit Integer library, originally from Long.js by dcodeIO\n// https://github.com/dcodeIO/Long.js\n// License Apache 2\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\n/**\n * A cache of the Integer representations of small integer values.\n * @type {!Object}\n * @inner\n * @private\n */\n// eslint-disable-next-line no-use-before-define\nvar INT_CACHE = new Map();\n/**\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n * See exported functions for more convenient ways of operating integers.\n * Use `int()` function to create new integers, `isInt()` to check if given object is integer,\n * `inSafeRange()` to check if it is safe to convert given value to native number,\n * `toNumber()` and `toString()` to convert given integer to number or string respectively.\n * @access public\n * @exports Integer\n * @class A Integer class for representing a 64 bit two's-complement integer value.\n * @param {number} low The low (signed) 32 bits of the long\n * @param {number} high The high (signed) 32 bits of the long\n *\n * @constructor\n */\nvar Integer = /** @class */ (function () {\n    function Integer(low, high) {\n        /**\n         * The low 32 bits as a signed value.\n         * @type {number}\n         * @expose\n         */\n        this.low = low !== null && low !== void 0 ? low : 0;\n        /**\n         * The high 32 bits as a signed value.\n         * @type {number}\n         * @expose\n         */\n        this.high = high !== null && high !== void 0 ? high : 0;\n    }\n    // The internal representation of an Integer is the two given signed, 32-bit values.\n    // We use 32-bit pieces because these are the size of integers on which\n    // JavaScript performs bit-operations.  For operations like addition and\n    // multiplication, we split each number into 16 bit pieces, which can easily be\n    // multiplied within JavaScript's floating-point representation without overflow\n    // or change in sign.\n    //\n    // In the algorithms below, we frequently reduce the negative case to the\n    // positive case by negating the input(s) and then post-processing the result.\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n    // a positive number, it overflows back into a negative).  Not handling this\n    // case would often result in infinite recursion.\n    //\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n    // methods on which they depend.\n    Integer.prototype.inSafeRange = function () {\n        return (this.greaterThanOrEqual(Integer.MIN_SAFE_VALUE) &&\n            this.lessThanOrEqual(Integer.MAX_SAFE_VALUE));\n    };\n    /**\n     * Converts the Integer to an exact javascript Number, assuming it is a 32 bit integer.\n     * @returns {number}\n     * @expose\n     */\n    Integer.prototype.toInt = function () {\n        return this.low;\n    };\n    /**\n     * Converts the Integer to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n     * @returns {number}\n     * @expose\n     */\n    Integer.prototype.toNumber = function () {\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    /**\n     * Converts the Integer to a BigInt representation of this value\n     * @returns {bigint}\n     * @expose\n     */\n    Integer.prototype.toBigInt = function () {\n        if (this.isZero()) {\n            return BigInt(0);\n        }\n        else if (this.isPositive()) {\n            return (BigInt(this.high >>> 0) * BigInt(TWO_PWR_32_DBL) +\n                BigInt(this.low >>> 0));\n        }\n        else {\n            var negate = this.negate();\n            return (BigInt(-1) *\n                (BigInt(negate.high >>> 0) * BigInt(TWO_PWR_32_DBL) +\n                    BigInt(negate.low >>> 0)));\n        }\n    };\n    /**\n     * Converts the Integer to native number or -Infinity/+Infinity when it does not fit.\n     * @return {number}\n     * @package\n     */\n    Integer.prototype.toNumberOrInfinity = function () {\n        if (this.lessThan(Integer.MIN_SAFE_VALUE)) {\n            return Number.NEGATIVE_INFINITY;\n        }\n        else if (this.greaterThan(Integer.MAX_SAFE_VALUE)) {\n            return Number.POSITIVE_INFINITY;\n        }\n        else {\n            return this.toNumber();\n        }\n    };\n    /**\n     * Converts the Integer to a string written in the specified radix.\n     * @param {number=} radix Radix (2-36), defaults to 10\n     * @returns {string}\n     * @override\n     * @throws {RangeError} If `radix` is out of range\n     * @expose\n     */\n    Integer.prototype.toString = function (radix) {\n        radix = radix !== null && radix !== void 0 ? radix : 10;\n        if (radix < 2 || radix > 36) {\n            throw RangeError('radix out of range: ' + radix.toString());\n        }\n        if (this.isZero()) {\n            return '0';\n        }\n        var rem;\n        if (this.isNegative()) {\n            if (this.equals(Integer.MIN_VALUE)) {\n                // We need to change the Integer value before it can be negated, so we remove\n                // the bottom-most digit in this base and then recurse to do the rest.\n                var radixInteger = Integer.fromNumber(radix);\n                var div = this.div(radixInteger);\n                rem = div.multiply(radixInteger).subtract(this);\n                return div.toString(radix) + rem.toInt().toString(radix);\n            }\n            else {\n                return '-' + this.negate().toString(radix);\n            }\n        }\n        // Do several (6) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = Integer.fromNumber(Math.pow(radix, 6));\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        rem = this;\n        var result = '';\n        while (true) {\n            var remDiv = rem.div(radixToPower);\n            var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;\n            var digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            }\n            else {\n                while (digits.length < 6) {\n                    digits = '0' + digits;\n                }\n                result = '' + digits + result;\n            }\n        }\n    };\n    /**\n     * Converts the Integer to it primitive value.\n     *\n     * @since 5.4.0\n     * @returns {bigint}\n     *\n     * @see {@link Integer#toBigInt}\n     * @see {@link Integer#toInt}\n     * @see {@link Integer#toNumber}\n     * @see {@link Integer#toString}\n     */\n    Integer.prototype.valueOf = function () {\n        return this.toBigInt();\n    };\n    /**\n     * Gets the high 32 bits as a signed integer.\n     * @returns {number} Signed high bits\n     * @expose\n     */\n    Integer.prototype.getHighBits = function () {\n        return this.high;\n    };\n    /**\n     * Gets the low 32 bits as a signed integer.\n     * @returns {number} Signed low bits\n     * @expose\n     */\n    Integer.prototype.getLowBits = function () {\n        return this.low;\n    };\n    /**\n     * Gets the number of bits needed to represent the absolute value of this Integer.\n     * @returns {number}\n     * @expose\n     */\n    Integer.prototype.getNumBitsAbs = function () {\n        if (this.isNegative()) {\n            return this.equals(Integer.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();\n        }\n        var val = this.high !== 0 ? this.high : this.low;\n        var bit = 0;\n        for (bit = 31; bit > 0; bit--) {\n            if ((val & (1 << bit)) !== 0) {\n                break;\n            }\n        }\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    };\n    /**\n     * Tests if this Integer's value equals zero.\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.isZero = function () {\n        return this.high === 0 && this.low === 0;\n    };\n    /**\n     * Tests if this Integer's value is negative.\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.isNegative = function () {\n        return this.high < 0;\n    };\n    /**\n     * Tests if this Integer's value is positive.\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.isPositive = function () {\n        return this.high >= 0;\n    };\n    /**\n     * Tests if this Integer's value is odd.\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.isOdd = function () {\n        return (this.low & 1) === 1;\n    };\n    /**\n     * Tests if this Integer's value is even.\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.isEven = function () {\n        return (this.low & 1) === 0;\n    };\n    /**\n     * Tests if this Integer's value equals the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.equals = function (other) {\n        var theOther = Integer.fromValue(other);\n        return this.high === theOther.high && this.low === theOther.low;\n    };\n    /**\n     * Tests if this Integer's value differs from the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.notEquals = function (other) {\n        return !this.equals(/* validates */ other);\n    };\n    /**\n     * Tests if this Integer's value is less than the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.lessThan = function (other) {\n        return this.compare(/* validates */ other) < 0;\n    };\n    /**\n     * Tests if this Integer's value is less than or equal the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.lessThanOrEqual = function (other) {\n        return this.compare(/* validates */ other) <= 0;\n    };\n    /**\n     * Tests if this Integer's value is greater than the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.greaterThan = function (other) {\n        return this.compare(/* validates */ other) > 0;\n    };\n    /**\n     * Tests if this Integer's value is greater than or equal the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.prototype.greaterThanOrEqual = function (other) {\n        return this.compare(/* validates */ other) >= 0;\n    };\n    /**\n     * Compares this Integer's value with the specified's.\n     * @param {!Integer|number|string} other Other value\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n     *  if the given one is greater\n     * @expose\n     */\n    Integer.prototype.compare = function (other) {\n        var theOther = Integer.fromValue(other);\n        if (this.equals(theOther)) {\n            return 0;\n        }\n        var thisNeg = this.isNegative();\n        var otherNeg = theOther.isNegative();\n        if (thisNeg && !otherNeg) {\n            return -1;\n        }\n        if (!thisNeg && otherNeg) {\n            return 1;\n        }\n        // At this point the sign bits are the same\n        return this.subtract(theOther).isNegative() ? -1 : 1;\n    };\n    /**\n     * Negates this Integer's value.\n     * @returns {!Integer} Negated Integer\n     * @expose\n     */\n    Integer.prototype.negate = function () {\n        if (this.equals(Integer.MIN_VALUE)) {\n            return Integer.MIN_VALUE;\n        }\n        return this.not().add(Integer.ONE);\n    };\n    /**\n     * Returns the sum of this and the specified Integer.\n     * @param {!Integer|number|string} addend Addend\n     * @returns {!Integer} Sum\n     * @expose\n     */\n    Integer.prototype.add = function (addend) {\n        var theAddend = Integer.fromValue(addend);\n        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xffff;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xffff;\n        var b48 = theAddend.high >>> 16;\n        var b32 = theAddend.high & 0xffff;\n        var b16 = theAddend.low >>> 16;\n        var b00 = theAddend.low & 0xffff;\n        var c48 = 0;\n        var c32 = 0;\n        var c16 = 0;\n        var c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Integer.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n    };\n    /**\n     * Returns the difference of this and the specified Integer.\n     * @param {!Integer|number|string} subtrahend Subtrahend\n     * @returns {!Integer} Difference\n     * @expose\n     */\n    Integer.prototype.subtract = function (subtrahend) {\n        var theSubtrahend = Integer.fromValue(subtrahend);\n        return this.add(theSubtrahend.negate());\n    };\n    /**\n     * Returns the product of this and the specified Integer.\n     * @param {!Integer|number|string} multiplier Multiplier\n     * @returns {!Integer} Product\n     * @expose\n     */\n    Integer.prototype.multiply = function (multiplier) {\n        if (this.isZero()) {\n            return Integer.ZERO;\n        }\n        var theMultiplier = Integer.fromValue(multiplier);\n        if (theMultiplier.isZero()) {\n            return Integer.ZERO;\n        }\n        if (this.equals(Integer.MIN_VALUE)) {\n            return theMultiplier.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;\n        }\n        if (theMultiplier.equals(Integer.MIN_VALUE)) {\n            return this.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;\n        }\n        if (this.isNegative()) {\n            if (theMultiplier.isNegative()) {\n                return this.negate().multiply(theMultiplier.negate());\n            }\n            else {\n                return this.negate()\n                    .multiply(theMultiplier)\n                    .negate();\n            }\n        }\n        else if (theMultiplier.isNegative()) {\n            return this.multiply(theMultiplier.negate()).negate();\n        }\n        // If both longs are small, use float multiplication\n        if (this.lessThan(TWO_PWR_24) && theMultiplier.lessThan(TWO_PWR_24)) {\n            return Integer.fromNumber(this.toNumber() * theMultiplier.toNumber());\n        }\n        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n        // We can skip products that would overflow.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xffff;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xffff;\n        var b48 = theMultiplier.high >>> 16;\n        var b32 = theMultiplier.high & 0xffff;\n        var b16 = theMultiplier.low >>> 16;\n        var b00 = theMultiplier.low & 0xffff;\n        var c48 = 0;\n        var c32 = 0;\n        var c16 = 0;\n        var c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Integer.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n    };\n    /**\n     * Returns this Integer divided by the specified.\n     * @param {!Integer|number|string} divisor Divisor\n     * @returns {!Integer} Quotient\n     * @expose\n     */\n    Integer.prototype.div = function (divisor) {\n        var theDivisor = Integer.fromValue(divisor);\n        if (theDivisor.isZero()) {\n            throw (0, error_1.newError)('division by zero');\n        }\n        if (this.isZero()) {\n            return Integer.ZERO;\n        }\n        var approx, rem, res;\n        if (this.equals(Integer.MIN_VALUE)) {\n            if (theDivisor.equals(Integer.ONE) ||\n                theDivisor.equals(Integer.NEG_ONE)) {\n                return Integer.MIN_VALUE;\n            }\n            if (theDivisor.equals(Integer.MIN_VALUE)) {\n                return Integer.ONE;\n            }\n            else {\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                var halfThis = this.shiftRight(1);\n                approx = halfThis.div(theDivisor).shiftLeft(1);\n                if (approx.equals(Integer.ZERO)) {\n                    return theDivisor.isNegative() ? Integer.ONE : Integer.NEG_ONE;\n                }\n                else {\n                    rem = this.subtract(theDivisor.multiply(approx));\n                    res = approx.add(rem.div(theDivisor));\n                    return res;\n                }\n            }\n        }\n        else if (theDivisor.equals(Integer.MIN_VALUE)) {\n            return Integer.ZERO;\n        }\n        if (this.isNegative()) {\n            if (theDivisor.isNegative()) {\n                return this.negate().div(theDivisor.negate());\n            }\n            return this.negate()\n                .div(theDivisor)\n                .negate();\n        }\n        else if (theDivisor.isNegative()) {\n            return this.div(theDivisor.negate()).negate();\n        }\n        // Repeat the following until the remainder is less than other:  find a\n        // floating-point that approximates remainder / other *from below*, add this\n        // into the result, and subtract it from the remainder.  It is critical that\n        // the approximate value is less than or equal to the real value so that the\n        // remainder never becomes negative.\n        res = Integer.ZERO;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        rem = this;\n        while (rem.greaterThanOrEqual(theDivisor)) {\n            // Approximate the result of division. This may be a little greater or\n            // smaller than the actual value.\n            approx = Math.max(1, Math.floor(rem.toNumber() / theDivisor.toNumber()));\n            // We will tweak the approximate result by changing it in the 48-th digit or\n            // the smallest non-fractional digit, whichever is larger.\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            // Decrease the approximation until it is smaller than the remainder.  Note\n            // that if it is too large, the product overflows and is negative.\n            var approxRes = Integer.fromNumber(approx);\n            var approxRem = approxRes.multiply(theDivisor);\n            while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n                approx -= delta;\n                approxRes = Integer.fromNumber(approx);\n                approxRem = approxRes.multiply(theDivisor);\n            }\n            // We know the answer can't be zero... and actually, zero would cause\n            // infinite recursion since we would make no progress.\n            if (approxRes.isZero()) {\n                approxRes = Integer.ONE;\n            }\n            res = res.add(approxRes);\n            rem = rem.subtract(approxRem);\n        }\n        return res;\n    };\n    /**\n     * Returns this Integer modulo the specified.\n     * @param {!Integer|number|string} divisor Divisor\n     * @returns {!Integer} Remainder\n     * @expose\n     */\n    Integer.prototype.modulo = function (divisor) {\n        var theDivisor = Integer.fromValue(divisor);\n        return this.subtract(this.div(theDivisor).multiply(theDivisor));\n    };\n    /**\n     * Returns the bitwise NOT of this Integer.\n     * @returns {!Integer}\n     * @expose\n     */\n    Integer.prototype.not = function () {\n        return Integer.fromBits(~this.low, ~this.high);\n    };\n    /**\n     * Returns the bitwise AND of this Integer and the specified.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n    Integer.prototype.and = function (other) {\n        var theOther = Integer.fromValue(other);\n        return Integer.fromBits(this.low & theOther.low, this.high & theOther.high);\n    };\n    /**\n     * Returns the bitwise OR of this Integer and the specified.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n    Integer.prototype.or = function (other) {\n        var theOther = Integer.fromValue(other);\n        return Integer.fromBits(this.low | theOther.low, this.high | theOther.high);\n    };\n    /**\n     * Returns the bitwise XOR of this Integer and the given one.\n     * @param {!Integer|number|string} other Other Integer\n     * @returns {!Integer}\n     * @expose\n     */\n    Integer.prototype.xor = function (other) {\n        var theOther = Integer.fromValue(other);\n        return Integer.fromBits(this.low ^ theOther.low, this.high ^ theOther.high);\n    };\n    /**\n     * Returns this Integer with bits shifted to the left by the given amount.\n     * @param {number|!Integer} numBits Number of bits\n     * @returns {!Integer} Shifted Integer\n     * @expose\n     */\n    Integer.prototype.shiftLeft = function (numBits) {\n        var bitsCount = Integer.toNumber(numBits);\n        if ((bitsCount &= 63) === 0) {\n            return Integer.ZERO;\n        }\n        else if (bitsCount < 32) {\n            return Integer.fromBits(this.low << bitsCount, (this.high << bitsCount) | (this.low >>> (32 - bitsCount)));\n        }\n        else {\n            return Integer.fromBits(0, this.low << (bitsCount - 32));\n        }\n    };\n    /**\n     * Returns this Integer with bits arithmetically shifted to the right by the given amount.\n     * @param {number|!Integer} numBits Number of bits\n     * @returns {!Integer} Shifted Integer\n     * @expose\n     */\n    Integer.prototype.shiftRight = function (numBits) {\n        var bitsCount = Integer.toNumber(numBits);\n        var numBitNum = Integer.toNumber(numBits);\n        if ((bitsCount &= 63) === 0) {\n            return Integer.ZERO;\n        }\n        else if (numBitNum < 32) {\n            return Integer.fromBits((this.low >>> bitsCount) | (this.high << (32 - bitsCount)), this.high >> bitsCount);\n        }\n        else {\n            return Integer.fromBits(this.high >> (bitsCount - 32), this.high >= 0 ? 0 : -1);\n        }\n    };\n    /**\n     * Tests if the specified object is a Integer.\n     * @access private\n     * @param {*} obj Object\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.isInteger = function (obj) {\n        return (obj === null || obj === void 0 ? void 0 : obj.__isInteger__) === true;\n    };\n    /**\n     * Returns a Integer representing the given 32 bit integer value.\n     * @access private\n     * @param {number} value The 32 bit integer in question\n     * @returns {!Integer} The corresponding Integer value\n     * @expose\n     */\n    Integer.fromInt = function (value) {\n        var cachedObj;\n        value = value | 0;\n        if (value >= -128 && value < 128) {\n            cachedObj = INT_CACHE.get(value);\n            if (cachedObj != null) {\n                return cachedObj;\n            }\n        }\n        var obj = new Integer(value, value < 0 ? -1 : 0);\n        if (value >= -128 && value < 128) {\n            INT_CACHE.set(value, obj);\n        }\n        return obj;\n    };\n    /**\n     * Returns a Integer representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n     *  assumed to use 32 bits.\n     * @access private\n     * @param {number} lowBits The low 32 bits\n     * @param {number} highBits The high 32 bits\n     * @returns {!Integer} The corresponding Integer value\n     * @expose\n     */\n    Integer.fromBits = function (lowBits, highBits) {\n        return new Integer(lowBits, highBits);\n    };\n    /**\n     * Returns a Integer representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n     * @access private\n     * @param {number} value The number in question\n     * @returns {!Integer} The corresponding Integer value\n     * @expose\n     */\n    Integer.fromNumber = function (value) {\n        if (isNaN(value) || !isFinite(value)) {\n            return Integer.ZERO;\n        }\n        if (value <= -TWO_PWR_63_DBL) {\n            return Integer.MIN_VALUE;\n        }\n        if (value + 1 >= TWO_PWR_63_DBL) {\n            return Integer.MAX_VALUE;\n        }\n        if (value < 0) {\n            return Integer.fromNumber(-value).negate();\n        }\n        return new Integer(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0);\n    };\n    /**\n     * Returns a Integer representation of the given string, written using the specified radix.\n     * @access private\n     * @param {string} str The textual representation of the Integer\n     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n     * @param {Object} [opts={}] Configuration options\n     * @param {boolean} [opts.strictStringValidation=false] Enable strict validation generated Integer.\n     * @returns {!Integer} The corresponding Integer value\n     * @expose\n     */\n    Integer.fromString = function (str, radix, _a) {\n        var _b = _a === void 0 ? {} : _a, strictStringValidation = _b.strictStringValidation;\n        if (str.length === 0) {\n            throw (0, error_1.newError)('number format error: empty string');\n        }\n        if (str === 'NaN' ||\n            str === 'Infinity' ||\n            str === '+Infinity' ||\n            str === '-Infinity') {\n            return Integer.ZERO;\n        }\n        radix = radix !== null && radix !== void 0 ? radix : 10;\n        if (radix < 2 || radix > 36) {\n            throw (0, error_1.newError)('radix out of range: ' + radix.toString());\n        }\n        var p;\n        if ((p = str.indexOf('-')) > 0) {\n            throw (0, error_1.newError)('number format error: interior \"-\" character: ' + str);\n        }\n        else if (p === 0) {\n            return Integer.fromString(str.substring(1), radix).negate();\n        }\n        // Do several (8) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = Integer.fromNumber(Math.pow(radix, 8));\n        var result = Integer.ZERO;\n        for (var i = 0; i < str.length; i += 8) {\n            var size = Math.min(8, str.length - i);\n            var valueString = str.substring(i, i + size);\n            var value = parseInt(valueString, radix);\n            if (strictStringValidation === true && !_isValidNumberFromString(valueString, value, radix)) {\n                throw (0, error_1.newError)(\"number format error: \\\"\".concat(valueString, \"\\\" is NaN in radix \").concat(radix, \": \").concat(str));\n            }\n            if (size < 8) {\n                var power = Integer.fromNumber(Math.pow(radix, size));\n                result = result.multiply(power).add(Integer.fromNumber(value));\n            }\n            else {\n                result = result.multiply(radixToPower);\n                result = result.add(Integer.fromNumber(value));\n            }\n        }\n        return result;\n    };\n    /**\n     * Converts the specified value to a Integer.\n     * @access private\n     * @param {!Integer|number|string|bigint|!{low: number, high: number}} val Value\n     * @param {Object} [opts={}] Configuration options\n     * @param {boolean} [opts.strictStringValidation=false] Enable strict validation generated Integer.\n     * @param {boolean} [opts.ceilFloat=false] Enable round up float to the nearest Integer.\n     * @returns {!Integer}\n     * @expose\n     */\n    Integer.fromValue = function (val, opts) {\n        if (opts === void 0) { opts = {}; }\n        if (val /* is compatible */ instanceof Integer) {\n            return val;\n        }\n        if (typeof val === 'number') {\n            if (opts.ceilFloat === true) {\n                val = Math.ceil(val);\n            }\n            return Integer.fromNumber(val);\n        }\n        if (typeof val === 'string') {\n            return Integer.fromString(val, undefined, opts);\n        }\n        if (typeof val === 'bigint') {\n            return Integer.fromString(val.toString());\n        }\n        // Throws for non-objects, converts non-instanceof Integer:\n        return new Integer(val.low, val.high);\n    };\n    /**\n     * Converts the specified value to a number.\n     * @access private\n     * @param {!Integer|number|string|!{low: number, high: number}} val Value\n     * @returns {number}\n     * @expose\n     */\n    Integer.toNumber = function (val) {\n        switch (typeof val) {\n            case 'number':\n                return val;\n            case 'bigint':\n                return Number(val);\n            default:\n                return Integer.fromValue(val).toNumber();\n        }\n    };\n    /**\n     * Converts the specified value to a string.\n     * @access private\n     * @param {!Integer|number|string|!{low: number, high: number}} val Value\n     * @param {number} radix optional radix for string conversion, defaults to 10\n     * @returns {string}\n     * @expose\n     */\n    Integer.toString = function (val, radix) {\n        return Integer.fromValue(val).toString(radix);\n    };\n    /**\n     * Checks if the given value is in the safe range in order to be converted to a native number\n     * @access private\n     * @param {!Integer|number|string|!{low: number, high: number}} val Value\n     * @param {number} radix optional radix for string conversion, defaults to 10\n     * @returns {boolean}\n     * @expose\n     */\n    Integer.inSafeRange = function (val) {\n        return Integer.fromValue(val).inSafeRange();\n    };\n    /**\n     * Signed zero.\n     * @type {!Integer}\n     * @expose\n     */\n    Integer.ZERO = Integer.fromInt(0);\n    /**\n     * Signed one.\n     * @type {!Integer}\n     * @expose\n     */\n    Integer.ONE = Integer.fromInt(1);\n    /**\n     * Signed negative one.\n     * @type {!Integer}\n     * @expose\n     */\n    Integer.NEG_ONE = Integer.fromInt(-1);\n    /**\n     * Maximum signed value.\n     * @type {!Integer}\n     * @expose\n     */\n    Integer.MAX_VALUE = Integer.fromBits(0xffffffff | 0, 0x7fffffff | 0);\n    /**\n     * Minimum signed value.\n     * @type {!Integer}\n     * @expose\n     */\n    Integer.MIN_VALUE = Integer.fromBits(0, 0x80000000 | 0);\n    /**\n     * Minimum safe value.\n     * @type {!Integer}\n     * @expose\n     */\n    Integer.MIN_SAFE_VALUE = Integer.fromBits(0x1 | 0, 0xffffffffffe00000 | 0);\n    /**\n     * Maximum safe value.\n     * @type {!Integer}\n     * @expose\n     */\n    Integer.MAX_SAFE_VALUE = Integer.fromBits(0xffffffff | 0, 0x1fffff | 0);\n    /**\n     * An indicator used to reliably determine if an object is a Integer or not.\n     * @type {boolean}\n     * @const\n     * @expose\n     * @private\n     */\n    Integer.__isInteger__ = true;\n    return Integer;\n}());\n/**\n * @private\n * @param num\n * @param radix\n * @param minSize\n * @returns {string}\n */\nfunction _convertNumberToString(num, radix, minSize) {\n    var theNumberString = num.toString(radix);\n    var paddingLength = Math.max(minSize - theNumberString.length, 0);\n    var padding = '0'.repeat(paddingLength);\n    return \"\".concat(padding).concat(theNumberString);\n}\n/**\n *\n * @private\n * @param theString\n * @param theNumber\n * @param radix\n * @return {boolean} True if valid\n */\nfunction _isValidNumberFromString(theString, theNumber, radix) {\n    return !Number.isNaN(theString) &&\n        !Number.isNaN(theNumber) &&\n        _convertNumberToString(theNumber, radix, theString.length) === theString.toLowerCase();\n}\nObject.defineProperty(Integer.prototype, '__isInteger__', {\n    value: true,\n    enumerable: false,\n    configurable: false\n});\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_16_DBL = 1 << 16;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_24_DBL = 1 << 24;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\n * @type {number}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\n * @type {!Integer}\n * @const\n * @inner\n * @private\n */\nvar TWO_PWR_24 = Integer.fromInt(TWO_PWR_24_DBL);\n/**\n * Cast value to Integer type.\n * @access public\n * @param {Mixed} value - The value to use.\n * @param {Object} [opts={}] Configuration options\n * @param {boolean} [opts.strictStringValidation=false] Enable strict validation generated Integer.\n * @param {boolean} [opts.ceilFloat=false] Enable round up float to the nearest Integer.\n * @return {Integer} - An object of type Integer.\n */\nvar int = Integer.fromValue;\nexports.int = int;\n/**\n * Check if a variable is of Integer type.\n * @access public\n * @param {Mixed} value - The variable to check.\n * @return {Boolean} - Is it of the Integer type?\n */\nvar isInt = Integer.isInteger;\nexports.isInt = isInt;\n/**\n * Check if a variable can be safely converted to a number\n * @access public\n * @param {Mixed} value - The variable to check\n * @return {Boolean} - true if it is safe to call toNumber on variable otherwise false\n */\nvar inSafeRange = Integer.inSafeRange;\nexports.inSafeRange = inSafeRange;\n/**\n * Converts a variable to a number\n * @access public\n * @param {Mixed} value - The variable to convert\n * @return {number} - the variable as a number\n */\nvar toNumber = Integer.toNumber;\nexports.toNumber = toNumber;\n/**\n * Converts the integer to a string representation\n * @access public\n * @param {Mixed} value - The variable to convert\n * @param {number} radix - radix to use in string conversion, defaults to 10\n * @return {string} - returns a string representation of the integer\n */\nvar toString = Integer.toString;\nexports.toString = toString;\nexports[\"default\"] = Integer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxtQkFBbUIsR0FBRyxhQUFhLEdBQUcsV0FBVztBQUN2RjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pC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QWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVEsUUFBUTtBQUMzQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlZ2VyLmpzPzdjYWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b1N0cmluZyA9IGV4cG9ydHMudG9OdW1iZXIgPSBleHBvcnRzLmluU2FmZVJhbmdlID0gZXhwb3J0cy5pc0ludCA9IGV4cG9ydHMuaW50ID0gdm9pZCAwO1xuLy8gNjQtYml0IEludGVnZXIgbGlicmFyeSwgb3JpZ2luYWxseSBmcm9tIExvbmcuanMgYnkgZGNvZGVJT1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vTG9uZy5qc1xuLy8gTGljZW5zZSBBcGFjaGUgMlxudmFyIGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbi8qKlxuICogQSBjYWNoZSBvZiB0aGUgSW50ZWdlciByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXG4gKiBAdHlwZSB7IU9iamVjdH1cbiAqIEBpbm5lclxuICogQHByaXZhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG52YXIgSU5UX0NBQ0hFID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxuICogU2VlIGV4cG9ydGVkIGZ1bmN0aW9ucyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2Ygb3BlcmF0aW5nIGludGVnZXJzLlxuICogVXNlIGBpbnQoKWAgZnVuY3Rpb24gdG8gY3JlYXRlIG5ldyBpbnRlZ2VycywgYGlzSW50KClgIHRvIGNoZWNrIGlmIGdpdmVuIG9iamVjdCBpcyBpbnRlZ2VyLFxuICogYGluU2FmZVJhbmdlKClgIHRvIGNoZWNrIGlmIGl0IGlzIHNhZmUgdG8gY29udmVydCBnaXZlbiB2YWx1ZSB0byBuYXRpdmUgbnVtYmVyLFxuICogYHRvTnVtYmVyKClgIGFuZCBgdG9TdHJpbmcoKWAgdG8gY29udmVydCBnaXZlbiBpbnRlZ2VyIHRvIG51bWJlciBvciBzdHJpbmcgcmVzcGVjdGl2ZWx5LlxuICogQGFjY2VzcyBwdWJsaWNcbiAqIEBleHBvcnRzIEludGVnZXJcbiAqIEBjbGFzcyBBIEludGVnZXIgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSW50ZWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlZ2VyKGxvdywgaGlnaCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvdyA9IGxvdyAhPT0gbnVsbCAmJiBsb3cgIT09IHZvaWQgMCA/IGxvdyA6IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZXhwb3NlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoICE9PSBudWxsICYmIGhpZ2ggIT09IHZvaWQgMCA/IGhpZ2ggOiAwO1xuICAgIH1cbiAgICAvLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYW4gSW50ZWdlciBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cbiAgICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxuICAgIC8vIEphdmFTY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxuICAgIC8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcbiAgICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhU2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xuICAgIC8vIG9yIGNoYW5nZSBpbiBzaWduLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxuICAgIC8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxuICAgIC8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxuICAgIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcbiAgICAvLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXG4gICAgLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgIC8vXG4gICAgLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXG4gICAgLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cbiAgICBJbnRlZ2VyLnByb3RvdHlwZS5pblNhZmVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdyZWF0ZXJUaGFuT3JFcXVhbChJbnRlZ2VyLk1JTl9TQUZFX1ZBTFVFKSAmJlxuICAgICAgICAgICAgdGhpcy5sZXNzVGhhbk9yRXF1YWwoSW50ZWdlci5NQVhfU0FGRV9WQUxVRSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIEludGVnZXIgdG8gYW4gZXhhY3QgamF2YXNjcmlwdCBOdW1iZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvdztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBJbnRlZ2VyIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIEludGVnZXIgdG8gYSBCaWdJbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLnRvQmlnSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzUG9zaXRpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIChCaWdJbnQodGhpcy5oaWdoID4+PiAwKSAqIEJpZ0ludChUV09fUFdSXzMyX0RCTCkgK1xuICAgICAgICAgICAgICAgIEJpZ0ludCh0aGlzLmxvdyA+Pj4gMCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5lZ2F0ZSA9IHRoaXMubmVnYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gKEJpZ0ludCgtMSkgKlxuICAgICAgICAgICAgICAgIChCaWdJbnQobmVnYXRlLmhpZ2ggPj4+IDApICogQmlnSW50KFRXT19QV1JfMzJfREJMKSArXG4gICAgICAgICAgICAgICAgICAgIEJpZ0ludChuZWdhdGUubG93ID4+PiAwKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgSW50ZWdlciB0byBuYXRpdmUgbnVtYmVyIG9yIC1JbmZpbml0eS8rSW5maW5pdHkgd2hlbiBpdCBkb2VzIG5vdCBmaXQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUudG9OdW1iZXJPckluZmluaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sZXNzVGhhbihJbnRlZ2VyLk1JTl9TQUZFX1ZBTFVFKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmdyZWF0ZXJUaGFuKEludGVnZXIuTUFYX1NBRkVfVkFMVUUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIEludGVnZXIgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSByYWRpeCAhPT0gbnVsbCAmJiByYWRpeCAhPT0gdm9pZCAwID8gcmFkaXggOiAxMDtcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCByYWRpeCA+IDM2KSB7XG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCBvdXQgb2YgcmFuZ2U6ICcgKyByYWRpeC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVtO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgSW50ZWdlciB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgICAgICAgICAgICB2YXIgcmFkaXhJbnRlZ2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKHJhZGl4KTtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gdGhpcy5kaXYocmFkaXhJbnRlZ2VyKTtcbiAgICAgICAgICAgICAgICByZW0gPSBkaXYubXVsdGlwbHkocmFkaXhJbnRlZ2VyKS5zdWJ0cmFjdCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gSW50ZWdlci5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCA2KSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICByZW0gPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpO1xuICAgICAgICAgICAgdmFyIGludHZhbCA9IHJlbS5zdWJ0cmFjdChyZW1EaXYubXVsdGlwbHkocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMDtcbiAgICAgICAgICAgIHZhciBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICAgICAgcmVtID0gcmVtRGl2O1xuICAgICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIEludGVnZXIgdG8gaXQgcHJpbWl0aXZlIHZhbHVlLlxuICAgICAqXG4gICAgICogQHNpbmNlIDUuNC4wXG4gICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEludGVnZXIjdG9CaWdJbnR9XG4gICAgICogQHNlZSB7QGxpbmsgSW50ZWdlciN0b0ludH1cbiAgICAgKiBAc2VlIHtAbGluayBJbnRlZ2VyI3RvTnVtYmVyfVxuICAgICAqIEBzZWUge0BsaW5rIEludGVnZXIjdG9TdHJpbmd9XG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9CaWdJbnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLnByb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEludGVnZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoSW50ZWdlci5NSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZ2F0ZSgpLmdldE51bUJpdHNBYnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9PSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gICAgICAgIHZhciBiaXQgPSAwO1xuICAgICAgICBmb3IgKGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkge1xuICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT09IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBlcXVhbHMgemVyby5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPCAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGlzIG9kZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGlzIGV2ZW4uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgdGhlT3RoZXIgPSBJbnRlZ2VyLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IHRoZU90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IHRoZU90aGVyLmxvdztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgSW50ZWdlcidzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxdWFscygvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIEludGVnZXIncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhpcyBJbnRlZ2VyJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHRoZU90aGVyID0gSW50ZWdlci5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5lcXVhbHModGhlT3RoZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpO1xuICAgICAgICB2YXIgb3RoZXJOZWcgPSB0aGVPdGhlci5pc05lZ2F0aXZlKCk7XG4gICAgICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdCh0aGVPdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTmVnYXRlcyB0aGlzIEludGVnZXIncyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IE5lZ2F0ZWQgSW50ZWdlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhJbnRlZ2VyLk1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoSW50ZWdlci5PTkUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZWdlci5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFN1bVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYWRkZW5kKSB7XG4gICAgICAgIHZhciB0aGVBZGRlbmQgPSBJbnRlZ2VyLmZyb21WYWx1ZShhZGRlbmQpO1xuICAgICAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgdmFyIGI0OCA9IHRoZUFkZGVuZC5oaWdoID4+PiAxNjtcbiAgICAgICAgdmFyIGIzMiA9IHRoZUFkZGVuZC5oaWdoICYgMHhmZmZmO1xuICAgICAgICB2YXIgYjE2ID0gdGhlQWRkZW5kLmxvdyA+Pj4gMTY7XG4gICAgICAgIHZhciBiMDAgPSB0aGVBZGRlbmQubG93ICYgMHhmZmZmO1xuICAgICAgICB2YXIgYzQ4ID0gMDtcbiAgICAgICAgdmFyIGMzMiA9IDA7XG4gICAgICAgIHZhciBjMTYgPSAwO1xuICAgICAgICB2YXIgYzAwID0gMDtcbiAgICAgICAgYzAwICs9IGEwMCArIGIwMDtcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICAgIGMwMCAmPSAweGZmZmY7XG4gICAgICAgIGMxNiArPSBhMTYgKyBiMTY7XG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTMyICsgYjMyO1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzQ4ICs9IGE0OCArIGI0ODtcbiAgICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBJbnRlZ2VyLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfSBEaWZmZXJlbmNlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHN1YnRyYWhlbmQpIHtcbiAgICAgICAgdmFyIHRoZVN1YnRyYWhlbmQgPSBJbnRlZ2VyLmZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHRoZVN1YnRyYWhlbmQubmVnYXRlKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIEludGVnZXIuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFByb2R1Y3RcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAobXVsdGlwbGllcikge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhlTXVsdGlwbGllciA9IEludGVnZXIuZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xuICAgICAgICBpZiAodGhlTXVsdGlwbGllci5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lcXVhbHMoSW50ZWdlci5NSU5fVkFMVUUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhlTXVsdGlwbGllci5pc09kZCgpID8gSW50ZWdlci5NSU5fVkFMVUUgOiBJbnRlZ2VyLlpFUk87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoZU11bHRpcGxpZXIuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IEludGVnZXIuTUlOX1ZBTFVFIDogSW50ZWdlci5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoZU11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlKCkubXVsdGlwbHkodGhlTXVsdGlwbGllci5uZWdhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKVxuICAgICAgICAgICAgICAgICAgICAubXVsdGlwbHkodGhlTXVsdGlwbGllcilcbiAgICAgICAgICAgICAgICAgICAgLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoZU11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseSh0aGVNdWx0aXBsaWVyLm5lZ2F0ZSgpKS5uZWdhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIGlmICh0aGlzLmxlc3NUaGFuKFRXT19QV1JfMjQpICYmIHRoZU11bHRpcGxpZXIubGVzc1RoYW4oVFdPX1BXUl8yNCkpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogdGhlTXVsdGlwbGllci50b051bWJlcigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cbiAgICAgICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgdmFyIGI0OCA9IHRoZU11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgICAgIHZhciBiMzIgPSB0aGVNdWx0aXBsaWVyLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIHZhciBiMTYgPSB0aGVNdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XG4gICAgICAgIHZhciBiMDAgPSB0aGVNdWx0aXBsaWVyLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgdmFyIGM0OCA9IDA7XG4gICAgICAgIHZhciBjMzIgPSAwO1xuICAgICAgICB2YXIgYzE2ID0gMDtcbiAgICAgICAgdmFyIGMwMCA9IDA7XG4gICAgICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgICBjMDAgJj0gMHhmZmZmO1xuICAgICAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgICAgIGM0OCAmPSAweGZmZmY7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgSW50ZWdlciBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFF1b3RpZW50XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIChkaXZpc29yKSB7XG4gICAgICAgIHZhciB0aGVEaXZpc29yID0gSW50ZWdlci5mcm9tVmFsdWUoZGl2aXNvcik7XG4gICAgICAgIGlmICh0aGVEaXZpc29yLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JfMS5uZXdFcnJvcikoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICAgICAgaWYgKHRoZURpdmlzb3IuZXF1YWxzKEludGVnZXIuT05FKSB8fFxuICAgICAgICAgICAgICAgIHRoZURpdmlzb3IuZXF1YWxzKEludGVnZXIuTkVHX09ORSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW50ZWdlci5NSU5fVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhlRGl2aXNvci5lcXVhbHMoSW50ZWdlci5NSU5fVkFMVUUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuT05FO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hpZnRSaWdodCgxKTtcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYodGhlRGl2aXNvcikuc2hpZnRMZWZ0KDEpO1xuICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXF1YWxzKEludGVnZXIuWkVSTykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZURpdmlzb3IuaXNOZWdhdGl2ZSgpID8gSW50ZWdlci5PTkUgOiBJbnRlZ2VyLk5FR19PTkU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YnRyYWN0KHRoZURpdmlzb3IubXVsdGlwbHkoYXBwcm94KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdih0aGVEaXZpc29yKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoZURpdmlzb3IuZXF1YWxzKEludGVnZXIuTUlOX1ZBTFVFKSkge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGVEaXZpc29yLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLmRpdih0aGVEaXZpc29yLm5lZ2F0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpXG4gICAgICAgICAgICAgICAgLmRpdih0aGVEaXZpc29yKVxuICAgICAgICAgICAgICAgIC5uZWdhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVEaXZpc29yLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KHRoZURpdmlzb3IubmVnYXRlKCkpLm5lZ2F0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gICAgICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgICAgICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAgICAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gICAgICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICAgICAgICByZXMgPSBJbnRlZ2VyLlpFUk87XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICByZW0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAocmVtLmdyZWF0ZXJUaGFuT3JFcXVhbCh0aGVEaXZpc29yKSkge1xuICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxuICAgICAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gdGhlRGl2aXNvci50b051bWJlcigpKSk7XG4gICAgICAgICAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXG4gICAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gbG9nMiA8PSA0OCA/IDEgOiBNYXRoLnBvdygyLCBsb2cyIC0gNDgpO1xuICAgICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXG4gICAgICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cbiAgICAgICAgICAgIHZhciBhcHByb3hSZXMgPSBJbnRlZ2VyLmZyb21OdW1iZXIoYXBwcm94KTtcbiAgICAgICAgICAgIHZhciBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsdGlwbHkodGhlRGl2aXNvcik7XG4gICAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3JlYXRlclRoYW4ocmVtKSkge1xuICAgICAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBJbnRlZ2VyLmZyb21OdW1iZXIoYXBwcm94KTtcbiAgICAgICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsdGlwbHkodGhlRGl2aXNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcbiAgICAgICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxuICAgICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IEludGVnZXIuT05FO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgICAgICAgcmVtID0gcmVtLnN1YnRyYWN0KGFwcHJveFJlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBJbnRlZ2VyIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfSBSZW1haW5kZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gKGRpdmlzb3IpIHtcbiAgICAgICAgdmFyIHRoZURpdmlzb3IgPSBJbnRlZ2VyLmZyb21WYWx1ZShkaXZpc29yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3QodGhpcy5kaXYodGhlRGl2aXNvcikubXVsdGlwbHkodGhlRGl2aXNvcikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBJbnRlZ2VyLlxuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBJbnRlZ2VyIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgSW50ZWdlclxuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciB0aGVPdGhlciA9IEludGVnZXIuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHModGhpcy5sb3cgJiB0aGVPdGhlci5sb3csIHRoaXMuaGlnaCAmIHRoZU90aGVyLmhpZ2gpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIEludGVnZXIgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBJbnRlZ2VyXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgdGhlT3RoZXIgPSBJbnRlZ2VyLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKHRoaXMubG93IHwgdGhlT3RoZXIubG93LCB0aGlzLmhpZ2ggfCB0aGVPdGhlci5oaWdoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgSW50ZWdlciBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIEludGVnZXJcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgdGhlT3RoZXIgPSBJbnRlZ2VyLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKHRoaXMubG93IF4gdGhlT3RoZXIubG93LCB0aGlzLmhpZ2ggXiB0aGVPdGhlci5oaWdoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBJbnRlZ2VyIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUludGVnZXJ9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFNoaWZ0ZWQgSW50ZWdlclxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiAobnVtQml0cykge1xuICAgICAgICB2YXIgYml0c0NvdW50ID0gSW50ZWdlci50b051bWJlcihudW1CaXRzKTtcbiAgICAgICAgaWYgKChiaXRzQ291bnQgJj0gNjMpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlci5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJpdHNDb3VudCA8IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cyh0aGlzLmxvdyA8PCBiaXRzQ291bnQsICh0aGlzLmhpZ2ggPDwgYml0c0NvdW50KSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gYml0c0NvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKGJpdHNDb3VudCAtIDMyKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBJbnRlZ2VyIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFJbnRlZ2VyfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfSBTaGlmdGVkIEludGVnZXJcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIChudW1CaXRzKSB7XG4gICAgICAgIHZhciBiaXRzQ291bnQgPSBJbnRlZ2VyLnRvTnVtYmVyKG51bUJpdHMpO1xuICAgICAgICB2YXIgbnVtQml0TnVtID0gSW50ZWdlci50b051bWJlcihudW1CaXRzKTtcbiAgICAgICAgaWYgKChiaXRzQ291bnQgJj0gNjMpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlci5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bUJpdE51bSA8IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlci5mcm9tQml0cygodGhpcy5sb3cgPj4+IGJpdHNDb3VudCkgfCAodGhpcy5oaWdoIDw8ICgzMiAtIGJpdHNDb3VudCkpLCB0aGlzLmhpZ2ggPj4gYml0c0NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21CaXRzKHRoaXMuaGlnaCA+PiAoYml0c0NvdW50IC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgSW50ZWdlci5cbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLl9faXNJbnRlZ2VyX18pID09PSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfSBUaGUgY29ycmVzcG9uZGluZyBJbnRlZ2VyIHZhbHVlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIuZnJvbUludCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FjaGVkT2JqO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHwgMDtcbiAgICAgICAgaWYgKHZhbHVlID49IC0xMjggJiYgdmFsdWUgPCAxMjgpIHtcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRS5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZE9iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqID0gbmV3IEludGVnZXIodmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMTI4ICYmIHZhbHVlIDwgMTI4KSB7XG4gICAgICAgICAgICBJTlRfQ0FDSEUuc2V0KHZhbHVlLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSW50ZWdlciByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcbiAgICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xuICAgICAqIEByZXR1cm5zIHshSW50ZWdlcn0gVGhlIGNvcnJlc3BvbmRpbmcgSW50ZWdlciB2YWx1ZVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLmZyb21CaXRzID0gZnVuY3Rpb24gKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZWdlcihsb3dCaXRzLCBoaWdoQml0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSW50ZWdlciByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfSBUaGUgY29ycmVzcG9uZGluZyBJbnRlZ2VyIHZhbHVlXG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIuZnJvbU51bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyLlpFUk87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTCkge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuTUlOX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlci5mcm9tTnVtYmVyKC12YWx1ZSkubmVnYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlZ2VyKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBJbnRlZ2VyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBJbnRlZ2VyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN0cmljdFN0cmluZ1ZhbGlkYXRpb249ZmFsc2VdIEVuYWJsZSBzdHJpY3QgdmFsaWRhdGlvbiBnZW5lcmF0ZWQgSW50ZWdlci5cbiAgICAgKiBAcmV0dXJucyB7IUludGVnZXJ9IFRoZSBjb3JyZXNwb25kaW5nIEludGVnZXIgdmFsdWVcbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0ciwgcmFkaXgsIF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBzdHJpY3RTdHJpbmdWYWxpZGF0aW9uID0gX2Iuc3RyaWN0U3RyaW5nVmFsaWRhdGlvbjtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnbnVtYmVyIGZvcm1hdCBlcnJvcjogZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ciA9PT0gJ05hTicgfHxcbiAgICAgICAgICAgIHN0ciA9PT0gJ0luZmluaXR5JyB8fFxuICAgICAgICAgICAgc3RyID09PSAnK0luZmluaXR5JyB8fFxuICAgICAgICAgICAgc3RyID09PSAnLUluZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuWkVSTztcbiAgICAgICAgfVxuICAgICAgICByYWRpeCA9IHJhZGl4ICE9PSBudWxsICYmIHJhZGl4ICE9PSB2b2lkIDAgPyByYWRpeCA6IDEwO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgncmFkaXggb3V0IG9mIHJhbmdlOiAnICsgcmFkaXgudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHA7XG4gICAgICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdudW1iZXIgZm9ybWF0IGVycm9yOiBpbnRlcmlvciBcIi1cIiBjaGFyYWN0ZXI6ICcgKyBzdHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgcmFkaXgpLm5lZ2F0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBJbnRlZ2VyLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDgpKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEludGVnZXIuWkVSTztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpO1xuICAgICAgICAgICAgdmFyIHZhbHVlU3RyaW5nID0gc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludCh2YWx1ZVN0cmluZywgcmFkaXgpO1xuICAgICAgICAgICAgaWYgKHN0cmljdFN0cmluZ1ZhbGlkYXRpb24gPT09IHRydWUgJiYgIV9pc1ZhbGlkTnVtYmVyRnJvbVN0cmluZyh2YWx1ZVN0cmluZywgdmFsdWUsIHJhZGl4KSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKShcIm51bWJlciBmb3JtYXQgZXJyb3I6IFxcXCJcIi5jb25jYXQodmFsdWVTdHJpbmcsIFwiXFxcIiBpcyBOYU4gaW4gcmFkaXggXCIpLmNvbmNhdChyYWRpeCwgXCI6IFwiKS5jb25jYXQoc3RyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG93ZXIgPSBJbnRlZ2VyLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIHNpemUpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsdGlwbHkocG93ZXIpLmFkZChJbnRlZ2VyLmZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShyYWRpeFRvUG93ZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoSW50ZWdlci5mcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBJbnRlZ2VyLlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7IUludGVnZXJ8bnVtYmVyfHN0cmluZ3xiaWdpbnR8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyfX0gdmFsIFZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN0cmljdFN0cmluZ1ZhbGlkYXRpb249ZmFsc2VdIEVuYWJsZSBzdHJpY3QgdmFsaWRhdGlvbiBnZW5lcmF0ZWQgSW50ZWdlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmNlaWxGbG9hdD1mYWxzZV0gRW5hYmxlIHJvdW5kIHVwIGZsb2F0IHRvIHRoZSBuZWFyZXN0IEludGVnZXIuXG4gICAgICogQHJldHVybnMgeyFJbnRlZ2VyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLmZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgaWYgKHZhbCAvKiBpcyBjb21wYXRpYmxlICovIGluc3RhbmNlb2YgSW50ZWdlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmNlaWxGbG9hdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IE1hdGguY2VpbCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbU51bWJlcih2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbVN0cmluZyh2YWwsIHVuZGVmaW5lZCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlci5mcm9tU3RyaW5nKHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBJbnRlZ2VyOlxuICAgICAgICByZXR1cm4gbmV3IEludGVnZXIodmFsLmxvdywgdmFsLmhpZ2gpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIG51bWJlci5cbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyfX0gdmFsIFZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci50b051bWJlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbVZhbHVlKHZhbCkudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyFJbnRlZ2VyfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyfX0gdmFsIFZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl4IG9wdGlvbmFsIHJhZGl4IGZvciBzdHJpbmcgY29udmVyc2lvbiwgZGVmYXVsdHMgdG8gMTBcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLnRvU3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgcmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIEludGVnZXIuZnJvbVZhbHVlKHZhbCkudG9TdHJpbmcocmFkaXgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBpbiB0aGUgc2FmZSByYW5nZSBpbiBvcmRlciB0byBiZSBjb252ZXJ0ZWQgdG8gYSBuYXRpdmUgbnVtYmVyXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICogQHBhcmFtIHshSW50ZWdlcnxudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlcn19IHZhbCBWYWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpeCBvcHRpb25hbCByYWRpeCBmb3Igc3RyaW5nIGNvbnZlcnNpb24sIGRlZmF1bHRzIHRvIDEwXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIuaW5TYWZlUmFuZ2UgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBJbnRlZ2VyLmZyb21WYWx1ZSh2YWwpLmluU2FmZVJhbmdlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaWduZWQgemVyby5cbiAgICAgKiBAdHlwZSB7IUludGVnZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIuWkVSTyA9IEludGVnZXIuZnJvbUludCgwKTtcbiAgICAvKipcbiAgICAgKiBTaWduZWQgb25lLlxuICAgICAqIEB0eXBlIHshSW50ZWdlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5PTkUgPSBJbnRlZ2VyLmZyb21JbnQoMSk7XG4gICAgLyoqXG4gICAgICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cbiAgICAgKiBAdHlwZSB7IUludGVnZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIuTkVHX09ORSA9IEludGVnZXIuZnJvbUludCgtMSk7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUgeyFJbnRlZ2VyfVxuICAgICAqIEBleHBvc2VcbiAgICAgKi9cbiAgICBJbnRlZ2VyLk1BWF9WQUxVRSA9IEludGVnZXIuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4N2ZmZmZmZmYgfCAwKTtcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7IUludGVnZXJ9XG4gICAgICogQGV4cG9zZVxuICAgICAqL1xuICAgIEludGVnZXIuTUlOX1ZBTFVFID0gSW50ZWdlci5mcm9tQml0cygwLCAweDgwMDAwMDAwIHwgMCk7XG4gICAgLyoqXG4gICAgICogTWluaW11bSBzYWZlIHZhbHVlLlxuICAgICAqIEB0eXBlIHshSW50ZWdlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5NSU5fU0FGRV9WQUxVRSA9IEludGVnZXIuZnJvbUJpdHMoMHgxIHwgMCwgMHhmZmZmZmZmZmZmZTAwMDAwIHwgMCk7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBzYWZlIHZhbHVlLlxuICAgICAqIEB0eXBlIHshSW50ZWdlcn1cbiAgICAgKiBAZXhwb3NlXG4gICAgICovXG4gICAgSW50ZWdlci5NQVhfU0FGRV9WQUxVRSA9IEludGVnZXIuZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4MWZmZmZmIHwgMCk7XG4gICAgLyoqXG4gICAgICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEludGVnZXIgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBjb25zdFxuICAgICAqIEBleHBvc2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEludGVnZXIuX19pc0ludGVnZXJfXyA9IHRydWU7XG4gICAgcmV0dXJuIEludGVnZXI7XG59KCkpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG51bVxuICogQHBhcmFtIHJhZGl4XG4gKiBAcGFyYW0gbWluU2l6ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gX2NvbnZlcnROdW1iZXJUb1N0cmluZyhudW0sIHJhZGl4LCBtaW5TaXplKSB7XG4gICAgdmFyIHRoZU51bWJlclN0cmluZyA9IG51bS50b1N0cmluZyhyYWRpeCk7XG4gICAgdmFyIHBhZGRpbmdMZW5ndGggPSBNYXRoLm1heChtaW5TaXplIC0gdGhlTnVtYmVyU3RyaW5nLmxlbmd0aCwgMCk7XG4gICAgdmFyIHBhZGRpbmcgPSAnMCcucmVwZWF0KHBhZGRpbmdMZW5ndGgpO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChwYWRkaW5nKS5jb25jYXQodGhlTnVtYmVyU3RyaW5nKTtcbn1cbi8qKlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gdGhlU3RyaW5nXG4gKiBAcGFyYW0gdGhlTnVtYmVyXG4gKiBAcGFyYW0gcmFkaXhcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsaWRcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWROdW1iZXJGcm9tU3RyaW5nKHRoZVN0cmluZywgdGhlTnVtYmVyLCByYWRpeCkge1xuICAgIHJldHVybiAhTnVtYmVyLmlzTmFOKHRoZVN0cmluZykgJiZcbiAgICAgICAgIU51bWJlci5pc05hTih0aGVOdW1iZXIpICYmXG4gICAgICAgIF9jb252ZXJ0TnVtYmVyVG9TdHJpbmcodGhlTnVtYmVyLCByYWRpeCwgdGhlU3RyaW5nLmxlbmd0aCkgPT09IHRoZVN0cmluZy50b0xvd2VyQ2FzZSgpO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEludGVnZXIucHJvdG90eXBlLCAnX19pc0ludGVnZXJfXycsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICogQHByaXZhdGVcbiAqL1xudmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICogQGlubmVyXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcbi8qKlxuICogQHR5cGUgeyFJbnRlZ2VyfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBUV09fUFdSXzI0ID0gSW50ZWdlci5mcm9tSW50KFRXT19QV1JfMjRfREJMKTtcbi8qKlxuICogQ2FzdCB2YWx1ZSB0byBJbnRlZ2VyIHR5cGUuXG4gKiBAYWNjZXNzIHB1YmxpY1xuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3RyaWN0U3RyaW5nVmFsaWRhdGlvbj1mYWxzZV0gRW5hYmxlIHN0cmljdCB2YWxpZGF0aW9uIGdlbmVyYXRlZCBJbnRlZ2VyLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5jZWlsRmxvYXQ9ZmFsc2VdIEVuYWJsZSByb3VuZCB1cCBmbG9hdCB0byB0aGUgbmVhcmVzdCBJbnRlZ2VyLlxuICogQHJldHVybiB7SW50ZWdlcn0gLSBBbiBvYmplY3Qgb2YgdHlwZSBJbnRlZ2VyLlxuICovXG52YXIgaW50ID0gSW50ZWdlci5mcm9tVmFsdWU7XG5leHBvcnRzLmludCA9IGludDtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YXJpYWJsZSBpcyBvZiBJbnRlZ2VyIHR5cGUuXG4gKiBAYWNjZXNzIHB1YmxpY1xuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBUaGUgdmFyaWFibGUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIElzIGl0IG9mIHRoZSBJbnRlZ2VyIHR5cGU/XG4gKi9cbnZhciBpc0ludCA9IEludGVnZXIuaXNJbnRlZ2VyO1xuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhcmlhYmxlIGNhbiBiZSBzYWZlbHkgY29udmVydGVkIHRvIGEgbnVtYmVyXG4gKiBAYWNjZXNzIHB1YmxpY1xuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBUaGUgdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBpdCBpcyBzYWZlIHRvIGNhbGwgdG9OdW1iZXIgb24gdmFyaWFibGUgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpblNhZmVSYW5nZSA9IEludGVnZXIuaW5TYWZlUmFuZ2U7XG5leHBvcnRzLmluU2FmZVJhbmdlID0gaW5TYWZlUmFuZ2U7XG4vKipcbiAqIENvbnZlcnRzIGEgdmFyaWFibGUgdG8gYSBudW1iZXJcbiAqIEBhY2Nlc3MgcHVibGljXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFRoZSB2YXJpYWJsZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gdGhlIHZhcmlhYmxlIGFzIGEgbnVtYmVyXG4gKi9cbnZhciB0b051bWJlciA9IEludGVnZXIudG9OdW1iZXI7XG5leHBvcnRzLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnRzIHRoZSBpbnRlZ2VyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBAYWNjZXNzIHB1YmxpY1xuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBUaGUgdmFyaWFibGUgdG8gY29udmVydFxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl4IC0gcmFkaXggdG8gdXNlIGluIHN0cmluZyBjb252ZXJzaW9uLCBkZWZhdWx0cyB0byAxMFxuICogQHJldHVybiB7c3RyaW5nfSAtIHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXJcbiAqL1xudmFyIHRvU3RyaW5nID0gSW50ZWdlci50b1N0cmluZztcbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbmV4cG9ydHMuZGVmYXVsdCA9IEludGVnZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/integer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/auth-util.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/auth-util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cacheKey = void 0;\nvar json_1 = __webpack_require__(/*! ../json */ \"(rsc)/./node_modules/neo4j-driver-core/lib/json.js\");\nfunction cacheKey(auth, impersonatedUser) {\n    var _a;\n    if (impersonatedUser != null) {\n        return 'basic:' + impersonatedUser;\n    }\n    if (auth === undefined) {\n        return 'DEFAULT';\n    }\n    if (auth.scheme === 'basic') {\n        return 'basic:' + ((_a = auth.principal) !== null && _a !== void 0 ? _a : '');\n    }\n    if (auth.scheme === 'kerberos') {\n        return 'kerberos:' + auth.credentials;\n    }\n    if (auth.scheme === 'bearer') {\n        return 'bearer:' + auth.credentials;\n    }\n    if (auth.scheme === 'none') {\n        return 'none';\n    }\n    return (0, json_1.stringify)(auth, { sortedElements: true });\n}\nexports.cacheKey = cacheKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2F1dGgtdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixhQUFhLG1CQUFPLENBQUMsbUVBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlcm5hbC9hdXRoLXV0aWwuanM/OTQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhY2hlS2V5ID0gdm9pZCAwO1xudmFyIGpzb25fMSA9IHJlcXVpcmUoXCIuLi9qc29uXCIpO1xuZnVuY3Rpb24gY2FjaGVLZXkoYXV0aCwgaW1wZXJzb25hdGVkVXNlcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaW1wZXJzb25hdGVkVXNlciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnYmFzaWM6JyArIGltcGVyc29uYXRlZFVzZXI7XG4gICAgfVxuICAgIGlmIChhdXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICdERUZBVUxUJztcbiAgICB9XG4gICAgaWYgKGF1dGguc2NoZW1lID09PSAnYmFzaWMnKSB7XG4gICAgICAgIHJldHVybiAnYmFzaWM6JyArICgoX2EgPSBhdXRoLnByaW5jaXBhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgIH1cbiAgICBpZiAoYXV0aC5zY2hlbWUgPT09ICdrZXJiZXJvcycpIHtcbiAgICAgICAgcmV0dXJuICdrZXJiZXJvczonICsgYXV0aC5jcmVkZW50aWFscztcbiAgICB9XG4gICAgaWYgKGF1dGguc2NoZW1lID09PSAnYmVhcmVyJykge1xuICAgICAgICByZXR1cm4gJ2JlYXJlcjonICsgYXV0aC5jcmVkZW50aWFscztcbiAgICB9XG4gICAgaWYgKGF1dGguc2NoZW1lID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICB9XG4gICAgcmV0dXJuICgwLCBqc29uXzEuc3RyaW5naWZ5KShhdXRoLCB7IHNvcnRlZEVsZW1lbnRzOiB0cnVlIH0pO1xufVxuZXhwb3J0cy5jYWNoZUtleSA9IGNhY2hlS2V5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/auth-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/bolt-agent/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./node */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/node/index.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2JvbHQtYWdlbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNEZBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlcm5hbC9ib2x0LWFnZW50L2luZGV4LmpzP2NiODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbm9kZVwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/node/bolt-agent.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/bolt-agent/node/bolt-agent.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromVersion = void 0;\n/**\n* Copyright (c) \"Neo4j\"\n* Neo4j Sweden AB [https://neo4j.com]\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\nvar os_1 = __webpack_require__(/*! os */ \"os\");\n/**\n * Constructs a BoltAgent structure from a given product version.\n *\n * @param {string} version The product version\n * @param {function():SystemInfo} getSystemInfo Parameter used of inject system information and mock calls to the APIs.\n * @returns {BoltAgent} The bolt agent\n */\nfunction fromVersion(version, getSystemInfo) {\n    if (getSystemInfo === void 0) { getSystemInfo = function () { return ({\n        hostArch: process.config.variables.host_arch,\n        nodeVersion: process.versions.node,\n        v8Version: process.versions.v8,\n        get platform() {\n            return (0, os_1.platform)();\n        },\n        get release() {\n            return (0, os_1.release)();\n        }\n    }); }; }\n    var systemInfo = getSystemInfo();\n    var HOST_ARCH = systemInfo.hostArch;\n    var NODE_VERSION = 'Node/' + systemInfo.nodeVersion;\n    var NODE_V8_VERSION = systemInfo.v8Version;\n    var OS_NAME_VERSION = \"\".concat(systemInfo.platform, \" \").concat(systemInfo.release);\n    return {\n        product: \"neo4j-javascript/\".concat(version),\n        platform: \"\".concat(OS_NAME_VERSION, \"; \").concat(HOST_ARCH),\n        languageDetails: \"\".concat(NODE_VERSION, \" (v8 \").concat(NODE_V8_VERSION, \")\")\n    };\n}\nexports.fromVersion = fromVersion;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2JvbHQtYWdlbnQvbm9kZS9ib2x0LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQyxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvYm9sdC1hZ2VudC9ub2RlL2JvbHQtYWdlbnQuanM/YjViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnJvbVZlcnNpb24gPSB2b2lkIDA7XG4vKipcbiogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xudmFyIG9zXzEgPSByZXF1aXJlKFwib3NcIik7XG4vKipcbiAqIENvbnN0cnVjdHMgYSBCb2x0QWdlbnQgc3RydWN0dXJlIGZyb20gYSBnaXZlbiBwcm9kdWN0IHZlcnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVGhlIHByb2R1Y3QgdmVyc2lvblxuICogQHBhcmFtIHtmdW5jdGlvbigpOlN5c3RlbUluZm99IGdldFN5c3RlbUluZm8gUGFyYW1ldGVyIHVzZWQgb2YgaW5qZWN0IHN5c3RlbSBpbmZvcm1hdGlvbiBhbmQgbW9jayBjYWxscyB0byB0aGUgQVBJcy5cbiAqIEByZXR1cm5zIHtCb2x0QWdlbnR9IFRoZSBib2x0IGFnZW50XG4gKi9cbmZ1bmN0aW9uIGZyb21WZXJzaW9uKHZlcnNpb24sIGdldFN5c3RlbUluZm8pIHtcbiAgICBpZiAoZ2V0U3lzdGVtSW5mbyA9PT0gdm9pZCAwKSB7IGdldFN5c3RlbUluZm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICBob3N0QXJjaDogcHJvY2Vzcy5jb25maWcudmFyaWFibGVzLmhvc3RfYXJjaCxcbiAgICAgICAgbm9kZVZlcnNpb246IHByb2Nlc3MudmVyc2lvbnMubm9kZSxcbiAgICAgICAgdjhWZXJzaW9uOiBwcm9jZXNzLnZlcnNpb25zLnY4LFxuICAgICAgICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG9zXzEucGxhdGZvcm0pKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCByZWxlYXNlKCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBvc18xLnJlbGVhc2UpKCk7XG4gICAgICAgIH1cbiAgICB9KTsgfTsgfVxuICAgIHZhciBzeXN0ZW1JbmZvID0gZ2V0U3lzdGVtSW5mbygpO1xuICAgIHZhciBIT1NUX0FSQ0ggPSBzeXN0ZW1JbmZvLmhvc3RBcmNoO1xuICAgIHZhciBOT0RFX1ZFUlNJT04gPSAnTm9kZS8nICsgc3lzdGVtSW5mby5ub2RlVmVyc2lvbjtcbiAgICB2YXIgTk9ERV9WOF9WRVJTSU9OID0gc3lzdGVtSW5mby52OFZlcnNpb247XG4gICAgdmFyIE9TX05BTUVfVkVSU0lPTiA9IFwiXCIuY29uY2F0KHN5c3RlbUluZm8ucGxhdGZvcm0sIFwiIFwiKS5jb25jYXQoc3lzdGVtSW5mby5yZWxlYXNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9kdWN0OiBcIm5lbzRqLWphdmFzY3JpcHQvXCIuY29uY2F0KHZlcnNpb24pLFxuICAgICAgICBwbGF0Zm9ybTogXCJcIi5jb25jYXQoT1NfTkFNRV9WRVJTSU9OLCBcIjsgXCIpLmNvbmNhdChIT1NUX0FSQ0gpLFxuICAgICAgICBsYW5ndWFnZURldGFpbHM6IFwiXCIuY29uY2F0KE5PREVfVkVSU0lPTiwgXCIgKHY4IFwiKS5jb25jYXQoTk9ERV9WOF9WRVJTSU9OLCBcIilcIilcbiAgICB9O1xufVxuZXhwb3J0cy5mcm9tVmVyc2lvbiA9IGZyb21WZXJzaW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/node/bolt-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/node/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/bolt-agent/node/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./bolt-agent */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/node/bolt-agent.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2JvbHQtYWdlbnQvbm9kZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx1R0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2JvbHQtYWdlbnQvbm9kZS9pbmRleC5qcz9hZTUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JvbHQtYWdlbnRcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/node/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/bookmarks.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/bookmarks.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Bookmarks = void 0;\nvar util = __importStar(__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\"));\nvar BOOKMARKS_KEY = 'bookmarks';\nvar Bookmarks = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {string|string[]} values single bookmark as string or multiple bookmarks as a string array.\n     */\n    function Bookmarks(values) {\n        this._values = asStringArray(values);\n    }\n    Bookmarks.empty = function () {\n        return EMPTY_BOOKMARK;\n    };\n    /**\n     * Check if the given Bookmarks holder is meaningful and can be send to the database.\n     * @return {boolean} returns `true` bookmarks has a value, `false` otherwise.\n     */\n    Bookmarks.prototype.isEmpty = function () {\n        return this._values.length === 0;\n    };\n    /**\n     * Get all bookmarks values as an array.\n     * @return {string[]} all values.\n     */\n    Bookmarks.prototype.values = function () {\n        return this._values;\n    };\n    Bookmarks.prototype[Symbol.iterator] = function () {\n        return this._values[Symbol.iterator]();\n    };\n    /**\n     * Get these bookmarks as an object for begin transaction call.\n     * @return {Object} the value of this bookmarks holder as object.\n     */\n    Bookmarks.prototype.asBeginTransactionParameters = function () {\n        var _a;\n        if (this.isEmpty()) {\n            return {};\n        }\n        // Driver sends {bookmarks: \"max\", bookmarks: [\"one\", \"two\", \"max\"]} instead of simple\n        // {bookmarks: [\"one\", \"two\", \"max\"]} for backwards compatibility reasons. Old servers can only accept single\n        // bookmarks that is why driver has to parse and compare given list of bookmarks. This functionality will\n        // eventually be removed.\n        return _a = {},\n            _a[BOOKMARKS_KEY] = this._values,\n            _a;\n    };\n    return Bookmarks;\n}());\nexports.Bookmarks = Bookmarks;\nvar EMPTY_BOOKMARK = new Bookmarks(null);\n/**\n * Converts given value to an array.\n * @param {string|string[]|Array} [value=undefined] argument to convert.\n * @return {string[]} value converted to an array.\n */\nfunction asStringArray(value) {\n    if (value == null || value === '') {\n        return [];\n    }\n    if (util.isString(value)) {\n        return [value];\n    }\n    if (Array.isArray(value)) {\n        var result = new Set();\n        var flattenedValue = flattenArray(value);\n        for (var i = 0; i < flattenedValue.length; i++) {\n            var element = flattenedValue[i];\n            // if it is undefined or null, ignore it\n            if (element !== undefined && element !== null) {\n                if (!util.isString(element)) {\n                    throw new TypeError(\n                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                    \"Bookmark value should be a string, given: '\".concat(element, \"'\"));\n                }\n                result.add(element);\n            }\n        }\n        return __spreadArray([], __read(result), false);\n    }\n    throw new TypeError(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    \"Bookmarks should either be a string or a string array, given: '\".concat(value, \"'\"));\n}\n/**\n * Recursively flattens an array so that the result becomes a single array\n * of values, which does not include any sub-arrays\n *\n * @param {Array} value\n */\nfunction flattenArray(values) {\n    return values.reduce(function (dest, value) {\n        return Array.isArray(value)\n            ? dest.concat(flattenArray(value))\n            : dest.concat(value);\n    }, []);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2Jvb2ttYXJrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsd0JBQXdCLG1CQUFPLENBQUMsMkVBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQW9EO0FBQzdFLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvYm9va21hcmtzLmpzP2QxMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJvb2ttYXJrcyA9IHZvaWQgMDtcbnZhciB1dGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxcIikpO1xudmFyIEJPT0tNQVJLU19LRVkgPSAnYm9va21hcmtzJztcbnZhciBCb29rbWFya3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHZhbHVlcyBzaW5nbGUgYm9va21hcmsgYXMgc3RyaW5nIG9yIG11bHRpcGxlIGJvb2ttYXJrcyBhcyBhIHN0cmluZyBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb29rbWFya3ModmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFzU3RyaW5nQXJyYXkodmFsdWVzKTtcbiAgICB9XG4gICAgQm9va21hcmtzLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRU1QVFlfQk9PS01BUks7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gQm9va21hcmtzIGhvbGRlciBpcyBtZWFuaW5nZnVsIGFuZCBjYW4gYmUgc2VuZCB0byB0aGUgZGF0YWJhc2UuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gcmV0dXJucyBgdHJ1ZWAgYm9va21hcmtzIGhhcyBhIHZhbHVlLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBCb29rbWFya3MucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBib29rbWFya3MgdmFsdWVzIGFzIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSBhbGwgdmFsdWVzLlxuICAgICAqL1xuICAgIEJvb2ttYXJrcy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzO1xuICAgIH07XG4gICAgQm9va21hcmtzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGVzZSBib29rbWFya3MgYXMgYW4gb2JqZWN0IGZvciBiZWdpbiB0cmFuc2FjdGlvbiBjYWxsLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhlIHZhbHVlIG9mIHRoaXMgYm9va21hcmtzIGhvbGRlciBhcyBvYmplY3QuXG4gICAgICovXG4gICAgQm9va21hcmtzLnByb3RvdHlwZS5hc0JlZ2luVHJhbnNhY3Rpb25QYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIERyaXZlciBzZW5kcyB7Ym9va21hcmtzOiBcIm1heFwiLCBib29rbWFya3M6IFtcIm9uZVwiLCBcInR3b1wiLCBcIm1heFwiXX0gaW5zdGVhZCBvZiBzaW1wbGVcbiAgICAgICAgLy8ge2Jvb2ttYXJrczogW1wib25lXCIsIFwidHdvXCIsIFwibWF4XCJdfSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucy4gT2xkIHNlcnZlcnMgY2FuIG9ubHkgYWNjZXB0IHNpbmdsZVxuICAgICAgICAvLyBib29rbWFya3MgdGhhdCBpcyB3aHkgZHJpdmVyIGhhcyB0byBwYXJzZSBhbmQgY29tcGFyZSBnaXZlbiBsaXN0IG9mIGJvb2ttYXJrcy4gVGhpcyBmdW5jdGlvbmFsaXR5IHdpbGxcbiAgICAgICAgLy8gZXZlbnR1YWxseSBiZSByZW1vdmVkLlxuICAgICAgICByZXR1cm4gX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0JPT0tNQVJLU19LRVldID0gdGhpcy5fdmFsdWVzLFxuICAgICAgICAgICAgX2E7XG4gICAgfTtcbiAgICByZXR1cm4gQm9va21hcmtzO1xufSgpKTtcbmV4cG9ydHMuQm9va21hcmtzID0gQm9va21hcmtzO1xudmFyIEVNUFRZX0JPT0tNQVJLID0gbmV3IEJvb2ttYXJrcyhudWxsKTtcbi8qKlxuICogQ29udmVydHMgZ2l2ZW4gdmFsdWUgdG8gYW4gYXJyYXkuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXXxBcnJheX0gW3ZhbHVlPXVuZGVmaW5lZF0gYXJndW1lbnQgdG8gY29udmVydC5cbiAqIEByZXR1cm4ge3N0cmluZ1tdfSB2YWx1ZSBjb252ZXJ0ZWQgdG8gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzU3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgZmxhdHRlbmVkVmFsdWUgPSBmbGF0dGVuQXJyYXkodmFsdWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYXR0ZW5lZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGZsYXR0ZW5lZFZhbHVlW2ldO1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgdW5kZWZpbmVkIG9yIG51bGwsIGlnbm9yZSBpdFxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgXCJCb29rbWFyayB2YWx1ZSBzaG91bGQgYmUgYSBzdHJpbmcsIGdpdmVuOiAnXCIuY29uY2F0KGVsZW1lbnQsIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChyZXN1bHQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgIFwiQm9va21hcmtzIHNob3VsZCBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgYSBzdHJpbmcgYXJyYXksIGdpdmVuOiAnXCIuY29uY2F0KHZhbHVlLCBcIidcIikpO1xufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBmbGF0dGVucyBhbiBhcnJheSBzbyB0aGF0IHRoZSByZXN1bHQgYmVjb21lcyBhIHNpbmdsZSBhcnJheVxuICogb2YgdmFsdWVzLCB3aGljaCBkb2VzIG5vdCBpbmNsdWRlIGFueSBzdWItYXJyYXlzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkFycmF5KHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChkZXN0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgID8gZGVzdC5jb25jYXQoZmxhdHRlbkFycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIDogZGVzdC5jb25jYXQodmFsdWUpO1xuICAgIH0sIFtdKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/bookmarks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/connection-holder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/connection-holder.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EMPTY_CONNECTION_HOLDER = exports.ReadOnlyConnectionHolder = exports.ConnectionHolder = void 0;\nvar error_1 = __webpack_require__(/*! ../error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/constants.js\");\nvar bookmarks_1 = __webpack_require__(/*! ./bookmarks */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/bookmarks.js\");\nvar logger_1 = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/logger.js\");\n/**\n * Utility to lazily initialize connections and return them back to the pool when unused.\n * @private\n */\nvar ConnectionHolder = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {object} params\n     * @property {string} params.mode - the access mode for new connection holder.\n     * @property {string} params.database - the target database name.\n     * @property {Bookmarks} params.bookmarks - initial bookmarks\n     * @property {ConnectionProvider} params.connectionProvider - the connection provider to acquire connections from.\n     * @property {string?} params.impersonatedUser - the user which will be impersonated\n     * @property {function(databaseName:string)} params.onDatabaseNameResolved - callback called when the database name is resolved\n     * @property {function():Promise<Bookmarks>} params.getConnectionAcquistionBookmarks - called for getting Bookmarks for acquiring connections\n     * @property {AuthToken} params.auth - the target auth for the to-be-acquired connection\n     */\n    function ConnectionHolder(_a) {\n        var mode = _a.mode, _b = _a.database, database = _b === void 0 ? '' : _b, bookmarks = _a.bookmarks, connectionProvider = _a.connectionProvider, impersonatedUser = _a.impersonatedUser, onDatabaseNameResolved = _a.onDatabaseNameResolved, getConnectionAcquistionBookmarks = _a.getConnectionAcquistionBookmarks, auth = _a.auth, log = _a.log;\n        this._mode = mode !== null && mode !== void 0 ? mode : constants_1.ACCESS_MODE_WRITE;\n        this._closed = false;\n        this._database = database != null ? (0, util_1.assertString)(database, 'database') : '';\n        this._bookmarks = bookmarks !== null && bookmarks !== void 0 ? bookmarks : bookmarks_1.Bookmarks.empty();\n        this._connectionProvider = connectionProvider;\n        this._impersonatedUser = impersonatedUser;\n        this._referenceCount = 0;\n        this._connectionPromise = Promise.resolve(null);\n        this._onDatabaseNameResolved = onDatabaseNameResolved;\n        this._auth = auth;\n        this._log = log;\n        this._logError = this._logError.bind(this);\n        this._getConnectionAcquistionBookmarks = getConnectionAcquistionBookmarks !== null && getConnectionAcquistionBookmarks !== void 0 ? getConnectionAcquistionBookmarks : (function () { return Promise.resolve(bookmarks_1.Bookmarks.empty()); });\n    }\n    ConnectionHolder.prototype.mode = function () {\n        return this._mode;\n    };\n    ConnectionHolder.prototype.database = function () {\n        return this._database;\n    };\n    ConnectionHolder.prototype.setDatabase = function (database) {\n        this._database = database;\n    };\n    ConnectionHolder.prototype.bookmarks = function () {\n        return this._bookmarks;\n    };\n    ConnectionHolder.prototype.connectionProvider = function () {\n        return this._connectionProvider;\n    };\n    ConnectionHolder.prototype.referenceCount = function () {\n        return this._referenceCount;\n    };\n    ConnectionHolder.prototype.initializeConnection = function (homeDatabase) {\n        if (this._referenceCount === 0 && (this._connectionProvider != null)) {\n            this._connectionPromise = this._createConnectionPromise(this._connectionProvider, homeDatabase);\n        }\n        else {\n            this._referenceCount++;\n            return false;\n        }\n        this._referenceCount++;\n        return true;\n    };\n    ConnectionHolder.prototype._createConnectionPromise = function (connectionProvider, homeDatabase) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, _b;\n            var _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _b = (_a = connectionProvider).acquireConnection;\n                        _c = {\n                            accessMode: this._mode,\n                            database: this._database\n                        };\n                        return [4 /*yield*/, this._getBookmarks()];\n                    case 1: return [4 /*yield*/, _b.apply(_a, [(_c.bookmarks = _d.sent(),\n                                _c.impersonatedUser = this._impersonatedUser,\n                                _c.onDatabaseNameResolved = this._onDatabaseNameResolved,\n                                _c.auth = this._auth,\n                                _c.homeDb = homeDatabase,\n                                _c)])];\n                    case 2: return [2 /*return*/, _d.sent()];\n                }\n            });\n        });\n    };\n    ConnectionHolder.prototype._getBookmarks = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._getConnectionAcquistionBookmarks()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    ConnectionHolder.prototype.getConnection = function () {\n        return this._connectionPromise;\n    };\n    ConnectionHolder.prototype.releaseConnection = function () {\n        if (this._referenceCount === 0) {\n            return this._connectionPromise;\n        }\n        this._referenceCount--;\n        if (this._referenceCount === 0) {\n            return this._releaseConnection();\n        }\n        return this._connectionPromise;\n    };\n    ConnectionHolder.prototype.close = function (hasTx) {\n        this._closed = true;\n        if (this._referenceCount === 0) {\n            return this._connectionPromise;\n        }\n        this._referenceCount = 0;\n        return this._releaseConnection(hasTx);\n    };\n    ConnectionHolder.prototype.log = function () {\n        return this._log;\n    };\n    /**\n     * Return the current pooled connection instance to the connection pool.\n     * We don't pool Session instances, to avoid users using the Session after they've called close.\n     * The `Session` object is just a thin wrapper around Connection anyway, so it makes little difference.\n     * @return {Promise} - promise resolved then connection is returned to the pool.\n     * @private\n     */\n    ConnectionHolder.prototype._releaseConnection = function (hasTx) {\n        this._connectionPromise = this._connectionPromise\n            .then(function (connection) {\n            if (connection != null) {\n                if (connection.isOpen() && (connection.hasOngoingObservableRequests() || hasTx === true)) {\n                    return connection\n                        .resetAndFlush()\n                        .catch(ignoreError)\n                        .then(function () { return connection.release().then(function () { return null; }); });\n                }\n                return connection.release().then(function () { return null; });\n            }\n            else {\n                return Promise.resolve(null);\n            }\n        })\n            .catch(this._logError);\n        return this._connectionPromise;\n    };\n    ConnectionHolder.prototype._logError = function (error) {\n        if (this._log.isWarnEnabled()) {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            this._log.warn(\"ConnectionHolder got an error while releasing the connection. Error \".concat(error, \". Stacktrace: \").concat(error.stack));\n        }\n        return null;\n    };\n    return ConnectionHolder;\n}());\nexports.ConnectionHolder = ConnectionHolder;\n/**\n * Provides a interaction with a ConnectionHolder without change it state by\n * releasing or initilizing\n */\nvar ReadOnlyConnectionHolder = /** @class */ (function (_super) {\n    __extends(ReadOnlyConnectionHolder, _super);\n    /**\n     * Constructor\n     * @param {ConnectionHolder} connectionHolder the connection holder which will treat the requests\n     */\n    function ReadOnlyConnectionHolder(connectionHolder) {\n        var _this = _super.call(this, {\n            mode: connectionHolder.mode(),\n            database: connectionHolder.database(),\n            bookmarks: connectionHolder.bookmarks(),\n            // @ts-expect-error\n            getConnectionAcquistionBookmarks: connectionHolder._getConnectionAcquistionBookmarks,\n            connectionProvider: connectionHolder.connectionProvider(),\n            log: connectionHolder.log()\n        }) || this;\n        _this._connectionHolder = connectionHolder;\n        return _this;\n    }\n    /**\n     * Return the true if the connection is suppose to be initilized with the command.\n     *\n     * @return {boolean}\n     */\n    ReadOnlyConnectionHolder.prototype.initializeConnection = function () {\n        if (this._connectionHolder.referenceCount() === 0) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Get the current connection promise.\n     * @return {Promise<Connection>} promise resolved with the current connection.\n     */\n    ReadOnlyConnectionHolder.prototype.getConnection = function () {\n        return this._connectionHolder.getConnection();\n    };\n    /**\n     * Get the current connection promise, doesn't performs the release\n     * @return {Promise<Connection>} promise with the resolved current connection\n     */\n    ReadOnlyConnectionHolder.prototype.releaseConnection = function () {\n        return this._connectionHolder.getConnection().catch(function () { return Promise.resolve(null); });\n    };\n    /**\n     * Get the current connection promise, doesn't performs the connection close\n     * @return {Promise<Connection>} promise with the resolved current connection\n     */\n    ReadOnlyConnectionHolder.prototype.close = function () {\n        return this._connectionHolder.getConnection().catch(function () { return Promise.resolve(null); });\n    };\n    return ReadOnlyConnectionHolder;\n}(ConnectionHolder));\nexports.ReadOnlyConnectionHolder = ReadOnlyConnectionHolder;\nexports[\"default\"] = ReadOnlyConnectionHolder;\nvar EmptyConnectionHolder = /** @class */ (function (_super) {\n    __extends(EmptyConnectionHolder, _super);\n    function EmptyConnectionHolder() {\n        return _super.call(this, {\n            // Empty logger\n            log: logger_1.Logger.create({})\n        }) || this;\n    }\n    EmptyConnectionHolder.prototype.mode = function () {\n        return undefined;\n    };\n    EmptyConnectionHolder.prototype.database = function () {\n        return undefined;\n    };\n    EmptyConnectionHolder.prototype.initializeConnection = function () {\n        // nothing to initialize\n        return true;\n    };\n    EmptyConnectionHolder.prototype.getConnection = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.reject((0, error_1.newError)('This connection holder does not serve connections'))];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    EmptyConnectionHolder.prototype.releaseConnection = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.resolve(null)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    EmptyConnectionHolder.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.resolve(null)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    return EmptyConnectionHolder;\n}(ConnectionHolder));\n/**\n * Connection holder that does not manage any connections.\n * @type {ConnectionHolder}\n * @private\n */\nvar EMPTY_CONNECTION_HOLDER = new EmptyConnectionHolder();\nexports.EMPTY_CONNECTION_HOLDER = EMPTY_CONNECTION_HOLDER;\n// eslint-disable-next-line n/handle-callback-err\nfunction ignoreError(error) {\n    return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2Nvbm5lY3Rpb24taG9sZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcsZ0NBQWdDLEdBQUcsd0JBQXdCO0FBQzdGLGNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlcm5hbC9jb25uZWN0aW9uLWhvbGRlci5qcz9iNTg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FTVBUWV9DT05ORUNUSU9OX0hPTERFUiA9IGV4cG9ydHMuUmVhZE9ubHlDb25uZWN0aW9uSG9sZGVyID0gZXhwb3J0cy5Db25uZWN0aW9uSG9sZGVyID0gdm9pZCAwO1xudmFyIGVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBib29rbWFya3NfMSA9IHJlcXVpcmUoXCIuL2Jvb2ttYXJrc1wiKTtcbnZhciBsb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZ2dlclwiKTtcbi8qKlxuICogVXRpbGl0eSB0byBsYXppbHkgaW5pdGlhbGl6ZSBjb25uZWN0aW9ucyBhbmQgcmV0dXJuIHRoZW0gYmFjayB0byB0aGUgcG9vbCB3aGVuIHVudXNlZC5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBDb25uZWN0aW9uSG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcGFyYW1zLm1vZGUgLSB0aGUgYWNjZXNzIG1vZGUgZm9yIG5ldyBjb25uZWN0aW9uIGhvbGRlci5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcGFyYW1zLmRhdGFiYXNlIC0gdGhlIHRhcmdldCBkYXRhYmFzZSBuYW1lLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9va21hcmtzfSBwYXJhbXMuYm9va21hcmtzIC0gaW5pdGlhbCBib29rbWFya3NcbiAgICAgKiBAcHJvcGVydHkge0Nvbm5lY3Rpb25Qcm92aWRlcn0gcGFyYW1zLmNvbm5lY3Rpb25Qcm92aWRlciAtIHRoZSBjb25uZWN0aW9uIHByb3ZpZGVyIHRvIGFjcXVpcmUgY29ubmVjdGlvbnMgZnJvbS5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZz99IHBhcmFtcy5pbXBlcnNvbmF0ZWRVc2VyIC0gdGhlIHVzZXIgd2hpY2ggd2lsbCBiZSBpbXBlcnNvbmF0ZWRcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9uKGRhdGFiYXNlTmFtZTpzdHJpbmcpfSBwYXJhbXMub25EYXRhYmFzZU5hbWVSZXNvbHZlZCAtIGNhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBkYXRhYmFzZSBuYW1lIGlzIHJlc29sdmVkXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbigpOlByb21pc2U8Qm9va21hcmtzPn0gcGFyYW1zLmdldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzIC0gY2FsbGVkIGZvciBnZXR0aW5nIEJvb2ttYXJrcyBmb3IgYWNxdWlyaW5nIGNvbm5lY3Rpb25zXG4gICAgICogQHByb3BlcnR5IHtBdXRoVG9rZW59IHBhcmFtcy5hdXRoIC0gdGhlIHRhcmdldCBhdXRoIGZvciB0aGUgdG8tYmUtYWNxdWlyZWQgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25Ib2xkZXIoX2EpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBfYS5tb2RlLCBfYiA9IF9hLmRhdGFiYXNlLCBkYXRhYmFzZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iLCBib29rbWFya3MgPSBfYS5ib29rbWFya3MsIGNvbm5lY3Rpb25Qcm92aWRlciA9IF9hLmNvbm5lY3Rpb25Qcm92aWRlciwgaW1wZXJzb25hdGVkVXNlciA9IF9hLmltcGVyc29uYXRlZFVzZXIsIG9uRGF0YWJhc2VOYW1lUmVzb2x2ZWQgPSBfYS5vbkRhdGFiYXNlTmFtZVJlc29sdmVkLCBnZXRDb25uZWN0aW9uQWNxdWlzdGlvbkJvb2ttYXJrcyA9IF9hLmdldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzLCBhdXRoID0gX2EuYXV0aCwgbG9nID0gX2EubG9nO1xuICAgICAgICB0aGlzLl9tb2RlID0gbW9kZSAhPT0gbnVsbCAmJiBtb2RlICE9PSB2b2lkIDAgPyBtb2RlIDogY29uc3RhbnRzXzEuQUNDRVNTX01PREVfV1JJVEU7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kYXRhYmFzZSA9IGRhdGFiYXNlICE9IG51bGwgPyAoMCwgdXRpbF8xLmFzc2VydFN0cmluZykoZGF0YWJhc2UsICdkYXRhYmFzZScpIDogJyc7XG4gICAgICAgIHRoaXMuX2Jvb2ttYXJrcyA9IGJvb2ttYXJrcyAhPT0gbnVsbCAmJiBib29rbWFya3MgIT09IHZvaWQgMCA/IGJvb2ttYXJrcyA6IGJvb2ttYXJrc18xLkJvb2ttYXJrcy5lbXB0eSgpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIgPSBjb25uZWN0aW9uUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuX2ltcGVyc29uYXRlZFVzZXIgPSBpbXBlcnNvbmF0ZWRVc2VyO1xuICAgICAgICB0aGlzLl9yZWZlcmVuY2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB0aGlzLl9vbkRhdGFiYXNlTmFtZVJlc29sdmVkID0gb25EYXRhYmFzZU5hbWVSZXNvbHZlZDtcbiAgICAgICAgdGhpcy5fYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMuX2xvZyA9IGxvZztcbiAgICAgICAgdGhpcy5fbG9nRXJyb3IgPSB0aGlzLl9sb2dFcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9nZXRDb25uZWN0aW9uQWNxdWlzdGlvbkJvb2ttYXJrcyA9IGdldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzICE9PSBudWxsICYmIGdldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzICE9PSB2b2lkIDAgPyBnZXRDb25uZWN0aW9uQWNxdWlzdGlvbkJvb2ttYXJrcyA6IChmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoYm9va21hcmtzXzEuQm9va21hcmtzLmVtcHR5KCkpOyB9KTtcbiAgICB9XG4gICAgQ29ubmVjdGlvbkhvbGRlci5wcm90b3R5cGUubW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uSG9sZGVyLnByb3RvdHlwZS5kYXRhYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFiYXNlO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbkhvbGRlci5wcm90b3R5cGUuc2V0RGF0YWJhc2UgPSBmdW5jdGlvbiAoZGF0YWJhc2UpIHtcbiAgICAgICAgdGhpcy5fZGF0YWJhc2UgPSBkYXRhYmFzZTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLmJvb2ttYXJrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jvb2ttYXJrcztcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLmNvbm5lY3Rpb25Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qcm92aWRlcjtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLnJlZmVyZW5jZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlQ291bnQ7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uSG9sZGVyLnByb3RvdHlwZS5pbml0aWFsaXplQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChob21lRGF0YWJhc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlZmVyZW5jZUNvdW50ID09PSAwICYmICh0aGlzLl9jb25uZWN0aW9uUHJvdmlkZXIgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5fY3JlYXRlQ29ubmVjdGlvblByb21pc2UodGhpcy5fY29ubmVjdGlvblByb3ZpZGVyLCBob21lRGF0YWJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVmZXJlbmNlQ291bnQrKztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWZlcmVuY2VDb3VudCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLl9jcmVhdGVDb25uZWN0aW9uUHJvbWlzZSA9IGZ1bmN0aW9uIChjb25uZWN0aW9uUHJvdmlkZXIsIGhvbWVEYXRhYmFzZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIF9jO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBjb25uZWN0aW9uUHJvdmlkZXIpLmFjcXVpcmVDb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzTW9kZTogdGhpcy5fbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZTogdGhpcy5fZGF0YWJhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRCb29rbWFya3MoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2IuYXBwbHkoX2EsIFsoX2MuYm9va21hcmtzID0gX2Quc2VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5pbXBlcnNvbmF0ZWRVc2VyID0gdGhpcy5faW1wZXJzb25hdGVkVXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Mub25EYXRhYmFzZU5hbWVSZXNvbHZlZCA9IHRoaXMuX29uRGF0YWJhc2VOYW1lUmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmF1dGggPSB0aGlzLl9hdXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5ob21lRGIgPSBob21lRGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKV0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Quc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uSG9sZGVyLnByb3RvdHlwZS5fZ2V0Qm9va21hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLnJlbGVhc2VDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVmZXJlbmNlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWZlcmVuY2VDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5fcmVmZXJlbmNlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxlYXNlQ29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGhhc1R4KSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9yZWZlcmVuY2VDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZmVyZW5jZUNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2VDb25uZWN0aW9uKGhhc1R4KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCBwb29sZWQgY29ubmVjdGlvbiBpbnN0YW5jZSB0byB0aGUgY29ubmVjdGlvbiBwb29sLlxuICAgICAqIFdlIGRvbid0IHBvb2wgU2Vzc2lvbiBpbnN0YW5jZXMsIHRvIGF2b2lkIHVzZXJzIHVzaW5nIHRoZSBTZXNzaW9uIGFmdGVyIHRoZXkndmUgY2FsbGVkIGNsb3NlLlxuICAgICAqIFRoZSBgU2Vzc2lvbmAgb2JqZWN0IGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgYXJvdW5kIENvbm5lY3Rpb24gYW55d2F5LCBzbyBpdCBtYWtlcyBsaXR0bGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHByb21pc2UgcmVzb2x2ZWQgdGhlbiBjb25uZWN0aW9uIGlzIHJldHVybmVkIHRvIHRoZSBwb29sLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbkhvbGRlci5wcm90b3R5cGUuX3JlbGVhc2VDb25uZWN0aW9uID0gZnVuY3Rpb24gKGhhc1R4KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5fY29ubmVjdGlvblByb21pc2VcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uaXNPcGVuKCkgJiYgKGNvbm5lY3Rpb24uaGFzT25nb2luZ09ic2VydmFibGVSZXF1ZXN0cygpIHx8IGhhc1R4ID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlc2V0QW5kRmx1c2goKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGlnbm9yZUVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbi5yZWxlYXNlKCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnJlbGVhc2UoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCh0aGlzLl9sb2dFcnJvcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLl9sb2dFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5fbG9nLmlzV2FybkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJDb25uZWN0aW9uSG9sZGVyIGdvdCBhbiBlcnJvciB3aGlsZSByZWxlYXNpbmcgdGhlIGNvbm5lY3Rpb24uIEVycm9yIFwiLmNvbmNhdChlcnJvciwgXCIuIFN0YWNrdHJhY2U6IFwiKS5jb25jYXQoZXJyb3Iuc3RhY2spKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0aW9uSG9sZGVyO1xufSgpKTtcbmV4cG9ydHMuQ29ubmVjdGlvbkhvbGRlciA9IENvbm5lY3Rpb25Ib2xkZXI7XG4vKipcbiAqIFByb3ZpZGVzIGEgaW50ZXJhY3Rpb24gd2l0aCBhIENvbm5lY3Rpb25Ib2xkZXIgd2l0aG91dCBjaGFuZ2UgaXQgc3RhdGUgYnlcbiAqIHJlbGVhc2luZyBvciBpbml0aWxpemluZ1xuICovXG52YXIgUmVhZE9ubHlDb25uZWN0aW9uSG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkT25seUNvbm5lY3Rpb25Ib2xkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25Ib2xkZXJ9IGNvbm5lY3Rpb25Ib2xkZXIgdGhlIGNvbm5lY3Rpb24gaG9sZGVyIHdoaWNoIHdpbGwgdHJlYXQgdGhlIHJlcXVlc3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVhZE9ubHlDb25uZWN0aW9uSG9sZGVyKGNvbm5lY3Rpb25Ib2xkZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgbW9kZTogY29ubmVjdGlvbkhvbGRlci5tb2RlKCksXG4gICAgICAgICAgICBkYXRhYmFzZTogY29ubmVjdGlvbkhvbGRlci5kYXRhYmFzZSgpLFxuICAgICAgICAgICAgYm9va21hcmtzOiBjb25uZWN0aW9uSG9sZGVyLmJvb2ttYXJrcygpLFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgZ2V0Q29ubmVjdGlvbkFjcXVpc3Rpb25Cb29rbWFya3M6IGNvbm5lY3Rpb25Ib2xkZXIuX2dldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzLFxuICAgICAgICAgICAgY29ubmVjdGlvblByb3ZpZGVyOiBjb25uZWN0aW9uSG9sZGVyLmNvbm5lY3Rpb25Qcm92aWRlcigpLFxuICAgICAgICAgICAgbG9nOiBjb25uZWN0aW9uSG9sZGVyLmxvZygpXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jb25uZWN0aW9uSG9sZGVyID0gY29ubmVjdGlvbkhvbGRlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHRydWUgaWYgdGhlIGNvbm5lY3Rpb24gaXMgc3VwcG9zZSB0byBiZSBpbml0aWxpemVkIHdpdGggdGhlIGNvbW1hbmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFJlYWRPbmx5Q29ubmVjdGlvbkhvbGRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uSG9sZGVyLnJlZmVyZW5jZUNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb25uZWN0aW9uIHByb21pc2UuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxDb25uZWN0aW9uPn0gcHJvbWlzZSByZXNvbHZlZCB3aXRoIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgUmVhZE9ubHlDb25uZWN0aW9uSG9sZGVyLnByb3RvdHlwZS5nZXRDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbkhvbGRlci5nZXRDb25uZWN0aW9uKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBwcm9taXNlLCBkb2Vzbid0IHBlcmZvcm1zIHRoZSByZWxlYXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxDb25uZWN0aW9uPn0gcHJvbWlzZSB3aXRoIHRoZSByZXNvbHZlZCBjdXJyZW50IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBSZWFkT25seUNvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLnJlbGVhc2VDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbkhvbGRlci5nZXRDb25uZWN0aW9uKCkuY2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb25uZWN0aW9uIHByb21pc2UsIGRvZXNuJ3QgcGVyZm9ybXMgdGhlIGNvbm5lY3Rpb24gY2xvc2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbm5lY3Rpb24+fSBwcm9taXNlIHdpdGggdGhlIHJlc29sdmVkIGN1cnJlbnQgY29ubmVjdGlvblxuICAgICAqL1xuICAgIFJlYWRPbmx5Q29ubmVjdGlvbkhvbGRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uSG9sZGVyLmdldENvbm5lY3Rpb24oKS5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRPbmx5Q29ubmVjdGlvbkhvbGRlcjtcbn0oQ29ubmVjdGlvbkhvbGRlcikpO1xuZXhwb3J0cy5SZWFkT25seUNvbm5lY3Rpb25Ib2xkZXIgPSBSZWFkT25seUNvbm5lY3Rpb25Ib2xkZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWFkT25seUNvbm5lY3Rpb25Ib2xkZXI7XG52YXIgRW1wdHlDb25uZWN0aW9uSG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eUNvbm5lY3Rpb25Ib2xkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlDb25uZWN0aW9uSG9sZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgLy8gRW1wdHkgbG9nZ2VyXG4gICAgICAgICAgICBsb2c6IGxvZ2dlcl8xLkxvZ2dlci5jcmVhdGUoe30pXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgfVxuICAgIEVtcHR5Q29ubmVjdGlvbkhvbGRlci5wcm90b3R5cGUubW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEVtcHR5Q29ubmVjdGlvbkhvbGRlci5wcm90b3R5cGUuZGF0YWJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBFbXB0eUNvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLmluaXRpYWxpemVDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGluaXRpYWxpemVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBFbXB0eUNvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLmdldENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZWplY3QoKDAsIGVycm9yXzEubmV3RXJyb3IpKCdUaGlzIGNvbm5lY3Rpb24gaG9sZGVyIGRvZXMgbm90IHNlcnZlIGNvbm5lY3Rpb25zJykpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbXB0eUNvbm5lY3Rpb25Ib2xkZXIucHJvdG90eXBlLnJlbGVhc2VDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZShudWxsKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRW1wdHlDb25uZWN0aW9uSG9sZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLnJlc29sdmUobnVsbCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFbXB0eUNvbm5lY3Rpb25Ib2xkZXI7XG59KENvbm5lY3Rpb25Ib2xkZXIpKTtcbi8qKlxuICogQ29ubmVjdGlvbiBob2xkZXIgdGhhdCBkb2VzIG5vdCBtYW5hZ2UgYW55IGNvbm5lY3Rpb25zLlxuICogQHR5cGUge0Nvbm5lY3Rpb25Ib2xkZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgRU1QVFlfQ09OTkVDVElPTl9IT0xERVIgPSBuZXcgRW1wdHlDb25uZWN0aW9uSG9sZGVyKCk7XG5leHBvcnRzLkVNUFRZX0NPTk5FQ1RJT05fSE9MREVSID0gRU1QVFlfQ09OTkVDVElPTl9IT0xERVI7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbi9oYW5kbGUtY2FsbGJhY2stZXJyXG5mdW5jdGlvbiBpZ25vcmVFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/connection-holder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/constants.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/constants.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TELEMETRY_APIS = exports.BOLT_PROTOCOL_V5_8 = exports.BOLT_PROTOCOL_V5_7 = exports.BOLT_PROTOCOL_V5_6 = exports.BOLT_PROTOCOL_V5_5 = exports.BOLT_PROTOCOL_V5_4 = exports.BOLT_PROTOCOL_V5_3 = exports.BOLT_PROTOCOL_V5_2 = exports.BOLT_PROTOCOL_V5_1 = exports.BOLT_PROTOCOL_V5_0 = exports.BOLT_PROTOCOL_V4_4 = exports.BOLT_PROTOCOL_V4_3 = exports.BOLT_PROTOCOL_V4_2 = exports.BOLT_PROTOCOL_V4_1 = exports.BOLT_PROTOCOL_V4_0 = exports.BOLT_PROTOCOL_V3 = exports.BOLT_PROTOCOL_V2 = exports.BOLT_PROTOCOL_V1 = exports.DEFAULT_POOL_MAX_SIZE = exports.DEFAULT_POOL_ACQUISITION_TIMEOUT = exports.DEFAULT_CONNECTION_TIMEOUT_MILLIS = exports.ACCESS_MODE_WRITE = exports.ACCESS_MODE_READ = exports.FETCH_ALL = void 0;\nvar FETCH_ALL = -1;\nexports.FETCH_ALL = FETCH_ALL;\nvar DEFAULT_POOL_ACQUISITION_TIMEOUT = 60 * 1000; // 60 seconds\nexports.DEFAULT_POOL_ACQUISITION_TIMEOUT = DEFAULT_POOL_ACQUISITION_TIMEOUT;\nvar DEFAULT_POOL_MAX_SIZE = 100;\nexports.DEFAULT_POOL_MAX_SIZE = DEFAULT_POOL_MAX_SIZE;\nvar DEFAULT_CONNECTION_TIMEOUT_MILLIS = 30000; // 30 seconds by default\nexports.DEFAULT_CONNECTION_TIMEOUT_MILLIS = DEFAULT_CONNECTION_TIMEOUT_MILLIS;\nvar ACCESS_MODE_READ = 'READ';\nexports.ACCESS_MODE_READ = ACCESS_MODE_READ;\nvar ACCESS_MODE_WRITE = 'WRITE';\nexports.ACCESS_MODE_WRITE = ACCESS_MODE_WRITE;\nvar BOLT_PROTOCOL_V1 = 1;\nexports.BOLT_PROTOCOL_V1 = BOLT_PROTOCOL_V1;\nvar BOLT_PROTOCOL_V2 = 2;\nexports.BOLT_PROTOCOL_V2 = BOLT_PROTOCOL_V2;\nvar BOLT_PROTOCOL_V3 = 3;\nexports.BOLT_PROTOCOL_V3 = BOLT_PROTOCOL_V3;\nvar BOLT_PROTOCOL_V4_0 = 4.0;\nexports.BOLT_PROTOCOL_V4_0 = BOLT_PROTOCOL_V4_0;\nvar BOLT_PROTOCOL_V4_1 = 4.1;\nexports.BOLT_PROTOCOL_V4_1 = BOLT_PROTOCOL_V4_1;\nvar BOLT_PROTOCOL_V4_2 = 4.2;\nexports.BOLT_PROTOCOL_V4_2 = BOLT_PROTOCOL_V4_2;\nvar BOLT_PROTOCOL_V4_3 = 4.3;\nexports.BOLT_PROTOCOL_V4_3 = BOLT_PROTOCOL_V4_3;\nvar BOLT_PROTOCOL_V4_4 = 4.4;\nexports.BOLT_PROTOCOL_V4_4 = BOLT_PROTOCOL_V4_4;\nvar BOLT_PROTOCOL_V5_0 = 5.0;\nexports.BOLT_PROTOCOL_V5_0 = BOLT_PROTOCOL_V5_0;\nvar BOLT_PROTOCOL_V5_1 = 5.1;\nexports.BOLT_PROTOCOL_V5_1 = BOLT_PROTOCOL_V5_1;\nvar BOLT_PROTOCOL_V5_2 = 5.2;\nexports.BOLT_PROTOCOL_V5_2 = BOLT_PROTOCOL_V5_2;\nvar BOLT_PROTOCOL_V5_3 = 5.3;\nexports.BOLT_PROTOCOL_V5_3 = BOLT_PROTOCOL_V5_3;\nvar BOLT_PROTOCOL_V5_4 = 5.4;\nexports.BOLT_PROTOCOL_V5_4 = BOLT_PROTOCOL_V5_4;\nvar BOLT_PROTOCOL_V5_5 = 5.5;\nexports.BOLT_PROTOCOL_V5_5 = BOLT_PROTOCOL_V5_5;\nvar BOLT_PROTOCOL_V5_6 = 5.6;\nexports.BOLT_PROTOCOL_V5_6 = BOLT_PROTOCOL_V5_6;\nvar BOLT_PROTOCOL_V5_7 = 5.7;\nexports.BOLT_PROTOCOL_V5_7 = BOLT_PROTOCOL_V5_7;\nvar BOLT_PROTOCOL_V5_8 = 5.8;\nexports.BOLT_PROTOCOL_V5_8 = BOLT_PROTOCOL_V5_8;\nvar TELEMETRY_APIS = {\n    MANAGED_TRANSACTION: 0,\n    UNMANAGED_TRANSACTION: 1,\n    AUTO_COMMIT_TRANSACTION: 2,\n    EXECUTE_QUERY: 3\n};\nexports.TELEMETRY_APIS = TELEMETRY_APIS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLDZCQUE2QixHQUFHLHdDQUF3QyxHQUFHLHlDQUF5QyxHQUFHLHlCQUF5QixHQUFHLHdCQUF3QixHQUFHLGlCQUFpQjtBQUMvckI7QUFDQSxpQkFBaUI7QUFDakIsa0RBQWtEO0FBQ2xELHdDQUF3QztBQUN4QztBQUNBLDZCQUE2QjtBQUM3QiwrQ0FBK0M7QUFDL0MseUNBQXlDO0FBQ3pDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2NvbnN0YW50cy5qcz9kNzdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVEVMRU1FVFJZX0FQSVMgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfOCA9IGV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WNV83ID0gZXhwb3J0cy5CT0xUX1BST1RPQ09MX1Y1XzYgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfNSA9IGV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WNV80ID0gZXhwb3J0cy5CT0xUX1BST1RPQ09MX1Y1XzMgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfMiA9IGV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WNV8xID0gZXhwb3J0cy5CT0xUX1BST1RPQ09MX1Y1XzAgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfNCA9IGV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WNF8zID0gZXhwb3J0cy5CT0xUX1BST1RPQ09MX1Y0XzIgPSBleHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfMSA9IGV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WNF8wID0gZXhwb3J0cy5CT0xUX1BST1RPQ09MX1YzID0gZXhwb3J0cy5CT0xUX1BST1RPQ09MX1YyID0gZXhwb3J0cy5CT0xUX1BST1RPQ09MX1YxID0gZXhwb3J0cy5ERUZBVUxUX1BPT0xfTUFYX1NJWkUgPSBleHBvcnRzLkRFRkFVTFRfUE9PTF9BQ1FVSVNJVElPTl9USU1FT1VUID0gZXhwb3J0cy5ERUZBVUxUX0NPTk5FQ1RJT05fVElNRU9VVF9NSUxMSVMgPSBleHBvcnRzLkFDQ0VTU19NT0RFX1dSSVRFID0gZXhwb3J0cy5BQ0NFU1NfTU9ERV9SRUFEID0gZXhwb3J0cy5GRVRDSF9BTEwgPSB2b2lkIDA7XG52YXIgRkVUQ0hfQUxMID0gLTE7XG5leHBvcnRzLkZFVENIX0FMTCA9IEZFVENIX0FMTDtcbnZhciBERUZBVUxUX1BPT0xfQUNRVUlTSVRJT05fVElNRU9VVCA9IDYwICogMTAwMDsgLy8gNjAgc2Vjb25kc1xuZXhwb3J0cy5ERUZBVUxUX1BPT0xfQUNRVUlTSVRJT05fVElNRU9VVCA9IERFRkFVTFRfUE9PTF9BQ1FVSVNJVElPTl9USU1FT1VUO1xudmFyIERFRkFVTFRfUE9PTF9NQVhfU0laRSA9IDEwMDtcbmV4cG9ydHMuREVGQVVMVF9QT09MX01BWF9TSVpFID0gREVGQVVMVF9QT09MX01BWF9TSVpFO1xudmFyIERFRkFVTFRfQ09OTkVDVElPTl9USU1FT1VUX01JTExJUyA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzIGJ5IGRlZmF1bHRcbmV4cG9ydHMuREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVRfTUlMTElTID0gREVGQVVMVF9DT05ORUNUSU9OX1RJTUVPVVRfTUlMTElTO1xudmFyIEFDQ0VTU19NT0RFX1JFQUQgPSAnUkVBRCc7XG5leHBvcnRzLkFDQ0VTU19NT0RFX1JFQUQgPSBBQ0NFU1NfTU9ERV9SRUFEO1xudmFyIEFDQ0VTU19NT0RFX1dSSVRFID0gJ1dSSVRFJztcbmV4cG9ydHMuQUNDRVNTX01PREVfV1JJVEUgPSBBQ0NFU1NfTU9ERV9XUklURTtcbnZhciBCT0xUX1BST1RPQ09MX1YxID0gMTtcbmV4cG9ydHMuQk9MVF9QUk9UT0NPTF9WMSA9IEJPTFRfUFJPVE9DT0xfVjE7XG52YXIgQk9MVF9QUk9UT0NPTF9WMiA9IDI7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjIgPSBCT0xUX1BST1RPQ09MX1YyO1xudmFyIEJPTFRfUFJPVE9DT0xfVjMgPSAzO1xuZXhwb3J0cy5CT0xUX1BST1RPQ09MX1YzID0gQk9MVF9QUk9UT0NPTF9WMztcbnZhciBCT0xUX1BST1RPQ09MX1Y0XzAgPSA0LjA7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfMCA9IEJPTFRfUFJPVE9DT0xfVjRfMDtcbnZhciBCT0xUX1BST1RPQ09MX1Y0XzEgPSA0LjE7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfMSA9IEJPTFRfUFJPVE9DT0xfVjRfMTtcbnZhciBCT0xUX1BST1RPQ09MX1Y0XzIgPSA0LjI7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfMiA9IEJPTFRfUFJPVE9DT0xfVjRfMjtcbnZhciBCT0xUX1BST1RPQ09MX1Y0XzMgPSA0LjM7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfMyA9IEJPTFRfUFJPVE9DT0xfVjRfMztcbnZhciBCT0xUX1BST1RPQ09MX1Y0XzQgPSA0LjQ7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjRfNCA9IEJPTFRfUFJPVE9DT0xfVjRfNDtcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzAgPSA1LjA7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfMCA9IEJPTFRfUFJPVE9DT0xfVjVfMDtcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzEgPSA1LjE7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfMSA9IEJPTFRfUFJPVE9DT0xfVjVfMTtcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzIgPSA1LjI7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfMiA9IEJPTFRfUFJPVE9DT0xfVjVfMjtcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzMgPSA1LjM7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfMyA9IEJPTFRfUFJPVE9DT0xfVjVfMztcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzQgPSA1LjQ7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfNCA9IEJPTFRfUFJPVE9DT0xfVjVfNDtcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzUgPSA1LjU7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfNSA9IEJPTFRfUFJPVE9DT0xfVjVfNTtcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzYgPSA1LjY7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfNiA9IEJPTFRfUFJPVE9DT0xfVjVfNjtcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzcgPSA1Ljc7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfNyA9IEJPTFRfUFJPVE9DT0xfVjVfNztcbnZhciBCT0xUX1BST1RPQ09MX1Y1XzggPSA1Ljg7XG5leHBvcnRzLkJPTFRfUFJPVE9DT0xfVjVfOCA9IEJPTFRfUFJPVE9DT0xfVjVfODtcbnZhciBURUxFTUVUUllfQVBJUyA9IHtcbiAgICBNQU5BR0VEX1RSQU5TQUNUSU9OOiAwLFxuICAgIFVOTUFOQUdFRF9UUkFOU0FDVElPTjogMSxcbiAgICBBVVRPX0NPTU1JVF9UUkFOU0FDVElPTjogMixcbiAgICBFWEVDVVRFX1FVRVJZOiAzXG59O1xuZXhwb3J0cy5URUxFTUVUUllfQVBJUyA9IFRFTEVNRVRSWV9BUElTO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/homedb-cache.js":
/*!*********************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/homedb-cache.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Cache which maps users to their last known home database, along with the last time the entry was accessed.\n *\n * @private\n */\nvar HomeDatabaseCache = /** @class */ (function () {\n    function HomeDatabaseCache(maxSize) {\n        this.maxSize = maxSize;\n        this.pruneCount = Math.max(Math.round(0.01 * maxSize * Math.log(maxSize)), 1);\n        this.map = new Map();\n    }\n    /**\n     * Updates or adds an entry to the cache, and prunes the cache if above the maximum allowed size\n     *\n     * @param {string} user cache key for the user to set\n     * @param {string} database new home database to set for the user\n     */\n    HomeDatabaseCache.prototype.set = function (user, database) {\n        this.map.set(user, { database: database, lastUsed: Date.now() });\n        this._pruneCache();\n    };\n    /**\n     * retrieves the last known home database for a user\n     *\n     * @param {string} user cache key for the user to get\n     */\n    HomeDatabaseCache.prototype.get = function (user) {\n        var value = this.map.get(user);\n        if (value !== undefined) {\n            value.lastUsed = Date.now();\n            return value.database;\n        }\n        return undefined;\n    };\n    /**\n     * removes the entry for a given user in the cache\n     *\n     * @param {string} user cache key for the user to remove\n     */\n    HomeDatabaseCache.prototype.delete = function (user) {\n        this.map.delete(user);\n    };\n    /**\n     * Removes a number of the oldest entries in the cache if the number of entries has exceeded the maximum size.\n     */\n    HomeDatabaseCache.prototype._pruneCache = function () {\n        if (this.map.size > this.maxSize) {\n            var sortedArray = Array.from(this.map.entries()).sort(function (a, b) { return a[1].lastUsed - b[1].lastUsed; });\n            for (var i = 0; i < this.pruneCount; i++) {\n                this.map.delete(sortedArray[i][0]);\n            }\n        }\n    };\n    return HomeDatabaseCache;\n}());\nexports[\"default\"] = HomeDatabaseCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2hvbWVkYi1jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSw2QkFBNkIsMENBQTBDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRix1Q0FBdUM7QUFDM0gsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvaG9tZWRiLWNhY2hlLmpzPzlhNDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBDYWNoZSB3aGljaCBtYXBzIHVzZXJzIHRvIHRoZWlyIGxhc3Qga25vd24gaG9tZSBkYXRhYmFzZSwgYWxvbmcgd2l0aCB0aGUgbGFzdCB0aW1lIHRoZSBlbnRyeSB3YXMgYWNjZXNzZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIEhvbWVEYXRhYmFzZUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhvbWVEYXRhYmFzZUNhY2hlKG1heFNpemUpIHtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5wcnVuZUNvdW50ID0gTWF0aC5tYXgoTWF0aC5yb3VuZCgwLjAxICogbWF4U2l6ZSAqIE1hdGgubG9nKG1heFNpemUpKSwgMSk7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIG9yIGFkZHMgYW4gZW50cnkgdG8gdGhlIGNhY2hlLCBhbmQgcHJ1bmVzIHRoZSBjYWNoZSBpZiBhYm92ZSB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyIGNhY2hlIGtleSBmb3IgdGhlIHVzZXIgdG8gc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFiYXNlIG5ldyBob21lIGRhdGFiYXNlIHRvIHNldCBmb3IgdGhlIHVzZXJcbiAgICAgKi9cbiAgICBIb21lRGF0YWJhc2VDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHVzZXIsIGRhdGFiYXNlKSB7XG4gICAgICAgIHRoaXMubWFwLnNldCh1c2VyLCB7IGRhdGFiYXNlOiBkYXRhYmFzZSwgbGFzdFVzZWQ6IERhdGUubm93KCkgfSk7XG4gICAgICAgIHRoaXMuX3BydW5lQ2FjaGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJldHJpZXZlcyB0aGUgbGFzdCBrbm93biBob21lIGRhdGFiYXNlIGZvciBhIHVzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyIGNhY2hlIGtleSBmb3IgdGhlIHVzZXIgdG8gZ2V0XG4gICAgICovXG4gICAgSG9tZURhdGFiYXNlQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubWFwLmdldCh1c2VyKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlLmxhc3RVc2VkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5kYXRhYmFzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVtb3ZlcyB0aGUgZW50cnkgZm9yIGEgZ2l2ZW4gdXNlciBpbiB0aGUgY2FjaGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyIGNhY2hlIGtleSBmb3IgdGhlIHVzZXIgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgSG9tZURhdGFiYXNlQ2FjaGUucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRoaXMubWFwLmRlbGV0ZSh1c2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBudW1iZXIgb2YgdGhlIG9sZGVzdCBlbnRyaWVzIGluIHRoZSBjYWNoZSBpZiB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaGFzIGV4Y2VlZGVkIHRoZSBtYXhpbXVtIHNpemUuXG4gICAgICovXG4gICAgSG9tZURhdGFiYXNlQ2FjaGUucHJvdG90eXBlLl9wcnVuZUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXAuc2l6ZSA+IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgdmFyIHNvcnRlZEFycmF5ID0gQXJyYXkuZnJvbSh0aGlzLm1hcC5lbnRyaWVzKCkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMV0ubGFzdFVzZWQgLSBiWzFdLmxhc3RVc2VkOyB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcnVuZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoc29ydGVkQXJyYXlbaV1bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSG9tZURhdGFiYXNlQ2FjaGU7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSG9tZURhdGFiYXNlQ2FjaGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/homedb-cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pool = exports.boltAgent = exports.objectUtil = exports.resolver = exports.serverAddress = exports.urlUtil = exports.logger = exports.transactionExecutor = exports.txConfig = exports.connectionHolder = exports.constants = exports.bookmarks = exports.observer = exports.temporalUtil = exports.util = void 0;\nvar util = __importStar(__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\"));\nexports.util = util;\nvar temporalUtil = __importStar(__webpack_require__(/*! ./temporal-util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/temporal-util.js\"));\nexports.temporalUtil = temporalUtil;\nvar observer = __importStar(__webpack_require__(/*! ./observers */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/observers.js\"));\nexports.observer = observer;\nvar bookmarks = __importStar(__webpack_require__(/*! ./bookmarks */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/bookmarks.js\"));\nexports.bookmarks = bookmarks;\nvar constants = __importStar(__webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/constants.js\"));\nexports.constants = constants;\nvar connectionHolder = __importStar(__webpack_require__(/*! ./connection-holder */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/connection-holder.js\"));\nexports.connectionHolder = connectionHolder;\nvar txConfig = __importStar(__webpack_require__(/*! ./tx-config */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/tx-config.js\"));\nexports.txConfig = txConfig;\nvar transactionExecutor = __importStar(__webpack_require__(/*! ./transaction-executor */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/transaction-executor.js\"));\nexports.transactionExecutor = transactionExecutor;\nvar logger = __importStar(__webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/logger.js\"));\nexports.logger = logger;\nvar urlUtil = __importStar(__webpack_require__(/*! ./url-util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/url-util.js\"));\nexports.urlUtil = urlUtil;\nvar serverAddress = __importStar(__webpack_require__(/*! ./server-address */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/server-address.js\"));\nexports.serverAddress = serverAddress;\nvar resolver = __importStar(__webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/index.js\"));\nexports.resolver = resolver;\nvar objectUtil = __importStar(__webpack_require__(/*! ./object-util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/object-util.js\"));\nexports.objectUtil = objectUtil;\nvar boltAgent = __importStar(__webpack_require__(/*! ./bolt-agent/index */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/bolt-agent/index.js\"));\nexports.boltAgent = boltAgent;\nvar pool = __importStar(__webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/index.js\"));\nexports.pool = pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxpQkFBaUIsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLDJCQUEyQixHQUFHLGdCQUFnQixHQUFHLHdCQUF3QixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLFlBQVk7QUFDaFQsd0JBQXdCLG1CQUFPLENBQUMsMkVBQVE7QUFDeEMsWUFBWTtBQUNaLGdDQUFnQyxtQkFBTyxDQUFDLDZGQUFpQjtBQUN6RCxvQkFBb0I7QUFDcEIsNEJBQTRCLG1CQUFPLENBQUMscUZBQWE7QUFDakQsZ0JBQWdCO0FBQ2hCLDZCQUE2QixtQkFBTyxDQUFDLHFGQUFhO0FBQ2xELGlCQUFpQjtBQUNqQiw2QkFBNkIsbUJBQU8sQ0FBQyxxRkFBYTtBQUNsRCxpQkFBaUI7QUFDakIsb0NBQW9DLG1CQUFPLENBQUMscUdBQXFCO0FBQ2pFLHdCQUF3QjtBQUN4Qiw0QkFBNEIsbUJBQU8sQ0FBQyxxRkFBYTtBQUNqRCxnQkFBZ0I7QUFDaEIsdUNBQXVDLG1CQUFPLENBQUMsMkdBQXdCO0FBQ3ZFLDJCQUEyQjtBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQywrRUFBVTtBQUM1QyxjQUFjO0FBQ2QsMkJBQTJCLG1CQUFPLENBQUMsbUZBQVk7QUFDL0MsZUFBZTtBQUNmLGlDQUFpQyxtQkFBTyxDQUFDLCtGQUFrQjtBQUMzRCxxQkFBcUI7QUFDckIsNEJBQTRCLG1CQUFPLENBQUMseUZBQVk7QUFDaEQsZ0JBQWdCO0FBQ2hCLDhCQUE4QixtQkFBTyxDQUFDLHlGQUFlO0FBQ3JELGtCQUFrQjtBQUNsQiw2QkFBNkIsbUJBQU8sQ0FBQyxtR0FBb0I7QUFDekQsaUJBQWlCO0FBQ2pCLHdCQUF3QixtQkFBTyxDQUFDLGlGQUFRO0FBQ3hDLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlcm5hbC9pbmRleC5qcz9iYTViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wb29sID0gZXhwb3J0cy5ib2x0QWdlbnQgPSBleHBvcnRzLm9iamVjdFV0aWwgPSBleHBvcnRzLnJlc29sdmVyID0gZXhwb3J0cy5zZXJ2ZXJBZGRyZXNzID0gZXhwb3J0cy51cmxVdGlsID0gZXhwb3J0cy5sb2dnZXIgPSBleHBvcnRzLnRyYW5zYWN0aW9uRXhlY3V0b3IgPSBleHBvcnRzLnR4Q29uZmlnID0gZXhwb3J0cy5jb25uZWN0aW9uSG9sZGVyID0gZXhwb3J0cy5jb25zdGFudHMgPSBleHBvcnRzLmJvb2ttYXJrcyA9IGV4cG9ydHMub2JzZXJ2ZXIgPSBleHBvcnRzLnRlbXBvcmFsVXRpbCA9IGV4cG9ydHMudXRpbCA9IHZvaWQgMDtcbnZhciB1dGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxcIikpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbnZhciB0ZW1wb3JhbFV0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdGVtcG9yYWwtdXRpbFwiKSk7XG5leHBvcnRzLnRlbXBvcmFsVXRpbCA9IHRlbXBvcmFsVXRpbDtcbnZhciBvYnNlcnZlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9vYnNlcnZlcnNcIikpO1xuZXhwb3J0cy5vYnNlcnZlciA9IG9ic2VydmVyO1xudmFyIGJvb2ttYXJrcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9ib29rbWFya3NcIikpO1xuZXhwb3J0cy5ib29rbWFya3MgPSBib29rbWFya3M7XG52YXIgY29uc3RhbnRzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSk7XG5leHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbnZhciBjb25uZWN0aW9uSG9sZGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24taG9sZGVyXCIpKTtcbmV4cG9ydHMuY29ubmVjdGlvbkhvbGRlciA9IGNvbm5lY3Rpb25Ib2xkZXI7XG52YXIgdHhDb25maWcgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHgtY29uZmlnXCIpKTtcbmV4cG9ydHMudHhDb25maWcgPSB0eENvbmZpZztcbnZhciB0cmFuc2FjdGlvbkV4ZWN1dG9yID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLWV4ZWN1dG9yXCIpKTtcbmV4cG9ydHMudHJhbnNhY3Rpb25FeGVjdXRvciA9IHRyYW5zYWN0aW9uRXhlY3V0b3I7XG52YXIgbG9nZ2VyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvZ2dlclwiKSk7XG5leHBvcnRzLmxvZ2dlciA9IGxvZ2dlcjtcbnZhciB1cmxVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3VybC11dGlsXCIpKTtcbmV4cG9ydHMudXJsVXRpbCA9IHVybFV0aWw7XG52YXIgc2VydmVyQWRkcmVzcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZXJ2ZXItYWRkcmVzc1wiKSk7XG5leHBvcnRzLnNlcnZlckFkZHJlc3MgPSBzZXJ2ZXJBZGRyZXNzO1xudmFyIHJlc29sdmVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpKTtcbmV4cG9ydHMucmVzb2x2ZXIgPSByZXNvbHZlcjtcbnZhciBvYmplY3RVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdC11dGlsXCIpKTtcbmV4cG9ydHMub2JqZWN0VXRpbCA9IG9iamVjdFV0aWw7XG52YXIgYm9sdEFnZW50ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JvbHQtYWdlbnQvaW5kZXhcIikpO1xuZXhwb3J0cy5ib2x0QWdlbnQgPSBib2x0QWdlbnQ7XG52YXIgcG9vbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9wb29sXCIpKTtcbmV4cG9ydHMucG9vbCA9IHBvb2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/logger.js":
/*!***************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/logger.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Logger = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar error_1 = __webpack_require__(/*! ../error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar ERROR = 'error';\nvar WARN = 'warn';\nvar INFO = 'info';\nvar DEBUG = 'debug';\nvar DEFAULT_LEVEL = INFO;\nvar levels = (_a = {},\n    _a[ERROR] = 0,\n    _a[WARN] = 1,\n    _a[INFO] = 2,\n    _a[DEBUG] = 3,\n    _a);\n/**\n * Logger used by the driver to notify about various internal events. Single logger should be used per driver.\n */\nvar Logger = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {string} level the enabled logging level.\n     * @param {function(level: string, message: string)} loggerFunction the function to write the log level and message.\n     */\n    function Logger(level, loggerFunction) {\n        this._level = level;\n        this._loggerFunction = loggerFunction;\n    }\n    /**\n     * Create a new logger based on the given driver configuration.\n     * @param {Object} driverConfig the driver configuration as supplied by the user.\n     * @return {Logger} a new logger instance or a no-op logger when not configured.\n     */\n    Logger.create = function (driverConfig) {\n        if ((driverConfig === null || driverConfig === void 0 ? void 0 : driverConfig.logging) != null) {\n            var loggingConfig = driverConfig.logging;\n            var level = extractConfiguredLevel(loggingConfig);\n            var loggerFunction = extractConfiguredLogger(loggingConfig);\n            return new Logger(level, loggerFunction);\n        }\n        return this.noOp();\n    };\n    /**\n     * Create a no-op logger implementation.\n     * @return {Logger} the no-op logger implementation.\n     */\n    Logger.noOp = function () {\n        return noOpLogger;\n    };\n    /**\n     * Check if error logging is enabled, i.e. it is not a no-op implementation.\n     * @return {boolean} `true` when enabled, `false` otherwise.\n     */\n    Logger.prototype.isErrorEnabled = function () {\n        return isLevelEnabled(this._level, ERROR);\n    };\n    /**\n     * Log an error message.\n     * @param {string} message the message to log.\n     */\n    Logger.prototype.error = function (message) {\n        if (this.isErrorEnabled()) {\n            this._loggerFunction(ERROR, message);\n        }\n    };\n    /**\n     * Check if warn logging is enabled, i.e. it is not a no-op implementation.\n     * @return {boolean} `true` when enabled, `false` otherwise.\n     */\n    Logger.prototype.isWarnEnabled = function () {\n        return isLevelEnabled(this._level, WARN);\n    };\n    /**\n     * Log an warning message.\n     * @param {string} message the message to log.\n     */\n    Logger.prototype.warn = function (message) {\n        if (this.isWarnEnabled()) {\n            this._loggerFunction(WARN, message);\n        }\n    };\n    /**\n     * Check if info logging is enabled, i.e. it is not a no-op implementation.\n     * @return {boolean} `true` when enabled, `false` otherwise.\n     */\n    Logger.prototype.isInfoEnabled = function () {\n        return isLevelEnabled(this._level, INFO);\n    };\n    /**\n     * Log an info message.\n     * @param {string} message the message to log.\n     */\n    Logger.prototype.info = function (message) {\n        if (this.isInfoEnabled()) {\n            this._loggerFunction(INFO, message);\n        }\n    };\n    /**\n     * Check if debug logging is enabled, i.e. it is not a no-op implementation.\n     * @return {boolean} `true` when enabled, `false` otherwise.\n     */\n    Logger.prototype.isDebugEnabled = function () {\n        return isLevelEnabled(this._level, DEBUG);\n    };\n    /**\n     * Log a debug message.\n     * @param {string} message the message to log.\n     */\n    Logger.prototype.debug = function (message) {\n        if (this.isDebugEnabled()) {\n            this._loggerFunction(DEBUG, message);\n        }\n    };\n    return Logger;\n}());\nexports.Logger = Logger;\nvar NoOpLogger = /** @class */ (function (_super) {\n    __extends(NoOpLogger, _super);\n    function NoOpLogger() {\n        return _super.call(this, INFO, function (level, message) { }) || this;\n    }\n    NoOpLogger.prototype.isErrorEnabled = function () {\n        return false;\n    };\n    NoOpLogger.prototype.error = function (message) { };\n    NoOpLogger.prototype.isWarnEnabled = function () {\n        return false;\n    };\n    NoOpLogger.prototype.warn = function (message) { };\n    NoOpLogger.prototype.isInfoEnabled = function () {\n        return false;\n    };\n    NoOpLogger.prototype.info = function (message) { };\n    NoOpLogger.prototype.isDebugEnabled = function () {\n        return false;\n    };\n    NoOpLogger.prototype.debug = function (message) { };\n    return NoOpLogger;\n}(Logger));\nvar noOpLogger = new NoOpLogger();\n/**\n * Check if the given logging level is enabled.\n * @param {string} configuredLevel the configured level.\n * @param {string} targetLevel the level to check.\n * @return {boolean} value of `true` when enabled, `false` otherwise.\n */\nfunction isLevelEnabled(configuredLevel, targetLevel) {\n    return levels[configuredLevel] >= levels[targetLevel];\n}\n/**\n * Extract the configured logging level from the driver's logging configuration.\n * @param {Object} loggingConfig the logging configuration.\n * @return {string} the configured log level or default when none configured.\n */\nfunction extractConfiguredLevel(loggingConfig) {\n    if ((loggingConfig === null || loggingConfig === void 0 ? void 0 : loggingConfig.level) != null) {\n        var configuredLevel = loggingConfig.level;\n        var value = levels[configuredLevel];\n        if (value == null && value !== 0) {\n            throw (0, error_1.newError)(\"Illegal logging level: \".concat(configuredLevel, \". Supported levels are: \").concat(Object.keys(levels).toString()));\n        }\n        return configuredLevel;\n    }\n    return DEFAULT_LEVEL;\n}\n/**\n * Extract the configured logger function from the driver's logging configuration.\n * @param {Object} loggingConfig the logging configuration.\n * @return {function(level: string, message: string)} the configured logging function.\n */\nfunction extractConfiguredLogger(loggingConfig) {\n    var _a, _b;\n    if ((loggingConfig === null || loggingConfig === void 0 ? void 0 : loggingConfig.logger) != null) {\n        var configuredLogger = loggingConfig.logger;\n        if (configuredLogger != null && typeof configuredLogger === 'function') {\n            return configuredLogger;\n        }\n    }\n    throw (0, error_1.newError)(\"Illegal logger function: \".concat((_b = (_a = loggingConfig === null || loggingConfig === void 0 ? void 0 : loggingConfig.logger) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : 'undefined'));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL2xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxxRUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQ0FBMEM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLDBDQUEwQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvbG9nZ2VyLmpzP2NjY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dnZXIgPSB2b2lkIDA7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIFdBUk4gPSAnd2Fybic7XG52YXIgSU5GTyA9ICdpbmZvJztcbnZhciBERUJVRyA9ICdkZWJ1Zyc7XG52YXIgREVGQVVMVF9MRVZFTCA9IElORk87XG52YXIgbGV2ZWxzID0gKF9hID0ge30sXG4gICAgX2FbRVJST1JdID0gMCxcbiAgICBfYVtXQVJOXSA9IDEsXG4gICAgX2FbSU5GT10gPSAyLFxuICAgIF9hW0RFQlVHXSA9IDMsXG4gICAgX2EpO1xuLyoqXG4gKiBMb2dnZXIgdXNlZCBieSB0aGUgZHJpdmVyIHRvIG5vdGlmeSBhYm91dCB2YXJpb3VzIGludGVybmFsIGV2ZW50cy4gU2luZ2xlIGxvZ2dlciBzaG91bGQgYmUgdXNlZCBwZXIgZHJpdmVyLlxuICovXG52YXIgTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbCB0aGUgZW5hYmxlZCBsb2dnaW5nIGxldmVsLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obGV2ZWw6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKX0gbG9nZ2VyRnVuY3Rpb24gdGhlIGZ1bmN0aW9uIHRvIHdyaXRlIHRoZSBsb2cgbGV2ZWwgYW5kIG1lc3NhZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9nZ2VyKGxldmVsLCBsb2dnZXJGdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLl9sb2dnZXJGdW5jdGlvbiA9IGxvZ2dlckZ1bmN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbG9nZ2VyIGJhc2VkIG9uIHRoZSBnaXZlbiBkcml2ZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZHJpdmVyQ29uZmlnIHRoZSBkcml2ZXIgY29uZmlndXJhdGlvbiBhcyBzdXBwbGllZCBieSB0aGUgdXNlci5cbiAgICAgKiBAcmV0dXJuIHtMb2dnZXJ9IGEgbmV3IGxvZ2dlciBpbnN0YW5jZSBvciBhIG5vLW9wIGxvZ2dlciB3aGVuIG5vdCBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIExvZ2dlci5jcmVhdGUgPSBmdW5jdGlvbiAoZHJpdmVyQ29uZmlnKSB7XG4gICAgICAgIGlmICgoZHJpdmVyQ29uZmlnID09PSBudWxsIHx8IGRyaXZlckNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJpdmVyQ29uZmlnLmxvZ2dpbmcpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2dnaW5nQ29uZmlnID0gZHJpdmVyQ29uZmlnLmxvZ2dpbmc7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBleHRyYWN0Q29uZmlndXJlZExldmVsKGxvZ2dpbmdDb25maWcpO1xuICAgICAgICAgICAgdmFyIGxvZ2dlckZ1bmN0aW9uID0gZXh0cmFjdENvbmZpZ3VyZWRMb2dnZXIobG9nZ2luZ0NvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ2dlcihsZXZlbCwgbG9nZ2VyRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vT3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5vLW9wIGxvZ2dlciBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtMb2dnZXJ9IHRoZSBuby1vcCBsb2dnZXIgaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgTG9nZ2VyLm5vT3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBub09wTG9nZ2VyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZXJyb3IgbG9nZ2luZyBpcyBlbmFibGVkLCBpLmUuIGl0IGlzIG5vdCBhIG5vLW9wIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCB3aGVuIGVuYWJsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIExvZ2dlci5wcm90b3R5cGUuaXNFcnJvckVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc0xldmVsRW5hYmxlZCh0aGlzLl9sZXZlbCwgRVJST1IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Vycm9yRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXJGdW5jdGlvbihFUlJPUiwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHdhcm4gbG9nZ2luZyBpcyBlbmFibGVkLCBpLmUuIGl0IGlzIG5vdCBhIG5vLW9wIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCB3aGVuIGVuYWJsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIExvZ2dlci5wcm90b3R5cGUuaXNXYXJuRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGV2ZWxFbmFibGVkKHRoaXMuX2xldmVsLCBXQVJOKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhbiB3YXJuaW5nIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuICAgIExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzV2FybkVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyRnVuY3Rpb24oV0FSTiwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGluZm8gbG9nZ2luZyBpcyBlbmFibGVkLCBpLmUuIGl0IGlzIG5vdCBhIG5vLW9wIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCB3aGVuIGVuYWJsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIExvZ2dlci5wcm90b3R5cGUuaXNJbmZvRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGV2ZWxFbmFibGVkKHRoaXMuX2xldmVsLCBJTkZPKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhbiBpbmZvIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuICAgIExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5mb0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyRnVuY3Rpb24oSU5GTywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGRlYnVnIGxvZ2dpbmcgaXMgZW5hYmxlZCwgaS5lLiBpdCBpcyBub3QgYSBuby1vcCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBlbmFibGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBMb2dnZXIucHJvdG90eXBlLmlzRGVidWdFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNMZXZlbEVuYWJsZWQodGhpcy5fbGV2ZWwsIERFQlVHKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhIGRlYnVnIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gbG9nLlxuICAgICAqL1xuICAgIExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXJGdW5jdGlvbihERUJVRywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBMb2dnZXI7XG59KCkpO1xuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG52YXIgTm9PcExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9PcExvZ2dlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb09wTG9nZ2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgSU5GTywgZnVuY3Rpb24gKGxldmVsLCBtZXNzYWdlKSB7IH0pIHx8IHRoaXM7XG4gICAgfVxuICAgIE5vT3BMb2dnZXIucHJvdG90eXBlLmlzRXJyb3JFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBOb09wTG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IH07XG4gICAgTm9PcExvZ2dlci5wcm90b3R5cGUuaXNXYXJuRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTm9PcExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IH07XG4gICAgTm9PcExvZ2dlci5wcm90b3R5cGUuaXNJbmZvRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTm9PcExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IH07XG4gICAgTm9PcExvZ2dlci5wcm90b3R5cGUuaXNEZWJ1Z0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE5vT3BMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgfTtcbiAgICByZXR1cm4gTm9PcExvZ2dlcjtcbn0oTG9nZ2VyKSk7XG52YXIgbm9PcExvZ2dlciA9IG5ldyBOb09wTG9nZ2VyKCk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBsb2dnaW5nIGxldmVsIGlzIGVuYWJsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlndXJlZExldmVsIHRoZSBjb25maWd1cmVkIGxldmVsLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldExldmVsIHRoZSBsZXZlbCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHZhbHVlIG9mIGB0cnVlYCB3aGVuIGVuYWJsZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0xldmVsRW5hYmxlZChjb25maWd1cmVkTGV2ZWwsIHRhcmdldExldmVsKSB7XG4gICAgcmV0dXJuIGxldmVsc1tjb25maWd1cmVkTGV2ZWxdID49IGxldmVsc1t0YXJnZXRMZXZlbF07XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIGNvbmZpZ3VyZWQgbG9nZ2luZyBsZXZlbCBmcm9tIHRoZSBkcml2ZXIncyBsb2dnaW5nIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gbG9nZ2luZ0NvbmZpZyB0aGUgbG9nZ2luZyBjb25maWd1cmF0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgY29uZmlndXJlZCBsb2cgbGV2ZWwgb3IgZGVmYXVsdCB3aGVuIG5vbmUgY29uZmlndXJlZC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbmZpZ3VyZWRMZXZlbChsb2dnaW5nQ29uZmlnKSB7XG4gICAgaWYgKChsb2dnaW5nQ29uZmlnID09PSBudWxsIHx8IGxvZ2dpbmdDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dpbmdDb25maWcubGV2ZWwpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNvbmZpZ3VyZWRMZXZlbCA9IGxvZ2dpbmdDb25maWcubGV2ZWw7XG4gICAgICAgIHZhciB2YWx1ZSA9IGxldmVsc1tjb25maWd1cmVkTGV2ZWxdO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiB2YWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKFwiSWxsZWdhbCBsb2dnaW5nIGxldmVsOiBcIi5jb25jYXQoY29uZmlndXJlZExldmVsLCBcIi4gU3VwcG9ydGVkIGxldmVscyBhcmU6IFwiKS5jb25jYXQoT2JqZWN0LmtleXMobGV2ZWxzKS50b1N0cmluZygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZ3VyZWRMZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIERFRkFVTFRfTEVWRUw7XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIGNvbmZpZ3VyZWQgbG9nZ2VyIGZ1bmN0aW9uIGZyb20gdGhlIGRyaXZlcidzIGxvZ2dpbmcgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2dnaW5nQ29uZmlnIHRoZSBsb2dnaW5nIGNvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihsZXZlbDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpfSB0aGUgY29uZmlndXJlZCBsb2dnaW5nIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29uZmlndXJlZExvZ2dlcihsb2dnaW5nQ29uZmlnKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoKGxvZ2dpbmdDb25maWcgPT09IG51bGwgfHwgbG9nZ2luZ0NvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nZ2luZ0NvbmZpZy5sb2dnZXIpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNvbmZpZ3VyZWRMb2dnZXIgPSBsb2dnaW5nQ29uZmlnLmxvZ2dlcjtcbiAgICAgICAgaWYgKGNvbmZpZ3VyZWRMb2dnZXIgIT0gbnVsbCAmJiB0eXBlb2YgY29uZmlndXJlZExvZ2dlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ3VyZWRMb2dnZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKFwiSWxsZWdhbCBsb2dnZXIgZnVuY3Rpb246IFwiLmNvbmNhdCgoX2IgPSAoX2EgPSBsb2dnaW5nQ29uZmlnID09PSBudWxsIHx8IGxvZ2dpbmdDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dpbmdDb25maWcubG9nZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3VuZGVmaW5lZCcpKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/object-util.js":
/*!********************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/object-util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBrokenObjectReason = exports.isBrokenObject = exports.createBrokenObject = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar __isBrokenObject__ = '__isBrokenObject__';\n// eslint-disable-next-line @typescript-eslint/naming-convention\nvar __reason__ = '__reason__';\n/**\n * Creates a object which all method call will throw the given error\n *\n * @param {Error} error The error\n * @param {any} object The object. Default: {}\n * @returns {any} A broken object\n */\nfunction createBrokenObject(error, object) {\n    if (object === void 0) { object = {}; }\n    var fail = function () {\n        throw error;\n    };\n    return new Proxy(object, {\n        get: function (_, p) {\n            if (p === __isBrokenObject__) {\n                return true;\n            }\n            else if (p === __reason__) {\n                return error;\n            }\n            else if (p === 'toJSON') {\n                return undefined;\n            }\n            fail();\n        },\n        set: fail,\n        apply: fail,\n        construct: fail,\n        defineProperty: fail,\n        deleteProperty: fail,\n        getOwnPropertyDescriptor: fail,\n        getPrototypeOf: fail,\n        has: fail,\n        isExtensible: fail,\n        ownKeys: fail,\n        preventExtensions: fail,\n        setPrototypeOf: fail\n    });\n}\nexports.createBrokenObject = createBrokenObject;\n/**\n * Verifies if it is a Broken Object\n * @param {any} object The object\n * @returns {boolean} If it was created with createBrokenObject\n */\nfunction isBrokenObject(object) {\n    return object !== null && typeof object === 'object' && object[__isBrokenObject__] === true;\n}\nexports.isBrokenObject = isBrokenObject;\n/**\n * Returns if the reason the object is broken.\n *\n * This method should only be called with instances create with {@link createBrokenObject}\n *\n * @param {any} object The object\n * @returns {Error} The reason the object is broken\n */\nfunction getBrokenObjectReason(object) {\n    return object[__reason__];\n}\nexports.getBrokenObjectReason = getBrokenObjectReason;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL29iamVjdC11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLHNCQUFzQixHQUFHLDBCQUEwQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlcm5hbC9vYmplY3QtdXRpbC5qcz9kZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRCcm9rZW5PYmplY3RSZWFzb24gPSBleHBvcnRzLmlzQnJva2VuT2JqZWN0ID0gZXhwb3J0cy5jcmVhdGVCcm9rZW5PYmplY3QgPSB2b2lkIDA7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxudmFyIF9faXNCcm9rZW5PYmplY3RfXyA9ICdfX2lzQnJva2VuT2JqZWN0X18nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxudmFyIF9fcmVhc29uX18gPSAnX19yZWFzb25fXyc7XG4vKipcbiAqIENyZWF0ZXMgYSBvYmplY3Qgd2hpY2ggYWxsIG1ldGhvZCBjYWxsIHdpbGwgdGhyb3cgdGhlIGdpdmVuIGVycm9yXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0IFRoZSBvYmplY3QuIERlZmF1bHQ6IHt9XG4gKiBAcmV0dXJucyB7YW55fSBBIGJyb2tlbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnJva2VuT2JqZWN0KGVycm9yLCBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09PSB2b2lkIDApIHsgb2JqZWN0ID0ge307IH1cbiAgICB2YXIgZmFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb3h5KG9iamVjdCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChfLCBwKSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gX19pc0Jyb2tlbk9iamVjdF9fKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSBfX3JlYXNvbl9fKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocCA9PT0gJ3RvSlNPTicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFpbCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZhaWwsXG4gICAgICAgIGFwcGx5OiBmYWlsLFxuICAgICAgICBjb25zdHJ1Y3Q6IGZhaWwsXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBmYWlsLFxuICAgICAgICBkZWxldGVQcm9wZXJ0eTogZmFpbCxcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmYWlsLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogZmFpbCxcbiAgICAgICAgaGFzOiBmYWlsLFxuICAgICAgICBpc0V4dGVuc2libGU6IGZhaWwsXG4gICAgICAgIG93bktleXM6IGZhaWwsXG4gICAgICAgIHByZXZlbnRFeHRlbnNpb25zOiBmYWlsLFxuICAgICAgICBzZXRQcm90b3R5cGVPZjogZmFpbFxuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCcm9rZW5PYmplY3QgPSBjcmVhdGVCcm9rZW5PYmplY3Q7XG4vKipcbiAqIFZlcmlmaWVzIGlmIGl0IGlzIGEgQnJva2VuIE9iamVjdFxuICogQHBhcmFtIHthbnl9IG9iamVjdCBUaGUgb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgaXQgd2FzIGNyZWF0ZWQgd2l0aCBjcmVhdGVCcm9rZW5PYmplY3RcbiAqL1xuZnVuY3Rpb24gaXNCcm9rZW5PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3RbX19pc0Jyb2tlbk9iamVjdF9fXSA9PT0gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNCcm9rZW5PYmplY3QgPSBpc0Jyb2tlbk9iamVjdDtcbi8qKlxuICogUmV0dXJucyBpZiB0aGUgcmVhc29uIHRoZSBvYmplY3QgaXMgYnJva2VuLlxuICpcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aXRoIGluc3RhbmNlcyBjcmVhdGUgd2l0aCB7QGxpbmsgY3JlYXRlQnJva2VuT2JqZWN0fVxuICpcbiAqIEBwYXJhbSB7YW55fSBvYmplY3QgVGhlIG9iamVjdFxuICogQHJldHVybnMge0Vycm9yfSBUaGUgcmVhc29uIHRoZSBvYmplY3QgaXMgYnJva2VuXG4gKi9cbmZ1bmN0aW9uIGdldEJyb2tlbk9iamVjdFJlYXNvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0W19fcmVhc29uX19dO1xufVxuZXhwb3J0cy5nZXRCcm9rZW5PYmplY3RSZWFzb24gPSBnZXRCcm9rZW5PYmplY3RSZWFzb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/object-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/observers.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/observers.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FailedObserver = exports.CompletedObserver = void 0;\nvar CompletedObserver = /** @class */ (function () {\n    function CompletedObserver() {\n    }\n    CompletedObserver.prototype.subscribe = function (observer) {\n        apply(observer, observer.onKeys, []);\n        apply(observer, observer.onCompleted, {});\n    };\n    CompletedObserver.prototype.cancel = function () {\n        // do nothing\n    };\n    CompletedObserver.prototype.pause = function () {\n        // do nothing\n    };\n    CompletedObserver.prototype.resume = function () {\n        // do nothing\n    };\n    CompletedObserver.prototype.prepareToHandleSingleResponse = function () {\n        // do nothing\n    };\n    CompletedObserver.prototype.markCompleted = function () {\n        // do nothing\n    };\n    CompletedObserver.prototype.onError = function (error) {\n        // nothing to do, already finished\n        // eslint-disable-next-line\n        // @ts-ignore: not available in ES oldest supported version\n        throw new Error('CompletedObserver not supposed to call onError', { cause: error });\n    };\n    return CompletedObserver;\n}());\nexports.CompletedObserver = CompletedObserver;\nvar FailedObserver = /** @class */ (function () {\n    function FailedObserver(_a) {\n        var error = _a.error, onError = _a.onError;\n        this._error = error;\n        this._beforeError = onError;\n        this._observers = [];\n        this.onError(error);\n    }\n    FailedObserver.prototype.subscribe = function (observer) {\n        apply(observer, observer.onError, this._error);\n        this._observers.push(observer);\n    };\n    FailedObserver.prototype.onError = function (error) {\n        apply(this, this._beforeError, error);\n        this._observers.forEach(function (o) { return apply(o, o.onError, error); });\n    };\n    FailedObserver.prototype.cancel = function () {\n        // do nothing\n    };\n    FailedObserver.prototype.pause = function () {\n        // do nothing\n    };\n    FailedObserver.prototype.resume = function () {\n        // do nothing\n    };\n    FailedObserver.prototype.markCompleted = function () {\n        // do nothing\n    };\n    FailedObserver.prototype.prepareToHandleSingleResponse = function () {\n        // do nothing\n    };\n    return FailedObserver;\n}());\nexports.FailedObserver = FailedObserver;\nfunction apply(thisArg, func, param) {\n    if (func != null) {\n        func.bind(thisArg)(param);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL29ic2VydmVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsY0FBYztBQUMxRjtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9DQUFvQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvb2JzZXJ2ZXJzLmpzPzZhYTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GYWlsZWRPYnNlcnZlciA9IGV4cG9ydHMuQ29tcGxldGVkT2JzZXJ2ZXIgPSB2b2lkIDA7XG52YXIgQ29tcGxldGVkT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGxldGVkT2JzZXJ2ZXIoKSB7XG4gICAgfVxuICAgIENvbXBsZXRlZE9ic2VydmVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgYXBwbHkob2JzZXJ2ZXIsIG9ic2VydmVyLm9uS2V5cywgW10pO1xuICAgICAgICBhcHBseShvYnNlcnZlciwgb2JzZXJ2ZXIub25Db21wbGV0ZWQsIHt9KTtcbiAgICB9O1xuICAgIENvbXBsZXRlZE9ic2VydmVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9O1xuICAgIENvbXBsZXRlZE9ic2VydmVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgQ29tcGxldGVkT2JzZXJ2ZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgQ29tcGxldGVkT2JzZXJ2ZXIucHJvdG90eXBlLnByZXBhcmVUb0hhbmRsZVNpbmdsZVJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfTtcbiAgICBDb21wbGV0ZWRPYnNlcnZlci5wcm90b3R5cGUubWFya0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgQ29tcGxldGVkT2JzZXJ2ZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBkbywgYWxyZWFkeSBmaW5pc2hlZFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogbm90IGF2YWlsYWJsZSBpbiBFUyBvbGRlc3Qgc3VwcG9ydGVkIHZlcnNpb25cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wbGV0ZWRPYnNlcnZlciBub3Qgc3VwcG9zZWQgdG8gY2FsbCBvbkVycm9yJywgeyBjYXVzZTogZXJyb3IgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGxldGVkT2JzZXJ2ZXI7XG59KCkpO1xuZXhwb3J0cy5Db21wbGV0ZWRPYnNlcnZlciA9IENvbXBsZXRlZE9ic2VydmVyO1xudmFyIEZhaWxlZE9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZhaWxlZE9ic2VydmVyKF9hKSB7XG4gICAgICAgIHZhciBlcnJvciA9IF9hLmVycm9yLCBvbkVycm9yID0gX2Eub25FcnJvcjtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fYmVmb3JlRXJyb3IgPSBvbkVycm9yO1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgRmFpbGVkT2JzZXJ2ZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBhcHBseShvYnNlcnZlciwgb2JzZXJ2ZXIub25FcnJvciwgdGhpcy5fZXJyb3IpO1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgfTtcbiAgICBGYWlsZWRPYnNlcnZlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBhcHBseSh0aGlzLCB0aGlzLl9iZWZvcmVFcnJvciwgZXJyb3IpO1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAobykgeyByZXR1cm4gYXBwbHkobywgby5vbkVycm9yLCBlcnJvcik7IH0pO1xuICAgIH07XG4gICAgRmFpbGVkT2JzZXJ2ZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgRmFpbGVkT2JzZXJ2ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfTtcbiAgICBGYWlsZWRPYnNlcnZlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfTtcbiAgICBGYWlsZWRPYnNlcnZlci5wcm90b3R5cGUubWFya0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgRmFpbGVkT2JzZXJ2ZXIucHJvdG90eXBlLnByZXBhcmVUb0hhbmRsZVNpbmdsZVJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfTtcbiAgICByZXR1cm4gRmFpbGVkT2JzZXJ2ZXI7XG59KCkpO1xuZXhwb3J0cy5GYWlsZWRPYnNlcnZlciA9IEZhaWxlZE9ic2VydmVyO1xuZnVuY3Rpb24gYXBwbHkodGhpc0FyZywgZnVuYywgcGFyYW0pIHtcbiAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIGZ1bmMuYmluZCh0aGlzQXJnKShwYXJhbSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/observers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/pool/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_MAX_SIZE = exports.DEFAULT_ACQUISITION_TIMEOUT = exports.PoolConfig = exports.Pool = void 0;\nvar pool_config_1 = __importStar(__webpack_require__(/*! ./pool-config */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/pool-config.js\"));\nexports.PoolConfig = pool_config_1.default;\nObject.defineProperty(exports, \"DEFAULT_ACQUISITION_TIMEOUT\", ({ enumerable: true, get: function () { return pool_config_1.DEFAULT_ACQUISITION_TIMEOUT; } }));\nObject.defineProperty(exports, \"DEFAULT_MAX_SIZE\", ({ enumerable: true, get: function () { return pool_config_1.DEFAULT_MAX_SIZE; } }));\nvar pool_1 = __importDefault(__webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/pool.js\"));\nexports.Pool = pool_1.default;\nexports[\"default\"] = pool_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Bvb2wvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxtQ0FBbUMsR0FBRyxrQkFBa0IsR0FBRyxZQUFZO0FBQ2xHLGlDQUFpQyxtQkFBTyxDQUFDLDhGQUFlO0FBQ3hELGtCQUFrQjtBQUNsQiwrREFBOEQsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDM0osb0RBQW1ELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3JJLDZCQUE2QixtQkFBTyxDQUFDLGdGQUFRO0FBQzdDLFlBQVk7QUFDWixrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Bvb2wvaW5kZXguanM/YTIwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9NQVhfU0laRSA9IGV4cG9ydHMuREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUID0gZXhwb3J0cy5Qb29sQ29uZmlnID0gZXhwb3J0cy5Qb29sID0gdm9pZCAwO1xudmFyIHBvb2xfY29uZmlnXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcG9vbC1jb25maWdcIikpO1xuZXhwb3J0cy5Qb29sQ29uZmlnID0gcG9vbF9jb25maWdfMS5kZWZhdWx0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwb29sX2NvbmZpZ18xLkRFRkFVTFRfQUNRVUlTSVRJT05fVElNRU9VVDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFRkFVTFRfTUFYX1NJWkVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBvb2xfY29uZmlnXzEuREVGQVVMVF9NQVhfU0laRTsgfSB9KTtcbnZhciBwb29sXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9vbFwiKSk7XG5leHBvcnRzLlBvb2wgPSBwb29sXzEuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IHBvb2xfMS5kZWZhdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/pool-config.js":
/*!*************************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/pool/pool-config.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_ACQUISITION_TIMEOUT = exports.DEFAULT_MAX_SIZE = void 0;\nvar DEFAULT_MAX_SIZE = 100;\nexports.DEFAULT_MAX_SIZE = DEFAULT_MAX_SIZE;\nvar DEFAULT_ACQUISITION_TIMEOUT = 60 * 1000; // 60 seconds\nexports.DEFAULT_ACQUISITION_TIMEOUT = DEFAULT_ACQUISITION_TIMEOUT;\nvar PoolConfig = /** @class */ (function () {\n    function PoolConfig(maxSize, acquisitionTimeout) {\n        this.maxSize = valueOrDefault(maxSize, DEFAULT_MAX_SIZE);\n        this.acquisitionTimeout = valueOrDefault(acquisitionTimeout, DEFAULT_ACQUISITION_TIMEOUT);\n    }\n    PoolConfig.defaultConfig = function () {\n        return new PoolConfig(DEFAULT_MAX_SIZE, DEFAULT_ACQUISITION_TIMEOUT);\n    };\n    PoolConfig.fromDriverConfig = function (config) {\n        var maxSize = isConfigured(config.maxConnectionPoolSize)\n            ? config.maxConnectionPoolSize\n            : DEFAULT_MAX_SIZE;\n        var acquisitionTimeout = isConfigured(config.connectionAcquisitionTimeout)\n            ? config.connectionAcquisitionTimeout\n            : DEFAULT_ACQUISITION_TIMEOUT;\n        return new PoolConfig(maxSize, acquisitionTimeout);\n    };\n    return PoolConfig;\n}());\nexports[\"default\"] = PoolConfig;\nfunction valueOrDefault(value, defaultValue) {\n    return isConfigured(value) ? value : defaultValue;\n}\nfunction isConfigured(value) {\n    return value === 0 || value != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Bvb2wvcG9vbC1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyx3QkFBd0I7QUFDOUQ7QUFDQSx3QkFBd0I7QUFDeEIsNkNBQTZDO0FBQzdDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlcm5hbC9wb29sL3Bvb2wtY29uZmlnLmpzP2VlMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQgPSBleHBvcnRzLkRFRkFVTFRfTUFYX1NJWkUgPSB2b2lkIDA7XG52YXIgREVGQVVMVF9NQVhfU0laRSA9IDEwMDtcbmV4cG9ydHMuREVGQVVMVF9NQVhfU0laRSA9IERFRkFVTFRfTUFYX1NJWkU7XG52YXIgREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUID0gNjAgKiAxMDAwOyAvLyA2MCBzZWNvbmRzXG5leHBvcnRzLkRFRkFVTFRfQUNRVUlTSVRJT05fVElNRU9VVCA9IERFRkFVTFRfQUNRVUlTSVRJT05fVElNRU9VVDtcbnZhciBQb29sQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvb2xDb25maWcobWF4U2l6ZSwgYWNxdWlzaXRpb25UaW1lb3V0KSB7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG1heFNpemUsIERFRkFVTFRfTUFYX1NJWkUpO1xuICAgICAgICB0aGlzLmFjcXVpc2l0aW9uVGltZW91dCA9IHZhbHVlT3JEZWZhdWx0KGFjcXVpc2l0aW9uVGltZW91dCwgREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUKTtcbiAgICB9XG4gICAgUG9vbENvbmZpZy5kZWZhdWx0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvb2xDb25maWcoREVGQVVMVF9NQVhfU0laRSwgREVGQVVMVF9BQ1FVSVNJVElPTl9USU1FT1VUKTtcbiAgICB9O1xuICAgIFBvb2xDb25maWcuZnJvbURyaXZlckNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIG1heFNpemUgPSBpc0NvbmZpZ3VyZWQoY29uZmlnLm1heENvbm5lY3Rpb25Qb29sU2l6ZSlcbiAgICAgICAgICAgID8gY29uZmlnLm1heENvbm5lY3Rpb25Qb29sU2l6ZVxuICAgICAgICAgICAgOiBERUZBVUxUX01BWF9TSVpFO1xuICAgICAgICB2YXIgYWNxdWlzaXRpb25UaW1lb3V0ID0gaXNDb25maWd1cmVkKGNvbmZpZy5jb25uZWN0aW9uQWNxdWlzaXRpb25UaW1lb3V0KVxuICAgICAgICAgICAgPyBjb25maWcuY29ubmVjdGlvbkFjcXVpc2l0aW9uVGltZW91dFxuICAgICAgICAgICAgOiBERUZBVUxUX0FDUVVJU0lUSU9OX1RJTUVPVVQ7XG4gICAgICAgIHJldHVybiBuZXcgUG9vbENvbmZpZyhtYXhTaXplLCBhY3F1aXNpdGlvblRpbWVvdXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvb2xDb25maWc7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUG9vbENvbmZpZztcbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gaXNDb25maWd1cmVkKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gaXNDb25maWd1cmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwIHx8IHZhbHVlICE9IG51bGw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/pool-config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/pool.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/pool/pool.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar pool_config_1 = __importDefault(__webpack_require__(/*! ./pool-config */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/pool-config.js\"));\nvar error_1 = __webpack_require__(/*! ../../error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar logger_1 = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/logger.js\");\nvar Pool = /** @class */ (function () {\n    /**\n     * @param {function(acquisitionContext: object, address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create\n     *                an allocation function that creates a promise with a new resource. It's given an address for which to\n     *                allocate the connection and a function that will return the resource to the pool if invoked, which is\n     *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.\n     * @param {function(acquisitionContext: object, resource: object): boolean} validateOnAcquire\n     *                called at various times when an instance is acquired\n     *                If this returns false, the resource will be evicted\n     * @param {function(resource: object): boolean} validateOnRelease\n     *                called at various times when an instance is released\n     *                If this returns false, the resource will be evicted\n     * @param {function(resource: object): Promise<void>} destroy\n     *                called with the resource when it is evicted from this pool\n     * @param {function(resource: object, observer: { onError }): void} installIdleObserver\n     *                called when the resource is released back to pool\n     * @param {function(resource: object): void} removeIdleObserver\n     *                called when the resource is acquired from the pool\n     * @param {PoolConfig} config configuration for the new driver.\n     * @param {Logger} log the driver logger.\n     */\n    function Pool(_a) {\n        var _b = _a.create, create = _b === void 0 ? function (acquisitionContext, address, release) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, Promise.reject(new Error('Not implemented'))];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        }); }); } : _b, _c = _a.destroy, destroy = _c === void 0 ? function (conn) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, Promise.resolve()];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        }); }); } : _c, _d = _a.validateOnAcquire, validateOnAcquire = _d === void 0 ? function (acquisitionContext, conn) { return true; } : _d, _e = _a.validateOnRelease, validateOnRelease = _e === void 0 ? function (conn) { return true; } : _e, _f = _a.installIdleObserver, installIdleObserver = _f === void 0 ? function (conn, observer) { } : _f, _g = _a.removeIdleObserver, removeIdleObserver = _g === void 0 ? function (conn) { } : _g, _h = _a.config, config = _h === void 0 ? pool_config_1.default.defaultConfig() : _h, _j = _a.log, log = _j === void 0 ? logger_1.Logger.noOp() : _j;\n        var _this = this;\n        this._create = create;\n        this._destroy = destroy;\n        this._validateOnAcquire = validateOnAcquire;\n        this._validateOnRelease = validateOnRelease;\n        this._installIdleObserver = installIdleObserver;\n        this._removeIdleObserver = removeIdleObserver;\n        this._maxSize = config.maxSize;\n        this._acquisitionTimeout = config.acquisitionTimeout;\n        this._pools = {};\n        this._pendingCreates = {};\n        this._acquireRequests = {};\n        this._activeResourceCounts = {};\n        this._release = this._release.bind(this);\n        this._log = log;\n        this._closed = false;\n    }\n    /**\n     * Acquire and idle resource fom the pool or create a new one.\n     * @param {object} acquisitionContext the acquisition context used for create and validateOnAcquire connection\n     * @param {ServerAddress} address the address for which we're acquiring.\n     * @param {object} config the config\n     * @param {boolean} config.requireNew Indicate it requires a new resource\n     * @return {Promise<Object>} resource that is ready to use.\n     */\n    Pool.prototype.acquire = function (acquisitionContext, address, config) {\n        return __awaiter(this, void 0, void 0, function () {\n            var key, allRequests, requests;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        key = address.asKey();\n                        allRequests = this._acquireRequests;\n                        requests = allRequests[key];\n                        if (requests == null) {\n                            allRequests[key] = [];\n                        }\n                        return [4 /*yield*/, new Promise(function (resolve, reject) {\n                                var timeoutId = setTimeout(function () {\n                                    // acquisition timeout fired\n                                    // remove request from the queue of pending requests, if it's still there\n                                    // request might've been taken out by the release operation\n                                    var pendingRequests = allRequests[key];\n                                    if (pendingRequests != null) {\n                                        allRequests[key] = pendingRequests.filter(function (item) { return item !== request; });\n                                    }\n                                    if (request.isCompleted()) {\n                                        // request already resolved/rejected by the release operation; nothing to do\n                                    }\n                                    else {\n                                        // request is still pending and needs to be failed\n                                        var activeCount = _this.activeResourceCount(address);\n                                        var idleCount = _this.has(address) ? _this._pools[key].length : 0;\n                                        request.reject((0, error_1.newError)(\"Connection acquisition timed out in \".concat(_this._acquisitionTimeout, \" ms. Pool status: Active conn count = \").concat(activeCount, \", Idle conn count = \").concat(idleCount, \".\")));\n                                    }\n                                }, _this._acquisitionTimeout);\n                                if (typeof timeoutId === 'object') {\n                                    // eslint-disable-next-line\n                                    // @ts-ignore\n                                    timeoutId.unref();\n                                }\n                                var request = new PendingRequest(key, acquisitionContext, config, resolve, reject, timeoutId, _this._log);\n                                allRequests[key].push(request);\n                                _this._processPendingAcquireRequests(address);\n                            })];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Destroy all idle resources for the given address.\n     * @param {ServerAddress} address the address of the server to purge its pool.\n     * @returns {Promise<void>} A promise that is resolved when the resources are purged\n     */\n    Pool.prototype.purge = function (address) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._purgeKey(address.asKey())];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    Pool.prototype.apply = function (address, resourceConsumer) {\n        var key = address.asKey();\n        if (key in this._pools) {\n            this._pools[key].apply(resourceConsumer);\n        }\n    };\n    /**\n     * Destroy all idle resources in this pool.\n     * @returns {Promise<void>} A promise that is resolved when the resources are purged\n     */\n    Pool.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this._closed = true;\n                        return [4 /*yield*/, Promise.all(Object.keys(this._pools).map(function (key) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, this._purgeKey(key)];\n                                    case 1: return [2 /*return*/, _a.sent()];\n                                }\n                            }); }); })).then()];\n                    case 1: \n                    /**\n                     * The lack of Promise consuming was making the driver do not close properly in the scenario\n                     * captured at result.test.js:it('should handle missing onCompleted'). The test was timing out\n                     * because while waiting for the driver close.\n                     *\n                     * Consuming the Promise.all or by calling then or by awaiting in the result inside this method solved\n                     * the issue somehow.\n                     *\n                     * PS: the return of this method was already awaited at PooledConnectionProvider.close, but the await bellow\n                     * seems to be need also.\n                     */\n                    return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Keep the idle resources for the provided addresses and purge the rest.\n     * @returns {Promise<void>} A promise that is resolved when the other resources are purged\n     */\n    Pool.prototype.keepAll = function (addresses) {\n        return __awaiter(this, void 0, void 0, function () {\n            var keysToKeep, keysPresent, keysToPurge;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        keysToKeep = addresses.map(function (a) { return a.asKey(); });\n                        keysPresent = Object.keys(this._pools);\n                        keysToPurge = keysPresent.filter(function (k) { return !keysToKeep.includes(k); });\n                        return [4 /*yield*/, Promise.all(keysToPurge.map(function (key) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, this._purgeKey(key)];\n                                    case 1: return [2 /*return*/, _a.sent()];\n                                }\n                            }); }); })).then()];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Check if this pool contains resources for the given address.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.\n     */\n    Pool.prototype.has = function (address) {\n        return address.asKey() in this._pools;\n    };\n    /**\n     * Get count of active (checked out of the pool) resources for the given key.\n     * @param {ServerAddress} address the address of the server to check.\n     * @return {number} count of resources acquired by clients.\n     */\n    Pool.prototype.activeResourceCount = function (address) {\n        var _a;\n        return (_a = this._activeResourceCounts[address.asKey()]) !== null && _a !== void 0 ? _a : 0;\n    };\n    Pool.prototype._getOrInitializePoolFor = function (key) {\n        var pool = this._pools[key];\n        if (pool == null) {\n            pool = new SingleAddressPool();\n            this._pools[key] = pool;\n            this._pendingCreates[key] = 0;\n        }\n        return pool;\n    };\n    Pool.prototype._acquire = function (acquisitionContext, address, requireNew) {\n        return __awaiter(this, void 0, void 0, function () {\n            var key, pool, resource_1, valid, e_1, numConnections, resource, numConnections, resource_2;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this._closed) {\n                            throw (0, error_1.newError)('Pool is closed, it is no more able to serve requests.');\n                        }\n                        key = address.asKey();\n                        pool = this._getOrInitializePoolFor(key);\n                        if (!!requireNew) return [3 /*break*/, 10];\n                        _a.label = 1;\n                    case 1:\n                        if (!(pool.length > 0)) return [3 /*break*/, 10];\n                        resource_1 = pool.pop();\n                        if (resource_1 == null) {\n                            return [3 /*break*/, 1];\n                        }\n                        resourceAcquired(key, this._activeResourceCounts);\n                        if (this._removeIdleObserver != null) {\n                            this._removeIdleObserver(resource_1);\n                        }\n                        valid = false;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 6]);\n                        return [4 /*yield*/, this._validateOnAcquire(acquisitionContext, resource_1)];\n                    case 3:\n                        valid = _a.sent();\n                        return [3 /*break*/, 6];\n                    case 4:\n                        e_1 = _a.sent();\n                        resourceReleased(key, this._activeResourceCounts);\n                        pool.removeInUse(resource_1);\n                        return [4 /*yield*/, this._destroy(resource_1)];\n                    case 5:\n                        _a.sent();\n                        throw e_1;\n                    case 6:\n                        if (!valid) return [3 /*break*/, 7];\n                        // idle resource is valid and can be acquired\n                        if (this._log.isDebugEnabled()) {\n                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                            this._log.debug(\"\".concat(resource_1, \" acquired from the pool \").concat(key));\n                        }\n                        return [2 /*return*/, { resource: resource_1, pool: pool }];\n                    case 7:\n                        resourceReleased(key, this._activeResourceCounts);\n                        pool.removeInUse(resource_1);\n                        return [4 /*yield*/, this._destroy(resource_1)];\n                    case 8:\n                        _a.sent();\n                        _a.label = 9;\n                    case 9: return [3 /*break*/, 1];\n                    case 10:\n                        // Ensure requested max pool size\n                        if (this._maxSize > 0) {\n                            numConnections = this.activeResourceCount(address) + this._pendingCreates[key];\n                            if (numConnections >= this._maxSize) {\n                                // Will put this request in queue instead since the pool is full\n                                return [2 /*return*/, { resource: null, pool: pool }];\n                            }\n                        }\n                        // there exist no idle valid resources, create a new one for acquisition\n                        // Keep track of how many pending creates there are to avoid making too many connections.\n                        this._pendingCreates[key] = this._pendingCreates[key] + 1;\n                        _a.label = 11;\n                    case 11:\n                        _a.trys.push([11, , 15, 16]);\n                        numConnections = this.activeResourceCount(address) + pool.length;\n                        if (!(numConnections >= this._maxSize && requireNew)) return [3 /*break*/, 13];\n                        resource_2 = pool.pop();\n                        if (!(resource_2 != null)) return [3 /*break*/, 13];\n                        if (this._removeIdleObserver != null) {\n                            this._removeIdleObserver(resource_2);\n                        }\n                        pool.removeInUse(resource_2);\n                        return [4 /*yield*/, this._destroy(resource_2)];\n                    case 12:\n                        _a.sent();\n                        _a.label = 13;\n                    case 13: return [4 /*yield*/, this._create(acquisitionContext, address, function (address, resource) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0: return [4 /*yield*/, this._release(address, resource, pool)];\n                                case 1: return [2 /*return*/, _a.sent()];\n                            }\n                        }); }); })];\n                    case 14:\n                        // Invoke callback that creates actual connection\n                        resource = _a.sent();\n                        pool.pushInUse(resource);\n                        resourceAcquired(key, this._activeResourceCounts);\n                        if (this._log.isDebugEnabled()) {\n                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                            this._log.debug(\"\".concat(resource, \" created for the pool \").concat(key));\n                        }\n                        return [3 /*break*/, 16];\n                    case 15:\n                        this._pendingCreates[key] = this._pendingCreates[key] - 1;\n                        return [7 /*endfinally*/];\n                    case 16: return [2 /*return*/, { resource: resource, pool: pool }];\n                }\n            });\n        });\n    };\n    Pool.prototype._release = function (address, resource, pool) {\n        return __awaiter(this, void 0, void 0, function () {\n            var key;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        key = address.asKey();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, , 9, 10]);\n                        if (!pool.isActive()) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this._validateOnRelease(resource)];\n                    case 2:\n                        if (!!(_a.sent())) return [3 /*break*/, 4];\n                        if (this._log.isDebugEnabled()) {\n                            this._log.debug(\n                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                            \"\".concat(resource, \" destroyed and can't be released to the pool \").concat(key, \" because it is not functional\"));\n                        }\n                        pool.removeInUse(resource);\n                        return [4 /*yield*/, this._destroy(resource)];\n                    case 3:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        if (this._installIdleObserver != null) {\n                            this._installIdleObserver(resource, {\n                                onError: function (error) {\n                                    _this._log.debug(\n                                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                                    \"Idle connection \".concat(resource, \" destroyed because of error: \").concat(error));\n                                    var pool = _this._pools[key];\n                                    if (pool != null) {\n                                        _this._pools[key] = pool.filter(function (r) { return r !== resource; });\n                                        pool.removeInUse(resource);\n                                    }\n                                    // let's not care about background clean-ups due to errors but just trigger the destroy\n                                    // process for the resource, we especially catch any errors and ignore them to avoid\n                                    // unhandled promise rejection warnings\n                                    _this._destroy(resource).catch(function () { });\n                                }\n                            });\n                        }\n                        pool.push(resource);\n                        if (this._log.isDebugEnabled()) {\n                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                            this._log.debug(\"\".concat(resource, \" released to the pool \").concat(key));\n                        }\n                        _a.label = 5;\n                    case 5: return [3 /*break*/, 8];\n                    case 6:\n                        // key has been purged, don't put it back, just destroy the resource\n                        if (this._log.isDebugEnabled()) {\n                            this._log.debug(\n                            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                            \"\".concat(resource, \" destroyed and can't be released to the pool \").concat(key, \" because pool has been purged\"));\n                        }\n                        pool.removeInUse(resource);\n                        return [4 /*yield*/, this._destroy(resource)];\n                    case 7:\n                        _a.sent();\n                        _a.label = 8;\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        resourceReleased(key, this._activeResourceCounts);\n                        this._processPendingAcquireRequests(address);\n                        return [7 /*endfinally*/];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Pool.prototype._purgeKey = function (key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var pool, destructionList, resource;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        pool = this._pools[key];\n                        destructionList = [];\n                        if (!(pool != null)) return [3 /*break*/, 2];\n                        while (pool.length > 0) {\n                            resource = pool.pop();\n                            if (resource == null) {\n                                continue;\n                            }\n                            if (this._removeIdleObserver != null) {\n                                this._removeIdleObserver(resource);\n                            }\n                            destructionList.push(this._destroy(resource));\n                        }\n                        pool.close();\n                        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                        delete this._pools[key];\n                        return [4 /*yield*/, Promise.all(destructionList)];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Pool.prototype._processPendingAcquireRequests = function (address) {\n        var _this = this;\n        var key = address.asKey();\n        var requests = this._acquireRequests[key];\n        if (requests != null) {\n            var pendingRequest_1 = requests.shift(); // pop a pending acquire request\n            if (pendingRequest_1 != null) {\n                this._acquire(pendingRequest_1.context, address, pendingRequest_1.requireNew)\n                    .catch(function (error) {\n                    // failed to acquire/create a new connection to resolve the pending acquire request\n                    // propagate the error by failing the pending request\n                    pendingRequest_1.reject(error);\n                    return { resource: null, pool: null };\n                })\n                    .then(function (_a) {\n                    var resource = _a.resource, pool = _a.pool;\n                    // there is not situation where the pool resource is not null and the\n                    // pool is null.\n                    if (resource != null && pool != null) {\n                        // managed to acquire a valid resource from the pool\n                        if (pendingRequest_1.isCompleted()) {\n                            // request has been completed, most likely failed by a timeout\n                            // return the acquired resource back to the pool\n                            _this._release(address, resource, pool)\n                                .catch(function (error) {\n                                if (_this._log.isDebugEnabled()) {\n                                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                                    _this._log.debug(\"\".concat(resource, \" could not be release back to the pool. Cause: \").concat(error));\n                                }\n                            });\n                        }\n                        else {\n                            // request is still pending and can be resolved with the newly acquired resource\n                            pendingRequest_1.resolve(resource); // resolve the pending request with the acquired resource\n                        }\n                    }\n                    else {\n                        // failed to acquire a valid resource from the pool\n                        // return the pending request back to the pool\n                        if (!pendingRequest_1.isCompleted()) {\n                            if (_this._acquireRequests[key] == null) {\n                                _this._acquireRequests[key] = [];\n                            }\n                            _this._acquireRequests[key].unshift(pendingRequest_1);\n                        }\n                    }\n                }).catch(function (error) { return pendingRequest_1.reject(error); });\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this._acquireRequests[key];\n            }\n        }\n    };\n    return Pool;\n}());\n/**\n * Increment active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\nfunction resourceAcquired(key, activeResourceCounts) {\n    var _a;\n    var currentCount = (_a = activeResourceCounts[key]) !== null && _a !== void 0 ? _a : 0;\n    activeResourceCounts[key] = currentCount + 1;\n}\n/**\n * Decrement active (checked out of the pool) resource counter.\n * @param {string} key the resource group identifier (server address for connections).\n * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.\n */\nfunction resourceReleased(key, activeResourceCounts) {\n    var _a;\n    var currentCount = (_a = activeResourceCounts[key]) !== null && _a !== void 0 ? _a : 0;\n    var nextCount = currentCount - 1;\n    if (nextCount > 0) {\n        activeResourceCounts[key] = nextCount;\n    }\n    else {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete activeResourceCounts[key];\n    }\n}\nvar PendingRequest = /** @class */ (function () {\n    function PendingRequest(key, context, config, resolve, reject, timeoutId, log) {\n        this._key = key;\n        this._context = context;\n        this._resolve = resolve;\n        this._reject = reject;\n        this._timeoutId = timeoutId;\n        this._log = log;\n        this._completed = false;\n        this._config = config !== null && config !== void 0 ? config : {};\n    }\n    Object.defineProperty(PendingRequest.prototype, \"context\", {\n        get: function () {\n            return this._context;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(PendingRequest.prototype, \"requireNew\", {\n        get: function () {\n            var _a;\n            return (_a = this._config.requireNew) !== null && _a !== void 0 ? _a : false;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    PendingRequest.prototype.isCompleted = function () {\n        return this._completed;\n    };\n    PendingRequest.prototype.resolve = function (resource) {\n        if (this._completed) {\n            return;\n        }\n        this._completed = true;\n        clearTimeout(this._timeoutId);\n        if (this._log.isDebugEnabled()) {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            this._log.debug(\"\".concat(resource, \" acquired from the pool \").concat(this._key));\n        }\n        this._resolve(resource);\n    };\n    PendingRequest.prototype.reject = function (error) {\n        if (this._completed) {\n            return;\n        }\n        this._completed = true;\n        clearTimeout(this._timeoutId);\n        this._reject(error);\n    };\n    return PendingRequest;\n}());\nvar SingleAddressPool = /** @class */ (function () {\n    function SingleAddressPool() {\n        this._active = true;\n        this._elements = [];\n        this._elementsInUse = new Set();\n    }\n    SingleAddressPool.prototype.isActive = function () {\n        return this._active;\n    };\n    SingleAddressPool.prototype.close = function () {\n        this._active = false;\n        this._elements = [];\n        this._elementsInUse = new Set();\n    };\n    SingleAddressPool.prototype.filter = function (predicate) {\n        this._elements = this._elements.filter(predicate);\n        return this;\n    };\n    SingleAddressPool.prototype.apply = function (resourceConsumer) {\n        this._elements.forEach(resourceConsumer);\n        this._elementsInUse.forEach(resourceConsumer);\n    };\n    Object.defineProperty(SingleAddressPool.prototype, \"length\", {\n        get: function () {\n            return this._elements.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SingleAddressPool.prototype.pop = function () {\n        var element = this._elements.pop();\n        if (element != null) {\n            this._elementsInUse.add(element);\n        }\n        return element;\n    };\n    SingleAddressPool.prototype.push = function (element) {\n        this._elementsInUse.delete(element);\n        return this._elements.push(element);\n    };\n    SingleAddressPool.prototype.pushInUse = function (element) {\n        this._elementsInUse.add(element);\n    };\n    SingleAddressPool.prototype.removeInUse = function (element) {\n        this._elementsInUse.delete(element);\n    };\n    return SingleAddressPool;\n}());\nexports[\"default\"] = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Bvb2wvcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQyxtQkFBTyxDQUFDLDhGQUFlO0FBQzNELGNBQWMsbUJBQU8sQ0FBQyx3RUFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsZ0ZBQVc7QUFDbEM7QUFDQTtBQUNBLGVBQWUsb0pBQW9KO0FBQ25LO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQWlFO0FBQ2hGO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvcG9vbC9wb29sLmpzPzFkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBvb2xfY29uZmlnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9vbC1jb25maWdcIikpO1xudmFyIGVycm9yXzEgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xudmFyIFBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihhY3F1aXNpdGlvbkNvbnRleHQ6IG9iamVjdCwgYWRkcmVzczogU2VydmVyQWRkcmVzcywgZnVuY3Rpb24oYWRkcmVzczogU2VydmVyQWRkcmVzcywgcmVzb3VyY2U6IG9iamVjdCk6IFByb21pc2U8b2JqZWN0Pik6IFByb21pc2U8b2JqZWN0Pn0gY3JlYXRlXG4gICAgICogICAgICAgICAgICAgICAgYW4gYWxsb2NhdGlvbiBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBwcm9taXNlIHdpdGggYSBuZXcgcmVzb3VyY2UuIEl0J3MgZ2l2ZW4gYW4gYWRkcmVzcyBmb3Igd2hpY2ggdG9cbiAgICAgKiAgICAgICAgICAgICAgICBhbGxvY2F0ZSB0aGUgY29ubmVjdGlvbiBhbmQgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIHRoZSByZXNvdXJjZSB0byB0aGUgcG9vbCBpZiBpbnZva2VkLCB3aGljaCBpc1xuICAgICAqICAgICAgICAgICAgICAgIG1lYW50IHRvIGJlIGNhbGxlZCBvbiAuZGlzcG9zZSBvciAuY2xvc2Ugb3Igd2hhdGV2ZXIgbWVjaGFuaXNtIHRoZSByZXNvdXJjZSB1c2VzIHRvIGZpbmFsaXplLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oYWNxdWlzaXRpb25Db250ZXh0OiBvYmplY3QsIHJlc291cmNlOiBvYmplY3QpOiBib29sZWFufSB2YWxpZGF0ZU9uQWNxdWlyZVxuICAgICAqICAgICAgICAgICAgICAgIGNhbGxlZCBhdCB2YXJpb3VzIHRpbWVzIHdoZW4gYW4gaW5zdGFuY2UgaXMgYWNxdWlyZWRcbiAgICAgKiAgICAgICAgICAgICAgICBJZiB0aGlzIHJldHVybnMgZmFsc2UsIHRoZSByZXNvdXJjZSB3aWxsIGJlIGV2aWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc291cmNlOiBvYmplY3QpOiBib29sZWFufSB2YWxpZGF0ZU9uUmVsZWFzZVxuICAgICAqICAgICAgICAgICAgICAgIGNhbGxlZCBhdCB2YXJpb3VzIHRpbWVzIHdoZW4gYW4gaW5zdGFuY2UgaXMgcmVsZWFzZWRcbiAgICAgKiAgICAgICAgICAgICAgICBJZiB0aGlzIHJldHVybnMgZmFsc2UsIHRoZSByZXNvdXJjZSB3aWxsIGJlIGV2aWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc291cmNlOiBvYmplY3QpOiBQcm9taXNlPHZvaWQ+fSBkZXN0cm95XG4gICAgICogICAgICAgICAgICAgICAgY2FsbGVkIHdpdGggdGhlIHJlc291cmNlIHdoZW4gaXQgaXMgZXZpY3RlZCBmcm9tIHRoaXMgcG9vbFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVzb3VyY2U6IG9iamVjdCwgb2JzZXJ2ZXI6IHsgb25FcnJvciB9KTogdm9pZH0gaW5zdGFsbElkbGVPYnNlcnZlclxuICAgICAqICAgICAgICAgICAgICAgIGNhbGxlZCB3aGVuIHRoZSByZXNvdXJjZSBpcyByZWxlYXNlZCBiYWNrIHRvIHBvb2xcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc291cmNlOiBvYmplY3QpOiB2b2lkfSByZW1vdmVJZGxlT2JzZXJ2ZXJcbiAgICAgKiAgICAgICAgICAgICAgICBjYWxsZWQgd2hlbiB0aGUgcmVzb3VyY2UgaXMgYWNxdWlyZWQgZnJvbSB0aGUgcG9vbFxuICAgICAqIEBwYXJhbSB7UG9vbENvbmZpZ30gY29uZmlnIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBuZXcgZHJpdmVyLlxuICAgICAqIEBwYXJhbSB7TG9nZ2VyfSBsb2cgdGhlIGRyaXZlciBsb2dnZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUG9vbChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5jcmVhdGUsIGNyZWF0ZSA9IF9iID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoYWNxdWlzaXRpb25Db250ZXh0LCBhZGRyZXNzLCByZWxlYXNlKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJykpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTsgfSk7IH0gOiBfYiwgX2MgPSBfYS5kZXN0cm95LCBkZXN0cm95ID0gX2MgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChjb25uKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTsgfSk7IH0gOiBfYywgX2QgPSBfYS52YWxpZGF0ZU9uQWNxdWlyZSwgdmFsaWRhdGVPbkFjcXVpcmUgPSBfZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGFjcXVpc2l0aW9uQ29udGV4dCwgY29ubikgeyByZXR1cm4gdHJ1ZTsgfSA6IF9kLCBfZSA9IF9hLnZhbGlkYXRlT25SZWxlYXNlLCB2YWxpZGF0ZU9uUmVsZWFzZSA9IF9lID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoY29ubikgeyByZXR1cm4gdHJ1ZTsgfSA6IF9lLCBfZiA9IF9hLmluc3RhbGxJZGxlT2JzZXJ2ZXIsIGluc3RhbGxJZGxlT2JzZXJ2ZXIgPSBfZiA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGNvbm4sIG9ic2VydmVyKSB7IH0gOiBfZiwgX2cgPSBfYS5yZW1vdmVJZGxlT2JzZXJ2ZXIsIHJlbW92ZUlkbGVPYnNlcnZlciA9IF9nID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoY29ubikgeyB9IDogX2csIF9oID0gX2EuY29uZmlnLCBjb25maWcgPSBfaCA9PT0gdm9pZCAwID8gcG9vbF9jb25maWdfMS5kZWZhdWx0LmRlZmF1bHRDb25maWcoKSA6IF9oLCBfaiA9IF9hLmxvZywgbG9nID0gX2ogPT09IHZvaWQgMCA/IGxvZ2dlcl8xLkxvZ2dlci5ub09wKCkgOiBfajtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICB0aGlzLl9kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVPbkFjcXVpcmUgPSB2YWxpZGF0ZU9uQWNxdWlyZTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVPblJlbGVhc2UgPSB2YWxpZGF0ZU9uUmVsZWFzZTtcbiAgICAgICAgdGhpcy5faW5zdGFsbElkbGVPYnNlcnZlciA9IGluc3RhbGxJZGxlT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuX3JlbW92ZUlkbGVPYnNlcnZlciA9IHJlbW92ZUlkbGVPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IGNvbmZpZy5tYXhTaXplO1xuICAgICAgICB0aGlzLl9hY3F1aXNpdGlvblRpbWVvdXQgPSBjb25maWcuYWNxdWlzaXRpb25UaW1lb3V0O1xuICAgICAgICB0aGlzLl9wb29scyA9IHt9O1xuICAgICAgICB0aGlzLl9wZW5kaW5nQ3JlYXRlcyA9IHt9O1xuICAgICAgICB0aGlzLl9hY3F1aXJlUmVxdWVzdHMgPSB7fTtcbiAgICAgICAgdGhpcy5fYWN0aXZlUmVzb3VyY2VDb3VudHMgPSB7fTtcbiAgICAgICAgdGhpcy5fcmVsZWFzZSA9IHRoaXMuX3JlbGVhc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbG9nID0gbG9nO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZSBhbmQgaWRsZSByZXNvdXJjZSBmb20gdGhlIHBvb2wgb3IgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNxdWlzaXRpb25Db250ZXh0IHRoZSBhY3F1aXNpdGlvbiBjb250ZXh0IHVzZWQgZm9yIGNyZWF0ZSBhbmQgdmFsaWRhdGVPbkFjcXVpcmUgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzcyB0aGUgYWRkcmVzcyBmb3Igd2hpY2ggd2UncmUgYWNxdWlyaW5nLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgdGhlIGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLnJlcXVpcmVOZXcgSW5kaWNhdGUgaXQgcmVxdWlyZXMgYSBuZXcgcmVzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59IHJlc291cmNlIHRoYXQgaXMgcmVhZHkgdG8gdXNlLlxuICAgICAqL1xuICAgIFBvb2wucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAoYWNxdWlzaXRpb25Db250ZXh0LCBhZGRyZXNzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleSwgYWxsUmVxdWVzdHMsIHJlcXVlc3RzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGFkZHJlc3MuYXNLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFJlcXVlc3RzID0gdGhpcy5fYWNxdWlyZVJlcXVlc3RzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHMgPSBhbGxSZXF1ZXN0c1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxSZXF1ZXN0c1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjcXVpc2l0aW9uIHRpbWVvdXQgZmlyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZXF1ZXN0IGZyb20gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgcmVxdWVzdHMsIGlmIGl0J3Mgc3RpbGwgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgbWlnaHQndmUgYmVlbiB0YWtlbiBvdXQgYnkgdGhlIHJlbGVhc2Ugb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVuZGluZ1JlcXVlc3RzID0gYWxsUmVxdWVzdHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nUmVxdWVzdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFJlcXVlc3RzW2tleV0gPSBwZW5kaW5nUmVxdWVzdHMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtICE9PSByZXF1ZXN0OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGFscmVhZHkgcmVzb2x2ZWQvcmVqZWN0ZWQgYnkgdGhlIHJlbGVhc2Ugb3BlcmF0aW9uOyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGlzIHN0aWxsIHBlbmRpbmcgYW5kIG5lZWRzIHRvIGJlIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVDb3VudCA9IF90aGlzLmFjdGl2ZVJlc291cmNlQ291bnQoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkbGVDb3VudCA9IF90aGlzLmhhcyhhZGRyZXNzKSA/IF90aGlzLl9wb29sc1trZXldLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZWplY3QoKDAsIGVycm9yXzEubmV3RXJyb3IpKFwiQ29ubmVjdGlvbiBhY3F1aXNpdGlvbiB0aW1lZCBvdXQgaW4gXCIuY29uY2F0KF90aGlzLl9hY3F1aXNpdGlvblRpbWVvdXQsIFwiIG1zLiBQb29sIHN0YXR1czogQWN0aXZlIGNvbm4gY291bnQgPSBcIikuY29uY2F0KGFjdGl2ZUNvdW50LCBcIiwgSWRsZSBjb25uIGNvdW50ID0gXCIpLmNvbmNhdChpZGxlQ291bnQsIFwiLlwiKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5fYWNxdWlzaXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0SWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZC51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFBlbmRpbmdSZXF1ZXN0KGtleSwgYWNxdWlzaXRpb25Db250ZXh0LCBjb25maWcsIHJlc29sdmUsIHJlamVjdCwgdGltZW91dElkLCBfdGhpcy5fbG9nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsUmVxdWVzdHNba2V5XS5wdXNoKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvY2Vzc1BlbmRpbmdBY3F1aXJlUmVxdWVzdHMoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYWxsIGlkbGUgcmVzb3VyY2VzIGZvciB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ge1NlcnZlckFkZHJlc3N9IGFkZHJlc3MgdGhlIGFkZHJlc3Mgb2YgdGhlIHNlcnZlciB0byBwdXJnZSBpdHMgcG9vbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgcmVzb3VyY2VzIGFyZSBwdXJnZWRcbiAgICAgKi9cbiAgICBQb29sLnByb3RvdHlwZS5wdXJnZSA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcHVyZ2VLZXkoYWRkcmVzcy5hc0tleSgpKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9vbC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoYWRkcmVzcywgcmVzb3VyY2VDb25zdW1lcikge1xuICAgICAgICB2YXIga2V5ID0gYWRkcmVzcy5hc0tleSgpO1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX3Bvb2xzKSB7XG4gICAgICAgICAgICB0aGlzLl9wb29sc1trZXldLmFwcGx5KHJlc291cmNlQ29uc3VtZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFsbCBpZGxlIHJlc291cmNlcyBpbiB0aGlzIHBvb2wuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHJlc291cmNlcyBhcmUgcHVyZ2VkXG4gICAgICovXG4gICAgUG9vbC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGhpcy5fcG9vbHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9wdXJnZUtleShrZXkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7IH0pKS50aGVuKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IFxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIGxhY2sgb2YgUHJvbWlzZSBjb25zdW1pbmcgd2FzIG1ha2luZyB0aGUgZHJpdmVyIGRvIG5vdCBjbG9zZSBwcm9wZXJseSBpbiB0aGUgc2NlbmFyaW9cbiAgICAgICAgICAgICAgICAgICAgICogY2FwdHVyZWQgYXQgcmVzdWx0LnRlc3QuanM6aXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyBvbkNvbXBsZXRlZCcpLiBUaGUgdGVzdCB3YXMgdGltaW5nIG91dFxuICAgICAgICAgICAgICAgICAgICAgKiBiZWNhdXNlIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBkcml2ZXIgY2xvc2UuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIENvbnN1bWluZyB0aGUgUHJvbWlzZS5hbGwgb3IgYnkgY2FsbGluZyB0aGVuIG9yIGJ5IGF3YWl0aW5nIGluIHRoZSByZXN1bHQgaW5zaWRlIHRoaXMgbWV0aG9kIHNvbHZlZFxuICAgICAgICAgICAgICAgICAgICAgKiB0aGUgaXNzdWUgc29tZWhvdy5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogUFM6IHRoZSByZXR1cm4gb2YgdGhpcyBtZXRob2Qgd2FzIGFscmVhZHkgYXdhaXRlZCBhdCBQb29sZWRDb25uZWN0aW9uUHJvdmlkZXIuY2xvc2UsIGJ1dCB0aGUgYXdhaXQgYmVsbG93XG4gICAgICAgICAgICAgICAgICAgICAqIHNlZW1zIHRvIGJlIG5lZWQgYWxzby5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEtlZXAgdGhlIGlkbGUgcmVzb3VyY2VzIGZvciB0aGUgcHJvdmlkZWQgYWRkcmVzc2VzIGFuZCBwdXJnZSB0aGUgcmVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgb3RoZXIgcmVzb3VyY2VzIGFyZSBwdXJnZWRcbiAgICAgKi9cbiAgICBQb29sLnByb3RvdHlwZS5rZWVwQWxsID0gZnVuY3Rpb24gKGFkZHJlc3Nlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIga2V5c1RvS2VlcCwga2V5c1ByZXNlbnQsIGtleXNUb1B1cmdlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXNUb0tlZXAgPSBhZGRyZXNzZXMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmFzS2V5KCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5c1ByZXNlbnQgPSBPYmplY3Qua2V5cyh0aGlzLl9wb29scyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzVG9QdXJnZSA9IGtleXNQcmVzZW50LmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gIWtleXNUb0tlZXAuaW5jbHVkZXMoayk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwoa2V5c1RvUHVyZ2UubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3B1cmdlS2V5KGtleSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSkpLnRoZW4oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBwb29sIGNvbnRhaW5zIHJlc291cmNlcyBmb3IgdGhlIGdpdmVuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtTZXJ2ZXJBZGRyZXNzfSBhZGRyZXNzIHRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXIgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gcG9vbCBjb250YWlucyBlbnRyaWVzIGZvciB0aGUgZ2l2ZW4ga2V5LCA8Y29kZT5mYWxzZTwvY29kZT4gb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIFBvb2wucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLmFzS2V5KCkgaW4gdGhpcy5fcG9vbHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgY291bnQgb2YgYWN0aXZlIChjaGVja2VkIG91dCBvZiB0aGUgcG9vbCkgcmVzb3VyY2VzIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSB7U2VydmVyQWRkcmVzc30gYWRkcmVzcyB0aGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gY291bnQgb2YgcmVzb3VyY2VzIGFjcXVpcmVkIGJ5IGNsaWVudHMuXG4gICAgICovXG4gICAgUG9vbC5wcm90b3R5cGUuYWN0aXZlUmVzb3VyY2VDb3VudCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzW2FkZHJlc3MuYXNLZXkoKV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgfTtcbiAgICBQb29sLnByb3RvdHlwZS5fZ2V0T3JJbml0aWFsaXplUG9vbEZvciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHBvb2wgPSB0aGlzLl9wb29sc1trZXldO1xuICAgICAgICBpZiAocG9vbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwb29sID0gbmV3IFNpbmdsZUFkZHJlc3NQb29sKCk7XG4gICAgICAgICAgICB0aGlzLl9wb29sc1trZXldID0gcG9vbDtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDcmVhdGVzW2tleV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb29sO1xuICAgIH07XG4gICAgUG9vbC5wcm90b3R5cGUuX2FjcXVpcmUgPSBmdW5jdGlvbiAoYWNxdWlzaXRpb25Db250ZXh0LCBhZGRyZXNzLCByZXF1aXJlTmV3KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBrZXksIHBvb2wsIHJlc291cmNlXzEsIHZhbGlkLCBlXzEsIG51bUNvbm5lY3Rpb25zLCByZXNvdXJjZSwgbnVtQ29ubmVjdGlvbnMsIHJlc291cmNlXzI7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnUG9vbCBpcyBjbG9zZWQsIGl0IGlzIG5vIG1vcmUgYWJsZSB0byBzZXJ2ZSByZXF1ZXN0cy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGFkZHJlc3MuYXNLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2wgPSB0aGlzLl9nZXRPckluaXRpYWxpemVQb29sRm9yKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFyZXF1aXJlTmV3KSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHBvb2wubGVuZ3RoID4gMCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlXzEgPSBwb29sLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc291cmNlXzEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VBY3F1aXJlZChrZXksIHRoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmVJZGxlT2JzZXJ2ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUlkbGVPYnNlcnZlcihyZXNvdXJjZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgNCwgLCA2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl92YWxpZGF0ZU9uQWNxdWlyZShhY3F1aXNpdGlvbkNvbnRleHQsIHJlc291cmNlXzEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VSZWxlYXNlZChrZXksIHRoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2wucmVtb3ZlSW5Vc2UocmVzb3VyY2VfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9kZXN0cm95KHJlc291cmNlXzEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkbGUgcmVzb3VyY2UgaXMgdmFsaWQgYW5kIGNhbiBiZSBhY3F1aXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvZy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIlwiLmNvbmNhdChyZXNvdXJjZV8xLCBcIiBhY3F1aXJlZCBmcm9tIHRoZSBwb29sIFwiKS5jb25jYXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyByZXNvdXJjZTogcmVzb3VyY2VfMSwgcG9vbDogcG9vbCB9XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VSZWxlYXNlZChrZXksIHRoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2wucmVtb3ZlSW5Vc2UocmVzb3VyY2VfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9kZXN0cm95KHJlc291cmNlXzEpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA5O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHJlcXVlc3RlZCBtYXggcG9vbCBzaXplXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF4U2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Db25uZWN0aW9ucyA9IHRoaXMuYWN0aXZlUmVzb3VyY2VDb3VudChhZGRyZXNzKSArIHRoaXMuX3BlbmRpbmdDcmVhdGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bUNvbm5lY3Rpb25zID49IHRoaXMuX21heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2lsbCBwdXQgdGhpcyByZXF1ZXN0IGluIHF1ZXVlIGluc3RlYWQgc2luY2UgdGhlIHBvb2wgaXMgZnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgeyByZXNvdXJjZTogbnVsbCwgcG9vbDogcG9vbCB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBleGlzdCBubyBpZGxlIHZhbGlkIHJlc291cmNlcywgY3JlYXRlIGEgbmV3IG9uZSBmb3IgYWNxdWlzaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgaG93IG1hbnkgcGVuZGluZyBjcmVhdGVzIHRoZXJlIGFyZSB0byBhdm9pZCBtYWtpbmcgdG9vIG1hbnkgY29ubmVjdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ3JlYXRlc1trZXldID0gdGhpcy5fcGVuZGluZ0NyZWF0ZXNba2V5XSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDExO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxMSwgLCAxNSwgMTZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bUNvbm5lY3Rpb25zID0gdGhpcy5hY3RpdmVSZXNvdXJjZUNvdW50KGFkZHJlc3MpICsgcG9vbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShudW1Db25uZWN0aW9ucyA+PSB0aGlzLl9tYXhTaXplICYmIHJlcXVpcmVOZXcpKSByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZV8yID0gcG9vbC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc291cmNlXzIgIT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmVJZGxlT2JzZXJ2ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUlkbGVPYnNlcnZlcihyZXNvdXJjZV8yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2wucmVtb3ZlSW5Vc2UocmVzb3VyY2VfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9kZXN0cm95KHJlc291cmNlXzIpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2NyZWF0ZShhY3F1aXNpdGlvbkNvbnRleHQsIGFkZHJlc3MsIGZ1bmN0aW9uIChhZGRyZXNzLCByZXNvdXJjZSkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3JlbGVhc2UoYWRkcmVzcywgcmVzb3VyY2UsIHBvb2wpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludm9rZSBjYWxsYmFjayB0aGF0IGNyZWF0ZXMgYWN0dWFsIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9vbC5wdXNoSW5Vc2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VBY3F1aXJlZChrZXksIHRoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQocmVzb3VyY2UsIFwiIGNyZWF0ZWQgZm9yIHRoZSBwb29sIFwiKS5jb25jYXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ3JlYXRlc1trZXldID0gdGhpcy5fcGVuZGluZ0NyZWF0ZXNba2V5XSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzIgLypyZXR1cm4qLywgeyByZXNvdXJjZTogcmVzb3VyY2UsIHBvb2w6IHBvb2wgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9vbC5wcm90b3R5cGUuX3JlbGVhc2UgPSBmdW5jdGlvbiAoYWRkcmVzcywgcmVzb3VyY2UsIHBvb2wpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBhZGRyZXNzLmFzS2V5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgLCA5LCAxMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb29sLmlzQWN0aXZlKCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fdmFsaWRhdGVPblJlbGVhc2UocmVzb3VyY2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhKF9hLnNlbnQoKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvZy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLmNvbmNhdChyZXNvdXJjZSwgXCIgZGVzdHJveWVkIGFuZCBjYW4ndCBiZSByZWxlYXNlZCB0byB0aGUgcG9vbCBcIikuY29uY2F0KGtleSwgXCIgYmVjYXVzZSBpdCBpcyBub3QgZnVuY3Rpb25hbFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb29sLnJlbW92ZUluVXNlKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2Rlc3Ryb3kocmVzb3VyY2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YWxsSWRsZU9ic2VydmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YWxsSWRsZU9ic2VydmVyKHJlc291cmNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWRsZSBjb25uZWN0aW9uIFwiLmNvbmNhdChyZXNvdXJjZSwgXCIgZGVzdHJveWVkIGJlY2F1c2Ugb2YgZXJyb3I6IFwiKS5jb25jYXQoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb29sID0gX3RoaXMuX3Bvb2xzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9vbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Bvb2xzW2tleV0gPSBwb29sLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gciAhPT0gcmVzb3VyY2U7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvb2wucmVtb3ZlSW5Vc2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3Mgbm90IGNhcmUgYWJvdXQgYmFja2dyb3VuZCBjbGVhbi11cHMgZHVlIHRvIGVycm9ycyBidXQganVzdCB0cmlnZ2VyIHRoZSBkZXN0cm95XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIGZvciB0aGUgcmVzb3VyY2UsIHdlIGVzcGVjaWFsbHkgY2F0Y2ggYW55IGVycm9ycyBhbmQgaWdub3JlIHRoZW0gdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbiB3YXJuaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rlc3Ryb3kocmVzb3VyY2UpLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvb2wucHVzaChyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHJlc291cmNlLCBcIiByZWxlYXNlZCB0byB0aGUgcG9vbCBcIikuY29uY2F0KGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXkgaGFzIGJlZW4gcHVyZ2VkLCBkb24ndCBwdXQgaXQgYmFjaywganVzdCBkZXN0cm95IHRoZSByZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvZy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiLmNvbmNhdChyZXNvdXJjZSwgXCIgZGVzdHJveWVkIGFuZCBjYW4ndCBiZSByZWxlYXNlZCB0byB0aGUgcG9vbCBcIikuY29uY2F0KGtleSwgXCIgYmVjYXVzZSBwb29sIGhhcyBiZWVuIHB1cmdlZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb29sLnJlbW92ZUluVXNlKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2Rlc3Ryb3kocmVzb3VyY2UpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VSZWxlYXNlZChrZXksIHRoaXMuX2FjdGl2ZVJlc291cmNlQ291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NQZW5kaW5nQWNxdWlyZVJlcXVlc3RzKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvb2wucHJvdG90eXBlLl9wdXJnZUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBvb2wsIGRlc3RydWN0aW9uTGlzdCwgcmVzb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb29sID0gdGhpcy5fcG9vbHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RydWN0aW9uTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocG9vbCAhPSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9vbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSBwb29sLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVtb3ZlSWRsZU9ic2VydmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSWRsZU9ic2VydmVyKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJ1Y3Rpb25MaXN0LnB1c2godGhpcy5fZGVzdHJveShyZXNvdXJjZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9vbC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Bvb2xzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChkZXN0cnVjdGlvbkxpc3QpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb29sLnByb3RvdHlwZS5fcHJvY2Vzc1BlbmRpbmdBY3F1aXJlUmVxdWVzdHMgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIga2V5ID0gYWRkcmVzcy5hc0tleSgpO1xuICAgICAgICB2YXIgcmVxdWVzdHMgPSB0aGlzLl9hY3F1aXJlUmVxdWVzdHNba2V5XTtcbiAgICAgICAgaWYgKHJlcXVlc3RzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwZW5kaW5nUmVxdWVzdF8xID0gcmVxdWVzdHMuc2hpZnQoKTsgLy8gcG9wIGEgcGVuZGluZyBhY3F1aXJlIHJlcXVlc3RcbiAgICAgICAgICAgIGlmIChwZW5kaW5nUmVxdWVzdF8xICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3F1aXJlKHBlbmRpbmdSZXF1ZXN0XzEuY29udGV4dCwgYWRkcmVzcywgcGVuZGluZ1JlcXVlc3RfMS5yZXF1aXJlTmV3KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWxlZCB0byBhY3F1aXJlL2NyZWF0ZSBhIG5ldyBjb25uZWN0aW9uIHRvIHJlc29sdmUgdGhlIHBlbmRpbmcgYWNxdWlyZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSB0aGUgZXJyb3IgYnkgZmFpbGluZyB0aGUgcGVuZGluZyByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0XzEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzb3VyY2U6IG51bGwsIHBvb2w6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gX2EucmVzb3VyY2UsIHBvb2wgPSBfYS5wb29sO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBub3Qgc2l0dWF0aW9uIHdoZXJlIHRoZSBwb29sIHJlc291cmNlIGlzIG5vdCBudWxsIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9vbCBpcyBudWxsLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb3VyY2UgIT0gbnVsbCAmJiBwb29sICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbmFnZWQgdG8gYWNxdWlyZSBhIHZhbGlkIHJlc291cmNlIGZyb20gdGhlIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nUmVxdWVzdF8xLmlzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGhhcyBiZWVuIGNvbXBsZXRlZCwgbW9zdCBsaWtlbHkgZmFpbGVkIGJ5IGEgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgYWNxdWlyZWQgcmVzb3VyY2UgYmFjayB0byB0aGUgcG9vbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWxlYXNlKGFkZHJlc3MsIHJlc291cmNlLCBwb29sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fbG9nLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoXCJcIi5jb25jYXQocmVzb3VyY2UsIFwiIGNvdWxkIG5vdCBiZSByZWxlYXNlIGJhY2sgdG8gdGhlIHBvb2wuIENhdXNlOiBcIikuY29uY2F0KGVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgaXMgc3RpbGwgcGVuZGluZyBhbmQgY2FuIGJlIHJlc29sdmVkIHdpdGggdGhlIG5ld2x5IGFjcXVpcmVkIHJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3RfMS5yZXNvbHZlKHJlc291cmNlKTsgLy8gcmVzb2x2ZSB0aGUgcGVuZGluZyByZXF1ZXN0IHdpdGggdGhlIGFjcXVpcmVkIHJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgdG8gYWNxdWlyZSBhIHZhbGlkIHJlc291cmNlIGZyb20gdGhlIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcGVuZGluZyByZXF1ZXN0IGJhY2sgdG8gdGhlIHBvb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ1JlcXVlc3RfMS5pc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9hY3F1aXJlUmVxdWVzdHNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hY3F1aXJlUmVxdWVzdHNba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWNxdWlyZVJlcXVlc3RzW2tleV0udW5zaGlmdChwZW5kaW5nUmVxdWVzdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gcGVuZGluZ1JlcXVlc3RfMS5yZWplY3QoZXJyb3IpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYWNxdWlyZVJlcXVlc3RzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQb29sO1xufSgpKTtcbi8qKlxuICogSW5jcmVtZW50IGFjdGl2ZSAoY2hlY2tlZCBvdXQgb2YgdGhlIHBvb2wpIHJlc291cmNlIGNvdW50ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRoZSByZXNvdXJjZSBncm91cCBpZGVudGlmaWVyIChzZXJ2ZXIgYWRkcmVzcyBmb3IgY29ubmVjdGlvbnMpLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gYWN0aXZlUmVzb3VyY2VDb3VudHMgdGhlIG9iamVjdCBob2xkaW5nIGFjdGl2ZSBjb3VudHMgcGVyIGtleS5cbiAqL1xuZnVuY3Rpb24gcmVzb3VyY2VBY3F1aXJlZChrZXksIGFjdGl2ZVJlc291cmNlQ291bnRzKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBjdXJyZW50Q291bnQgPSAoX2EgPSBhY3RpdmVSZXNvdXJjZUNvdW50c1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgIGFjdGl2ZVJlc291cmNlQ291bnRzW2tleV0gPSBjdXJyZW50Q291bnQgKyAxO1xufVxuLyoqXG4gKiBEZWNyZW1lbnQgYWN0aXZlIChjaGVja2VkIG91dCBvZiB0aGUgcG9vbCkgcmVzb3VyY2UgY291bnRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIHJlc291cmNlIGdyb3VwIGlkZW50aWZpZXIgKHNlcnZlciBhZGRyZXNzIGZvciBjb25uZWN0aW9ucykuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBhY3RpdmVSZXNvdXJjZUNvdW50cyB0aGUgb2JqZWN0IGhvbGRpbmcgYWN0aXZlIGNvdW50cyBwZXIga2V5LlxuICovXG5mdW5jdGlvbiByZXNvdXJjZVJlbGVhc2VkKGtleSwgYWN0aXZlUmVzb3VyY2VDb3VudHMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGN1cnJlbnRDb3VudCA9IChfYSA9IGFjdGl2ZVJlc291cmNlQ291bnRzW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgdmFyIG5leHRDb3VudCA9IGN1cnJlbnRDb3VudCAtIDE7XG4gICAgaWYgKG5leHRDb3VudCA+IDApIHtcbiAgICAgICAgYWN0aXZlUmVzb3VyY2VDb3VudHNba2V5XSA9IG5leHRDb3VudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgZGVsZXRlIGFjdGl2ZVJlc291cmNlQ291bnRzW2tleV07XG4gICAgfVxufVxudmFyIFBlbmRpbmdSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlbmRpbmdSZXF1ZXN0KGtleSwgY29udGV4dCwgY29uZmlnLCByZXNvbHZlLCByZWplY3QsIHRpbWVvdXRJZCwgbG9nKSB7XG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHRpbWVvdXRJZDtcbiAgICAgICAgdGhpcy5fbG9nID0gbG9nO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnICE9PSBudWxsICYmIGNvbmZpZyAhPT0gdm9pZCAwID8gY29uZmlnIDoge307XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQZW5kaW5nUmVxdWVzdC5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGVuZGluZ1JlcXVlc3QucHJvdG90eXBlLCBcInJlcXVpcmVOZXdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9jb25maWcucmVxdWlyZU5ldykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQZW5kaW5nUmVxdWVzdC5wcm90b3R5cGUuaXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wbGV0ZWQ7XG4gICAgfTtcbiAgICBQZW5kaW5nUmVxdWVzdC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5fY29tcGxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG4gICAgICAgIGlmICh0aGlzLl9sb2cuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiXCIuY29uY2F0KHJlc291cmNlLCBcIiBhY3F1aXJlZCBmcm9tIHRoZSBwb29sIFwiKS5jb25jYXQodGhpcy5fa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzb2x2ZShyZXNvdXJjZSk7XG4gICAgfTtcbiAgICBQZW5kaW5nUmVxdWVzdC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dElkKTtcbiAgICAgICAgdGhpcy5fcmVqZWN0KGVycm9yKTtcbiAgICB9O1xuICAgIHJldHVybiBQZW5kaW5nUmVxdWVzdDtcbn0oKSk7XG52YXIgU2luZ2xlQWRkcmVzc1Bvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2luZ2xlQWRkcmVzc1Bvb2woKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzSW5Vc2UgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIFNpbmdsZUFkZHJlc3NQb29sLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9O1xuICAgIFNpbmdsZUFkZHJlc3NQb29sLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzSW5Vc2UgPSBuZXcgU2V0KCk7XG4gICAgfTtcbiAgICBTaW5nbGVBZGRyZXNzUG9vbC5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLmZpbHRlcihwcmVkaWNhdGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNpbmdsZUFkZHJlc3NQb29sLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChyZXNvdXJjZUNvbnN1bWVyKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLmZvckVhY2gocmVzb3VyY2VDb25zdW1lcik7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzSW5Vc2UuZm9yRWFjaChyZXNvdXJjZUNvbnN1bWVyKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW5nbGVBZGRyZXNzUG9vbC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2luZ2xlQWRkcmVzc1Bvb2wucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50cy5wb3AoKTtcbiAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHNJblVzZS5hZGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgICBTaW5nbGVBZGRyZXNzUG9vbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzSW5Vc2UuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICB9O1xuICAgIFNpbmdsZUFkZHJlc3NQb29sLnByb3RvdHlwZS5wdXNoSW5Vc2UgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50c0luVXNlLmFkZChlbGVtZW50KTtcbiAgICB9O1xuICAgIFNpbmdsZUFkZHJlc3NQb29sLnByb3RvdHlwZS5yZW1vdmVJblVzZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzSW5Vc2UuZGVsZXRlKGVsZW1lbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIFNpbmdsZUFkZHJlc3NQb29sO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBvb2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/pool/pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/query-executor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/query-executor.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/constants.js\");\nvar QueryExecutor = /** @class */ (function () {\n    function QueryExecutor(_createSession) {\n        this._createSession = _createSession;\n    }\n    QueryExecutor.prototype.execute = function (config, query, parameters) {\n        return __awaiter(this, void 0, void 0, function () {\n            var session, listenerHandle, executeInTransaction;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        session = this._createSession({\n                            database: config.database,\n                            bookmarkManager: config.bookmarkManager,\n                            impersonatedUser: config.impersonatedUser,\n                            auth: config.auth\n                        });\n                        listenerHandle = installEventListenerWhenPossible(\n                        // Solving linter and types definitions issue\n                        config.signal, 'abort', function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0: return [4 /*yield*/, session.close()];\n                                case 1: return [2 /*return*/, _a.sent()];\n                            }\n                        }); }); });\n                        // @ts-expect-error The method is private for external users\n                        session._configureTransactionExecutor(true, constants_1.TELEMETRY_APIS.EXECUTE_QUERY);\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, , 3, 5]);\n                        executeInTransaction = config.routing === 'READ'\n                            ? session.executeRead.bind(session)\n                            : session.executeWrite.bind(session);\n                        return [4 /*yield*/, executeInTransaction(function (tx) { return __awaiter(_this, void 0, void 0, function () {\n                                var result;\n                                return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0:\n                                            result = tx.run(query, parameters);\n                                            return [4 /*yield*/, config.resultTransformer(result)];\n                                        case 1: return [2 /*return*/, _a.sent()];\n                                    }\n                                });\n                            }); }, config.transactionConfig)];\n                    case 2: return [2 /*return*/, _a.sent()];\n                    case 3:\n                        listenerHandle.uninstall();\n                        return [4 /*yield*/, session.close()];\n                    case 4:\n                        _a.sent();\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return QueryExecutor;\n}());\nexports[\"default\"] = QueryExecutor;\nfunction installEventListenerWhenPossible(target, event, listener) {\n    if (typeof (target === null || target === void 0 ? void 0 : target.addEventListener) === 'function') {\n        target.addEventListener(event, listener);\n    }\n    return {\n        uninstall: function () {\n            if (typeof (target === null || target === void 0 ? void 0 : target.removeEventListener) === 'function') {\n                target.removeEventListener(event, listener);\n            }\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3F1ZXJ5LWV4ZWN1dG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw4REFBOEQsc0RBQXNEO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvcXVlcnktZXhlY3V0b3IuanM/MTA3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgUXVlcnlFeGVjdXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeUV4ZWN1dG9yKF9jcmVhdGVTZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVNlc3Npb24gPSBfY3JlYXRlU2Vzc2lvbjtcbiAgICB9XG4gICAgUXVlcnlFeGVjdXRvci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChjb25maWcsIHF1ZXJ5LCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZXNzaW9uLCBsaXN0ZW5lckhhbmRsZSwgZXhlY3V0ZUluVHJhbnNhY3Rpb247XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbiA9IHRoaXMuX2NyZWF0ZVNlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9va21hcmtNYW5hZ2VyOiBjb25maWcuYm9va21hcmtNYW5hZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcGVyc29uYXRlZFVzZXI6IGNvbmZpZy5pbXBlcnNvbmF0ZWRVc2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGg6IGNvbmZpZy5hdXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVySGFuZGxlID0gaW5zdGFsbEV2ZW50TGlzdGVuZXJXaGVuUG9zc2libGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb2x2aW5nIGxpbnRlciBhbmQgdHlwZXMgZGVmaW5pdGlvbnMgaXNzdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zaWduYWwsICdhYm9ydCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBzZXNzaW9uLmNsb3NlKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoZSBtZXRob2QgaXMgcHJpdmF0ZSBmb3IgZXh0ZXJuYWwgdXNlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24uX2NvbmZpZ3VyZVRyYW5zYWN0aW9uRXhlY3V0b3IodHJ1ZSwgY29uc3RhbnRzXzEuVEVMRU1FVFJZX0FQSVMuRVhFQ1VURV9RVUVSWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgLCAzLCA1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlSW5UcmFuc2FjdGlvbiA9IGNvbmZpZy5yb3V0aW5nID09PSAnUkVBRCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlc3Npb24uZXhlY3V0ZVJlYWQuYmluZChzZXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2Vzc2lvbi5leGVjdXRlV3JpdGUuYmluZChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGVJblRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0eCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0eC5ydW4ocXVlcnksIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb25maWcucmVzdWx0VHJhbnNmb3JtZXIocmVzdWx0KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIGNvbmZpZy50cmFuc2FjdGlvbkNvbmZpZyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckhhbmRsZS51bmluc3RhbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlc3Npb24uY2xvc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBRdWVyeUV4ZWN1dG9yO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5RXhlY3V0b3I7XG5mdW5jdGlvbiBpbnN0YWxsRXZlbnRMaXN0ZW5lcldoZW5Qb3NzaWJsZSh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgKHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/query-executor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/base-host-name-resolver.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/resolver/base-host-name-resolver.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable @typescript-eslint/promise-function-async */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar BaseHostNameResolver = /** @class */ (function () {\n    function BaseHostNameResolver() {\n    }\n    BaseHostNameResolver.prototype.resolve = function () {\n        throw new Error('Abstract function');\n    };\n    /**\n     * @protected\n     */\n    BaseHostNameResolver.prototype._resolveToItself = function (address) {\n        return Promise.resolve([address]);\n    };\n    return BaseHostNameResolver;\n}());\nexports[\"default\"] = BaseHostNameResolver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Jlc29sdmVyL2Jhc2UtaG9zdC1uYW1lLXJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Jlc29sdmVyL2Jhc2UtaG9zdC1uYW1lLXJlc29sdmVyLmpzPzY0MTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCYXNlSG9zdE5hbWVSZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlSG9zdE5hbWVSZXNvbHZlcigpIHtcbiAgICB9XG4gICAgQmFzZUhvc3ROYW1lUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWJzdHJhY3QgZnVuY3Rpb24nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBCYXNlSG9zdE5hbWVSZXNvbHZlci5wcm90b3R5cGUuX3Jlc29sdmVUb0l0c2VsZiA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW2FkZHJlc3NdKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlSG9zdE5hbWVSZXNvbHZlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlSG9zdE5hbWVSZXNvbHZlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/base-host-name-resolver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/configured-custom-resolver.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/resolver/configured-custom-resolver.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar server_address_1 = __webpack_require__(/*! ../server-address */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/server-address.js\");\nfunction resolveToSelf(address) {\n    return Promise.resolve([address]);\n}\nvar ConfiguredCustomResolver = /** @class */ (function () {\n    function ConfiguredCustomResolver(resolverFunction) {\n        this._resolverFunction = resolverFunction !== null && resolverFunction !== void 0 ? resolverFunction : resolveToSelf;\n    }\n    ConfiguredCustomResolver.prototype.resolve = function (seedRouter) {\n        var _this = this;\n        return new Promise(function (resolve) {\n            return resolve(_this._resolverFunction(seedRouter.asHostPort()));\n        }).then(function (resolved) {\n            if (!Array.isArray(resolved)) {\n                throw new TypeError('Configured resolver function should either return an array of addresses or a Promise resolved with an array of addresses.' +\n                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                    \"Each address is '<host>:<port>'. Got: \".concat(resolved));\n            }\n            return resolved.map(function (r) { return server_address_1.ServerAddress.fromUrl(r); });\n        });\n    };\n    return ConfiguredCustomResolver;\n}());\nexports[\"default\"] = ConfiguredCustomResolver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Jlc29sdmVyL2NvbmZpZ3VyZWQtY3VzdG9tLXJlc29sdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1EQUFtRDtBQUNsRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Jlc29sdmVyL2NvbmZpZ3VyZWQtY3VzdG9tLXJlc29sdmVyLmpzPzg1NTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbnZhciBzZXJ2ZXJfYWRkcmVzc18xID0gcmVxdWlyZShcIi4uL3NlcnZlci1hZGRyZXNzXCIpO1xuZnVuY3Rpb24gcmVzb2x2ZVRvU2VsZihhZGRyZXNzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbYWRkcmVzc10pO1xufVxudmFyIENvbmZpZ3VyZWRDdXN0b21SZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXIocmVzb2x2ZXJGdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9yZXNvbHZlckZ1bmN0aW9uID0gcmVzb2x2ZXJGdW5jdGlvbiAhPT0gbnVsbCAmJiByZXNvbHZlckZ1bmN0aW9uICE9PSB2b2lkIDAgPyByZXNvbHZlckZ1bmN0aW9uIDogcmVzb2x2ZVRvU2VsZjtcbiAgICB9XG4gICAgQ29uZmlndXJlZEN1c3RvbVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHNlZWRSb3V0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShfdGhpcy5fcmVzb2x2ZXJGdW5jdGlvbihzZWVkUm91dGVyLmFzSG9zdFBvcnQoKSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc29sdmVkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbmZpZ3VyZWQgcmVzb2x2ZXIgZnVuY3Rpb24gc2hvdWxkIGVpdGhlciByZXR1cm4gYW4gYXJyYXkgb2YgYWRkcmVzc2VzIG9yIGEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIGFkZHJlc3Nlcy4nICtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICBcIkVhY2ggYWRkcmVzcyBpcyAnPGhvc3Q+Ojxwb3J0PicuIEdvdDogXCIuY29uY2F0KHJlc29sdmVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiBzZXJ2ZXJfYWRkcmVzc18xLlNlcnZlckFkZHJlc3MuZnJvbVVybChyKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmZpZ3VyZWRDdXN0b21SZXNvbHZlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDb25maWd1cmVkQ3VzdG9tUmVzb2x2ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/configured-custom-resolver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/resolver/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConfiguredCustomResolver = exports.BaseHostNameResolver = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar base_host_name_resolver_1 = __importDefault(__webpack_require__(/*! ./base-host-name-resolver */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/base-host-name-resolver.js\"));\nexports.BaseHostNameResolver = base_host_name_resolver_1.default;\nvar configured_custom_resolver_1 = __importDefault(__webpack_require__(/*! ./configured-custom-resolver */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/configured-custom-resolver.js\"));\nexports.ConfiguredCustomResolver = configured_custom_resolver_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3Jlc29sdmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG1CQUFPLENBQUMsMEhBQTJCO0FBQ25GLDRCQUE0QjtBQUM1QixtREFBbUQsbUJBQU8sQ0FBQyxnSUFBOEI7QUFDekYsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvcmVzb2x2ZXIvaW5kZXguanM/NDcwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uZmlndXJlZEN1c3RvbVJlc29sdmVyID0gZXhwb3J0cy5CYXNlSG9zdE5hbWVSZXNvbHZlciA9IHZvaWQgMDtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgYmFzZV9ob3N0X25hbWVfcmVzb2x2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlLWhvc3QtbmFtZS1yZXNvbHZlclwiKSk7XG5leHBvcnRzLkJhc2VIb3N0TmFtZVJlc29sdmVyID0gYmFzZV9ob3N0X25hbWVfcmVzb2x2ZXJfMS5kZWZhdWx0O1xudmFyIGNvbmZpZ3VyZWRfY3VzdG9tX3Jlc29sdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29uZmlndXJlZC1jdXN0b20tcmVzb2x2ZXJcIikpO1xuZXhwb3J0cy5Db25maWd1cmVkQ3VzdG9tUmVzb2x2ZXIgPSBjb25maWd1cmVkX2N1c3RvbV9yZXNvbHZlcl8xLmRlZmF1bHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/resolver/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/server-address.js":
/*!***********************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/server-address.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerAddress = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\nvar urlUtil = __importStar(__webpack_require__(/*! ./url-util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/url-util.js\"));\nvar ServerAddress = /** @class */ (function () {\n    function ServerAddress(host, resolved, port, hostPort) {\n        this._host = (0, util_1.assertString)(host, 'host');\n        this._resolved = resolved != null ? (0, util_1.assertString)(resolved, 'resolved') : null;\n        this._port = (0, util_1.assertNumber)(port, 'port');\n        this._hostPort = hostPort;\n        this._stringValue = resolved != null ? \"\".concat(hostPort, \"(\").concat(resolved, \")\") : \"\".concat(hostPort);\n    }\n    ServerAddress.prototype.host = function () {\n        return this._host;\n    };\n    ServerAddress.prototype.resolvedHost = function () {\n        return this._resolved != null ? this._resolved : this._host;\n    };\n    ServerAddress.prototype.port = function () {\n        return this._port;\n    };\n    ServerAddress.prototype.resolveWith = function (resolved) {\n        return new ServerAddress(this._host, resolved, this._port, this._hostPort);\n    };\n    ServerAddress.prototype.asHostPort = function () {\n        return this._hostPort;\n    };\n    ServerAddress.prototype.asKey = function () {\n        return this._hostPort;\n    };\n    ServerAddress.prototype.toString = function () {\n        return this._stringValue;\n    };\n    ServerAddress.fromUrl = function (url) {\n        var urlParsed = urlUtil.parseDatabaseUrl(url);\n        return new ServerAddress(urlParsed.host, null, urlParsed.port, urlParsed.hostAndPort);\n    };\n    return ServerAddress;\n}());\nexports.ServerAddress = ServerAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3NlcnZlci1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsMkVBQVE7QUFDN0IsMkJBQTJCLG1CQUFPLENBQUMsbUZBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvc2VydmVyLWFkZHJlc3MuanM/MWVlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJBZGRyZXNzID0gdm9pZCAwO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHVybFV0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXJsLXV0aWxcIikpO1xudmFyIFNlcnZlckFkZHJlc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmVyQWRkcmVzcyhob3N0LCByZXNvbHZlZCwgcG9ydCwgaG9zdFBvcnQpIHtcbiAgICAgICAgdGhpcy5faG9zdCA9ICgwLCB1dGlsXzEuYXNzZXJ0U3RyaW5nKShob3N0LCAnaG9zdCcpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IHJlc29sdmVkICE9IG51bGwgPyAoMCwgdXRpbF8xLmFzc2VydFN0cmluZykocmVzb2x2ZWQsICdyZXNvbHZlZCcpIDogbnVsbDtcbiAgICAgICAgdGhpcy5fcG9ydCA9ICgwLCB1dGlsXzEuYXNzZXJ0TnVtYmVyKShwb3J0LCAncG9ydCcpO1xuICAgICAgICB0aGlzLl9ob3N0UG9ydCA9IGhvc3RQb3J0O1xuICAgICAgICB0aGlzLl9zdHJpbmdWYWx1ZSA9IHJlc29sdmVkICE9IG51bGwgPyBcIlwiLmNvbmNhdChob3N0UG9ydCwgXCIoXCIpLmNvbmNhdChyZXNvbHZlZCwgXCIpXCIpIDogXCJcIi5jb25jYXQoaG9zdFBvcnQpO1xuICAgIH1cbiAgICBTZXJ2ZXJBZGRyZXNzLnByb3RvdHlwZS5ob3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcbiAgICB9O1xuICAgIFNlcnZlckFkZHJlc3MucHJvdG90eXBlLnJlc29sdmVkSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkICE9IG51bGwgPyB0aGlzLl9yZXNvbHZlZCA6IHRoaXMuX2hvc3Q7XG4gICAgfTtcbiAgICBTZXJ2ZXJBZGRyZXNzLnByb3RvdHlwZS5wb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgICB9O1xuICAgIFNlcnZlckFkZHJlc3MucHJvdG90eXBlLnJlc29sdmVXaXRoID0gZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmVyQWRkcmVzcyh0aGlzLl9ob3N0LCByZXNvbHZlZCwgdGhpcy5fcG9ydCwgdGhpcy5faG9zdFBvcnQpO1xuICAgIH07XG4gICAgU2VydmVyQWRkcmVzcy5wcm90b3R5cGUuYXNIb3N0UG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvc3RQb3J0O1xuICAgIH07XG4gICAgU2VydmVyQWRkcmVzcy5wcm90b3R5cGUuYXNLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3N0UG9ydDtcbiAgICB9O1xuICAgIFNlcnZlckFkZHJlc3MucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaW5nVmFsdWU7XG4gICAgfTtcbiAgICBTZXJ2ZXJBZGRyZXNzLmZyb21VcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciB1cmxQYXJzZWQgPSB1cmxVdGlsLnBhcnNlRGF0YWJhc2VVcmwodXJsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJ2ZXJBZGRyZXNzKHVybFBhcnNlZC5ob3N0LCBudWxsLCB1cmxQYXJzZWQucG9ydCwgdXJsUGFyc2VkLmhvc3RBbmRQb3J0KTtcbiAgICB9O1xuICAgIHJldHVybiBTZXJ2ZXJBZGRyZXNzO1xufSgpKTtcbmV4cG9ydHMuU2VydmVyQWRkcmVzcyA9IFNlcnZlckFkZHJlc3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/server-address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/temporal-util.js":
/*!**********************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/temporal-util.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.floorMod = exports.floorDiv = exports.assertValidZoneId = exports.assertValidNanosecond = exports.assertValidSecond = exports.assertValidMinute = exports.assertValidHour = exports.assertValidDay = exports.assertValidMonth = exports.assertValidYear = exports.timeZoneOffsetInSeconds = exports.totalNanoseconds = exports.newDate = exports.toStandardDate = exports.isoStringToStandardDate = exports.dateToIsoString = exports.timeZoneOffsetToIsoString = exports.timeToIsoString = exports.durationToIsoString = exports.dateToEpochDay = exports.localDateTimeToEpochSecond = exports.localTimeToNanoOfDay = exports.normalizeNanosecondsForDuration = exports.normalizeSecondsForDuration = exports.SECONDS_PER_DAY = exports.DAYS_PER_400_YEAR_CYCLE = exports.DAYS_0000_TO_1970 = exports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE = exports.NANOS_PER_MILLISECOND = exports.NANOS_PER_SECOND = exports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE = exports.MINUTES_PER_HOUR = exports.NANOSECOND_OF_SECOND_RANGE = exports.SECOND_OF_MINUTE_RANGE = exports.MINUTE_OF_HOUR_RANGE = exports.HOUR_OF_DAY_RANGE = exports.DAY_OF_MONTH_RANGE = exports.MONTH_OF_YEAR_RANGE = exports.YEAR_RANGE = void 0;\nvar integer_1 = __importStar(__webpack_require__(/*! ../integer */ \"(rsc)/./node_modules/neo4j-driver-core/lib/integer.js\"));\nvar error_1 = __webpack_require__(/*! ../error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\n/*\n  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.\n\n  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived\n  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere\n  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.\n\n  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the\n  conversion functions.\n */\nvar ValueRange = /** @class */ (function () {\n    function ValueRange(min, max) {\n        this._minNumber = min;\n        this._maxNumber = max;\n        this._minInteger = (0, integer_1.int)(min);\n        this._maxInteger = (0, integer_1.int)(max);\n    }\n    ValueRange.prototype.contains = function (value) {\n        if ((0, integer_1.isInt)(value) && value instanceof integer_1.default) {\n            return (value.greaterThanOrEqual(this._minInteger) &&\n                value.lessThanOrEqual(this._maxInteger));\n        }\n        else if (typeof value === 'bigint') {\n            var intValue = (0, integer_1.int)(value);\n            return (intValue.greaterThanOrEqual(this._minInteger) &&\n                intValue.lessThanOrEqual(this._maxInteger));\n        }\n        else {\n            return value >= this._minNumber && value <= this._maxNumber;\n        }\n    };\n    ValueRange.prototype.toString = function () {\n        return \"[\".concat(this._minNumber, \", \").concat(this._maxNumber, \"]\");\n    };\n    return ValueRange;\n}());\nexports.YEAR_RANGE = new ValueRange(-999999999, 999999999);\nexports.MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);\nexports.DAY_OF_MONTH_RANGE = new ValueRange(1, 31);\nexports.HOUR_OF_DAY_RANGE = new ValueRange(0, 23);\nexports.MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);\nexports.SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);\nexports.NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);\nexports.MINUTES_PER_HOUR = 60;\nexports.SECONDS_PER_MINUTE = 60;\nexports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.NANOS_PER_SECOND = 1000000000;\nexports.NANOS_PER_MILLISECOND = 1000000;\nexports.NANOS_PER_MINUTE = exports.NANOS_PER_SECOND * exports.SECONDS_PER_MINUTE;\nexports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.DAYS_0000_TO_1970 = 719528;\nexports.DAYS_PER_400_YEAR_CYCLE = 146097;\nexports.SECONDS_PER_DAY = 86400;\nfunction normalizeSecondsForDuration(seconds, nanoseconds) {\n    return (0, integer_1.int)(seconds).add(floorDiv(nanoseconds, exports.NANOS_PER_SECOND));\n}\nexports.normalizeSecondsForDuration = normalizeSecondsForDuration;\nfunction normalizeNanosecondsForDuration(nanoseconds) {\n    return floorMod(nanoseconds, exports.NANOS_PER_SECOND);\n}\nexports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;\n/**\n * Converts given local time into a single integer representing this same time in nanoseconds of the day.\n * @param {Integer|number|string} hour the hour of the local time to convert.\n * @param {Integer|number|string} minute the minute of the local time to convert.\n * @param {Integer|number|string} second the second of the local time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.\n * @return {Integer} nanoseconds representing the given local time.\n */\nfunction localTimeToNanoOfDay(hour, minute, second, nanosecond) {\n    hour = (0, integer_1.int)(hour);\n    minute = (0, integer_1.int)(minute);\n    second = (0, integer_1.int)(second);\n    nanosecond = (0, integer_1.int)(nanosecond);\n    var totalNanos = hour.multiply(exports.NANOS_PER_HOUR);\n    totalNanos = totalNanos.add(minute.multiply(exports.NANOS_PER_MINUTE));\n    totalNanos = totalNanos.add(second.multiply(exports.NANOS_PER_SECOND));\n    return totalNanos.add(nanosecond);\n}\nexports.localTimeToNanoOfDay = localTimeToNanoOfDay;\n/**\n * Converts given local date time into a single integer representing this same time in epoch seconds UTC.\n * @param {Integer|number|string} year the year of the local date-time to convert.\n * @param {Integer|number|string} month the month of the local date-time to convert.\n * @param {Integer|number|string} day the day of the local date-time to convert.\n * @param {Integer|number|string} hour the hour of the local date-time to convert.\n * @param {Integer|number|string} minute the minute of the local date-time to convert.\n * @param {Integer|number|string} second the second of the local date-time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.\n * @return {Integer} epoch second in UTC representing the given local date time.\n */\nfunction localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {\n    var epochDay = dateToEpochDay(year, month, day);\n    var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);\n    return epochDay.multiply(exports.SECONDS_PER_DAY).add(localTimeSeconds);\n}\nexports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;\n/**\n * Converts given local date into a single integer representing it's epoch day.\n * @param {Integer|number|string} year the year of the local date to convert.\n * @param {Integer|number|string} month the month of the local date to convert.\n * @param {Integer|number|string} day the day of the local date to convert.\n * @return {Integer} epoch day representing the given date.\n */\nfunction dateToEpochDay(year, month, day) {\n    year = (0, integer_1.int)(year);\n    month = (0, integer_1.int)(month);\n    day = (0, integer_1.int)(day);\n    var epochDay = year.multiply(365);\n    if (year.greaterThanOrEqual(0)) {\n        epochDay = epochDay.add(year\n            .add(3)\n            .div(4)\n            .subtract(year.add(99).div(100))\n            .add(year.add(399).div(400)));\n    }\n    else {\n        epochDay = epochDay.subtract(year\n            .div(-4)\n            .subtract(year.div(-100))\n            .add(year.div(-400)));\n    }\n    epochDay = epochDay.add(month\n        .multiply(367)\n        .subtract(362)\n        .div(12));\n    epochDay = epochDay.add(day.subtract(1));\n    if (month.greaterThan(2)) {\n        epochDay = epochDay.subtract(1);\n        if (!isLeapYear(year)) {\n            epochDay = epochDay.subtract(1);\n        }\n    }\n    return epochDay.subtract(exports.DAYS_0000_TO_1970);\n}\nexports.dateToEpochDay = dateToEpochDay;\n/**\n * Format given duration to an ISO 8601 string.\n * @param {Integer|number|string} months the number of months.\n * @param {Integer|number|string} days the number of days.\n * @param {Integer|number|string} seconds the number of seconds.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds.\n * @return {string} ISO string that represents given duration.\n */\nfunction durationToIsoString(months, days, seconds, nanoseconds) {\n    var monthsString = formatNumber(months);\n    var daysString = formatNumber(days);\n    var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);\n    return \"P\".concat(monthsString, \"M\").concat(daysString, \"DT\").concat(secondsAndNanosecondsString, \"S\");\n}\nexports.durationToIsoString = durationToIsoString;\n/**\n * Formats given time to an ISO 8601 string.\n * @param {Integer|number|string} hour the hour value.\n * @param {Integer|number|string} minute the minute value.\n * @param {Integer|number|string} second the second value.\n * @param {Integer|number|string} nanosecond the nanosecond value.\n * @return {string} ISO string that represents given time.\n */\nfunction timeToIsoString(hour, minute, second, nanosecond) {\n    var hourString = formatNumber(hour, 2);\n    var minuteString = formatNumber(minute, 2);\n    var secondString = formatNumber(second, 2);\n    var nanosecondString = formatNanosecond(nanosecond);\n    return \"\".concat(hourString, \":\").concat(minuteString, \":\").concat(secondString).concat(nanosecondString);\n}\nexports.timeToIsoString = timeToIsoString;\n/**\n * Formats given time zone offset in seconds to string representation like 'HH:MM', 'HH:MM:SS' or 'Z' for UTC.\n * @param {Integer|number|string} offsetSeconds the offset in seconds.\n * @return {string} ISO string that represents given offset.\n */\nfunction timeZoneOffsetToIsoString(offsetSeconds) {\n    offsetSeconds = (0, integer_1.int)(offsetSeconds);\n    if (offsetSeconds.equals(0)) {\n        return 'Z';\n    }\n    var isNegative = offsetSeconds.isNegative();\n    if (isNegative) {\n        offsetSeconds = offsetSeconds.multiply(-1);\n    }\n    var signPrefix = isNegative ? '-' : '+';\n    var hours = formatNumber(offsetSeconds.div(exports.SECONDS_PER_HOUR), 2);\n    var minutes = formatNumber(offsetSeconds.div(exports.SECONDS_PER_MINUTE).modulo(exports.MINUTES_PER_HOUR), 2);\n    var secondsValue = offsetSeconds.modulo(exports.SECONDS_PER_MINUTE);\n    var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);\n    return seconds != null\n        ? \"\".concat(signPrefix).concat(hours, \":\").concat(minutes, \":\").concat(seconds)\n        : \"\".concat(signPrefix).concat(hours, \":\").concat(minutes);\n}\nexports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;\n/**\n * Formats given date to an ISO 8601 string.\n * @param {Integer|number|string} year the date year.\n * @param {Integer|number|string} month the date month.\n * @param {Integer|number|string} day the date day.\n * @return {string} ISO string that represents given date.\n */\nfunction dateToIsoString(year, month, day) {\n    var yearString = formatYear(year);\n    var monthString = formatNumber(month, 2);\n    var dayString = formatNumber(day, 2);\n    return \"\".concat(yearString, \"-\").concat(monthString, \"-\").concat(dayString);\n}\nexports.dateToIsoString = dateToIsoString;\n/**\n * Convert the given iso date string to a JavaScript Date object\n *\n * @param {string} isoString The iso date string\n * @returns {Date} the date\n */\nfunction isoStringToStandardDate(isoString) {\n    return new Date(isoString);\n}\nexports.isoStringToStandardDate = isoStringToStandardDate;\n/**\n * Convert the given utc timestamp to a JavaScript Date object\n *\n * @param {number} utc Timestamp in UTC\n * @returns {Date} the date\n */\nfunction toStandardDate(utc) {\n    return new Date(utc);\n}\nexports.toStandardDate = toStandardDate;\n/**\n * Shortcut for creating a new StandardDate\n * @param date\n * @returns {Date} the standard date\n */\nfunction newDate(date) {\n    return new Date(date);\n}\nexports.newDate = newDate;\n/**\n * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.\n * @param {global.Date} standardDate the standard JavaScript date.\n * @param {Integer|number|bigint|undefined} nanoseconds the optional number of nanoseconds.\n * @return {Integer|number|bigint} the total amount of nanoseconds.\n */\nfunction totalNanoseconds(standardDate, nanoseconds) {\n    nanoseconds = nanoseconds !== null && nanoseconds !== void 0 ? nanoseconds : 0;\n    var nanosFromMillis = standardDate.getMilliseconds() * exports.NANOS_PER_MILLISECOND;\n    return add(nanoseconds, nanosFromMillis);\n}\nexports.totalNanoseconds = totalNanoseconds;\n/**\n * Get the time zone offset in seconds from the given standard JavaScript date.\n *\n * @param {global.Date} standardDate the standard JavaScript date.\n * @return {number} the time zone offset in seconds.\n */\nfunction timeZoneOffsetInSeconds(standardDate) {\n    var secondsPortion = standardDate.getSeconds() - standardDate.getUTCSeconds();\n    var minutesPortion = standardDate.getMinutes() - standardDate.getUTCMinutes();\n    var hoursPortion = standardDate.getHours() - standardDate.getUTCHours();\n    var daysPortion = _getDayOffset(standardDate);\n    return hoursPortion * exports.SECONDS_PER_HOUR + minutesPortion * exports.SECONDS_PER_MINUTE + secondsPortion + daysPortion * exports.SECONDS_PER_DAY;\n}\nexports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;\n/**\n * Get the difference in days from the given JavaScript date in local time and UTC.\n *\n * @private\n * @param {global.Date} standardDate the date to evaluate\n * @returns  {number} the difference in days between date local time and UTC\n */\nfunction _getDayOffset(standardDate) {\n    if (standardDate.getMonth() === standardDate.getUTCMonth()) {\n        return standardDate.getDate() - standardDate.getUTCDate();\n    }\n    else if ((standardDate.getFullYear() > standardDate.getUTCFullYear()) || (standardDate.getMonth() > standardDate.getUTCMonth() && standardDate.getFullYear() === standardDate.getUTCFullYear())) {\n        return standardDate.getDate() + _daysUntilNextMonth(standardDate.getUTCMonth(), standardDate.getUTCFullYear()) - standardDate.getUTCDate();\n    }\n    else {\n        return standardDate.getDate() - (standardDate.getUTCDate() + _daysUntilNextMonth(standardDate.getMonth(), standardDate.getFullYear()));\n    }\n}\n/**\n * Get the number of days in a month, including a check for leap years.\n *\n * @private\n * @param {number} month the month of the date to evalutate\n * @param {number} year the month of the date to evalutate\n * @returns {number} the total number of days in the month evaluated\n */\nfunction _daysUntilNextMonth(month, year) {\n    if (month === 1) {\n        if (year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)) {\n            return 29;\n        }\n        else {\n            return 28;\n        }\n    }\n    else if ([0, 2, 4, 6, 7, 9, 11].includes(month)) {\n        return 31;\n    }\n    else {\n        return 30;\n    }\n}\n/**\n * Assert that the year value is valid.\n * @param {Integer|number} year the value to check.\n * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidYear(year) {\n    return assertValidTemporalValue(year, exports.YEAR_RANGE, 'Year');\n}\nexports.assertValidYear = assertValidYear;\n/**\n * Assert that the month value is valid.\n * @param {Integer|number} month the value to check.\n * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidMonth(month) {\n    return assertValidTemporalValue(month, exports.MONTH_OF_YEAR_RANGE, 'Month');\n}\nexports.assertValidMonth = assertValidMonth;\n/**\n * Assert that the day value is valid.\n * @param {Integer|number} day the value to check.\n * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidDay(day) {\n    return assertValidTemporalValue(day, exports.DAY_OF_MONTH_RANGE, 'Day');\n}\nexports.assertValidDay = assertValidDay;\n/**\n * Assert that the hour value is valid.\n * @param {Integer|number} hour the value to check.\n * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidHour(hour) {\n    return assertValidTemporalValue(hour, exports.HOUR_OF_DAY_RANGE, 'Hour');\n}\nexports.assertValidHour = assertValidHour;\n/**\n * Assert that the minute value is valid.\n * @param {Integer|number} minute the value to check.\n * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidMinute(minute) {\n    return assertValidTemporalValue(minute, exports.MINUTE_OF_HOUR_RANGE, 'Minute');\n}\nexports.assertValidMinute = assertValidMinute;\n/**\n * Assert that the second value is valid.\n * @param {Integer|number} second the value to check.\n * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidSecond(second) {\n    return assertValidTemporalValue(second, exports.SECOND_OF_MINUTE_RANGE, 'Second');\n}\nexports.assertValidSecond = assertValidSecond;\n/**\n * Assert that the nanosecond value is valid.\n * @param {Integer|number} nanosecond the value to check.\n * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidNanosecond(nanosecond) {\n    return assertValidTemporalValue(nanosecond, exports.NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');\n}\nexports.assertValidNanosecond = assertValidNanosecond;\nvar timeZoneValidityCache = new Map();\nvar newInvalidZoneIdError = function (zoneId, fieldName) { return (0, error_1.newError)(\"\".concat(fieldName, \" is expected to be a valid ZoneId but was: \\\"\").concat(zoneId, \"\\\"\")); };\nfunction assertValidZoneId(fieldName, zoneId) {\n    var cachedResult = timeZoneValidityCache.get(zoneId);\n    if (cachedResult === true) {\n        return;\n    }\n    if (cachedResult === false) {\n        throw newInvalidZoneIdError(zoneId, fieldName);\n    }\n    try {\n        Intl.DateTimeFormat(undefined, { timeZone: zoneId });\n        timeZoneValidityCache.set(zoneId, true);\n    }\n    catch (e) {\n        timeZoneValidityCache.set(zoneId, false);\n        throw newInvalidZoneIdError(zoneId, fieldName);\n    }\n}\nexports.assertValidZoneId = assertValidZoneId;\n/**\n * Check if the given value is of expected type and is in the expected range.\n * @param {Integer|number} value the value to check.\n * @param {ValueRange} range the range.\n * @param {string} name the name of the value.\n * @return {Integer|number} the value if valid. Exception is thrown otherwise.\n */\nfunction assertValidTemporalValue(value, range, name) {\n    (0, util_1.assertNumberOrInteger)(value, name);\n    if (!range.contains(value)) {\n        throw (0, error_1.newError)(\"\".concat(name, \" is expected to be in range \").concat(range.toString(), \" but was: \").concat(value.toString()));\n    }\n    return value;\n}\n/**\n * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.\n * @param {Integer|number|string} hour the hour of the local time.\n * @param {Integer|number|string} minute the minute of the local time.\n * @param {Integer|number|string} second the second of the local time.\n * @return {Integer} seconds representing the given local time.\n */\nfunction localTimeToSecondOfDay(hour, minute, second) {\n    hour = (0, integer_1.int)(hour);\n    minute = (0, integer_1.int)(minute);\n    second = (0, integer_1.int)(second);\n    var totalSeconds = hour.multiply(exports.SECONDS_PER_HOUR);\n    totalSeconds = totalSeconds.add(minute.multiply(exports.SECONDS_PER_MINUTE));\n    return totalSeconds.add(second);\n}\n/**\n * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.\n * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.\n * @return {boolean} `true` if given year is a leap year, `false` otherwise.\n */\nfunction isLeapYear(year) {\n    year = (0, integer_1.int)(year);\n    if (!year.modulo(4).equals(0)) {\n        return false;\n    }\n    else if (!year.modulo(100).equals(0)) {\n        return true;\n    }\n    else if (!year.modulo(400).equals(0)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\nfunction floorDiv(x, y) {\n    x = (0, integer_1.int)(x);\n    y = (0, integer_1.int)(y);\n    var result = x.div(y);\n    if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {\n        result = result.subtract(1);\n    }\n    return result;\n}\nexports.floorDiv = floorDiv;\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\nfunction floorMod(x, y) {\n    x = (0, integer_1.int)(x);\n    y = (0, integer_1.int)(y);\n    return x.subtract(floorDiv(x, y).multiply(y));\n}\nexports.floorMod = floorMod;\n/**\n * @param {Integer|number|string} seconds the number of seconds to format.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.\n * @return {string} formatted value.\n */\nfunction formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {\n    seconds = (0, integer_1.int)(seconds);\n    nanoseconds = (0, integer_1.int)(nanoseconds);\n    var secondsString;\n    var nanosecondsString;\n    var secondsNegative = seconds.isNegative();\n    var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);\n    if (secondsNegative && nanosecondsGreaterThanZero) {\n        if (seconds.equals(-1)) {\n            secondsString = '-0';\n        }\n        else {\n            secondsString = seconds.add(1).toString();\n        }\n    }\n    else {\n        secondsString = seconds.toString();\n    }\n    if (nanosecondsGreaterThanZero) {\n        if (secondsNegative) {\n            nanosecondsString = formatNanosecond(nanoseconds\n                .negate()\n                .add(2 * exports.NANOS_PER_SECOND)\n                .modulo(exports.NANOS_PER_SECOND));\n        }\n        else {\n            nanosecondsString = formatNanosecond(nanoseconds.add(exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n        }\n    }\n    return nanosecondsString != null ? secondsString + nanosecondsString : secondsString;\n}\n/**\n * @param {Integer|number|string} value the number of nanoseconds to format.\n * @return {string} formatted and possibly left-padded nanoseconds part as string.\n */\nfunction formatNanosecond(value) {\n    value = (0, integer_1.int)(value);\n    return value.equals(0) ? '' : '.' + formatNumber(value, 9);\n}\n/**\n *\n * @param {Integer|number|string} year The year to be formatted\n * @return {string} formatted year\n */\nfunction formatYear(year) {\n    var yearInteger = (0, integer_1.int)(year);\n    if (yearInteger.isNegative() || yearInteger.greaterThan(9999)) {\n        return formatNumber(yearInteger, 6, { usePositiveSign: true });\n    }\n    return formatNumber(yearInteger, 4);\n}\n/**\n * @param {Integer|number|string} num the number to format.\n * @param {number} [stringLength=undefined] the string length to left-pad to.\n * @return {string} formatted and possibly left-padded number as string.\n */\nfunction formatNumber(num, stringLength, params) {\n    num = (0, integer_1.int)(num);\n    var isNegative = num.isNegative();\n    if (isNegative) {\n        num = num.negate();\n    }\n    var numString = num.toString();\n    if (stringLength != null) {\n        // left pad the string with zeroes\n        while (numString.length < stringLength) {\n            numString = '0' + numString;\n        }\n    }\n    if (isNegative) {\n        return '-' + numString;\n    }\n    else if ((params === null || params === void 0 ? void 0 : params.usePositiveSign) === true) {\n        return '+' + numString;\n    }\n    return numString;\n}\nfunction add(x, y) {\n    if (x instanceof integer_1.default) {\n        return x.add(y);\n    }\n    else if (typeof x === 'bigint') {\n        return x + BigInt(y);\n    }\n    return x + y;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3RlbXBvcmFsLXV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcseUJBQXlCLEdBQUcsNkJBQTZCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsK0JBQStCLEdBQUcsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLHNCQUFzQixHQUFHLCtCQUErQixHQUFHLHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQixHQUFHLGtDQUFrQyxHQUFHLDRCQUE0QixHQUFHLHVDQUF1QyxHQUFHLG1DQUFtQyxHQUFHLHVCQUF1QixHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLDZCQUE2QixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLGtDQUFrQyxHQUFHLDhCQUE4QixHQUFHLDRCQUE0QixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLDJCQUEyQixHQUFHLGtCQUFrQjtBQUN2cEMsNkJBQTZCLG1CQUFPLENBQUMseUVBQVk7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LFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlcm5hbC90ZW1wb3JhbC11dGlsLmpzPzdiMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZsb29yTW9kID0gZXhwb3J0cy5mbG9vckRpdiA9IGV4cG9ydHMuYXNzZXJ0VmFsaWRab25lSWQgPSBleHBvcnRzLmFzc2VydFZhbGlkTmFub3NlY29uZCA9IGV4cG9ydHMuYXNzZXJ0VmFsaWRTZWNvbmQgPSBleHBvcnRzLmFzc2VydFZhbGlkTWludXRlID0gZXhwb3J0cy5hc3NlcnRWYWxpZEhvdXIgPSBleHBvcnRzLmFzc2VydFZhbGlkRGF5ID0gZXhwb3J0cy5hc3NlcnRWYWxpZE1vbnRoID0gZXhwb3J0cy5hc3NlcnRWYWxpZFllYXIgPSBleHBvcnRzLnRpbWVab25lT2Zmc2V0SW5TZWNvbmRzID0gZXhwb3J0cy50b3RhbE5hbm9zZWNvbmRzID0gZXhwb3J0cy5uZXdEYXRlID0gZXhwb3J0cy50b1N0YW5kYXJkRGF0ZSA9IGV4cG9ydHMuaXNvU3RyaW5nVG9TdGFuZGFyZERhdGUgPSBleHBvcnRzLmRhdGVUb0lzb1N0cmluZyA9IGV4cG9ydHMudGltZVpvbmVPZmZzZXRUb0lzb1N0cmluZyA9IGV4cG9ydHMudGltZVRvSXNvU3RyaW5nID0gZXhwb3J0cy5kdXJhdGlvblRvSXNvU3RyaW5nID0gZXhwb3J0cy5kYXRlVG9FcG9jaERheSA9IGV4cG9ydHMubG9jYWxEYXRlVGltZVRvRXBvY2hTZWNvbmQgPSBleHBvcnRzLmxvY2FsVGltZVRvTmFub09mRGF5ID0gZXhwb3J0cy5ub3JtYWxpemVOYW5vc2Vjb25kc0ZvckR1cmF0aW9uID0gZXhwb3J0cy5ub3JtYWxpemVTZWNvbmRzRm9yRHVyYXRpb24gPSBleHBvcnRzLlNFQ09ORFNfUEVSX0RBWSA9IGV4cG9ydHMuREFZU19QRVJfNDAwX1lFQVJfQ1lDTEUgPSBleHBvcnRzLkRBWVNfMDAwMF9UT18xOTcwID0gZXhwb3J0cy5OQU5PU19QRVJfSE9VUiA9IGV4cG9ydHMuTkFOT1NfUEVSX01JTlVURSA9IGV4cG9ydHMuTkFOT1NfUEVSX01JTExJU0VDT05EID0gZXhwb3J0cy5OQU5PU19QRVJfU0VDT05EID0gZXhwb3J0cy5TRUNPTkRTX1BFUl9IT1VSID0gZXhwb3J0cy5TRUNPTkRTX1BFUl9NSU5VVEUgPSBleHBvcnRzLk1JTlVURVNfUEVSX0hPVVIgPSBleHBvcnRzLk5BTk9TRUNPTkRfT0ZfU0VDT05EX1JBTkdFID0gZXhwb3J0cy5TRUNPTkRfT0ZfTUlOVVRFX1JBTkdFID0gZXhwb3J0cy5NSU5VVEVfT0ZfSE9VUl9SQU5HRSA9IGV4cG9ydHMuSE9VUl9PRl9EQVlfUkFOR0UgPSBleHBvcnRzLkRBWV9PRl9NT05USF9SQU5HRSA9IGV4cG9ydHMuTU9OVEhfT0ZfWUVBUl9SQU5HRSA9IGV4cG9ydHMuWUVBUl9SQU5HRSA9IHZvaWQgMDtcbnZhciBpbnRlZ2VyXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2ludGVnZXJcIikpO1xudmFyIGVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbi8qXG4gIENvZGUgaW4gdGhpcyB1dGlsIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGggY29kZSBpbiB0aGUgZGF0YWJhc2UgdGhhdCB1c2VzIEpTUi0zMTAgamF2YS50aW1lIEFQSXMuXG5cbiAgSXQgaXMgYmFzZWQgb24gYSBsaWJyYXJ5IGNhbGxlZCBUaHJlZVRlbiAoaHR0cHM6Ly9naXRodWIuY29tL1RocmVlVGVuL3RocmVldGVuYnApIHdoaWNoIHdhcyBkZXJpdmVkXG4gIGZyb20gSlNSLTMxMCByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gcHJldmlvdXNseSBob3N0ZWQgb24gR2l0SHViLiBDb2RlIHVzZXMgYEludGVnZXJgIHR5cGUgZXZlcnl3aGVyZVxuICB0byBjb3JyZWN0bHkgaGFuZGxlIGxhcmdlIGludGVnZXIgdmFsdWVzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuXG4gIFBsZWFzZSBjb25zdWx0IGVpdGhlciBUaHJlZVRlbiBvciBqcy1qb2RhIChodHRwczovL2dpdGh1Yi5jb20vanMtam9kYS9qcy1qb2RhKSB3aGVuIHdvcmtpbmcgd2l0aCB0aGVcbiAgY29udmVyc2lvbiBmdW5jdGlvbnMuXG4gKi9cbnZhciBWYWx1ZVJhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbHVlUmFuZ2UobWluLCBtYXgpIHtcbiAgICAgICAgdGhpcy5fbWluTnVtYmVyID0gbWluO1xuICAgICAgICB0aGlzLl9tYXhOdW1iZXIgPSBtYXg7XG4gICAgICAgIHRoaXMuX21pbkludGVnZXIgPSAoMCwgaW50ZWdlcl8xLmludCkobWluKTtcbiAgICAgICAgdGhpcy5fbWF4SW50ZWdlciA9ICgwLCBpbnRlZ2VyXzEuaW50KShtYXgpO1xuICAgIH1cbiAgICBWYWx1ZVJhbmdlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoKDAsIGludGVnZXJfMS5pc0ludCkodmFsdWUpICYmIHZhbHVlIGluc3RhbmNlb2YgaW50ZWdlcl8xLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUuZ3JlYXRlclRoYW5PckVxdWFsKHRoaXMuX21pbkludGVnZXIpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVzc1RoYW5PckVxdWFsKHRoaXMuX21heEludGVnZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICB2YXIgaW50VmFsdWUgPSAoMCwgaW50ZWdlcl8xLmludCkodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIChpbnRWYWx1ZS5ncmVhdGVyVGhhbk9yRXF1YWwodGhpcy5fbWluSW50ZWdlcikgJiZcbiAgICAgICAgICAgICAgICBpbnRWYWx1ZS5sZXNzVGhhbk9yRXF1YWwodGhpcy5fbWF4SW50ZWdlcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID49IHRoaXMuX21pbk51bWJlciAmJiB2YWx1ZSA8PSB0aGlzLl9tYXhOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZhbHVlUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJbXCIuY29uY2F0KHRoaXMuX21pbk51bWJlciwgXCIsIFwiKS5jb25jYXQodGhpcy5fbWF4TnVtYmVyLCBcIl1cIik7XG4gICAgfTtcbiAgICByZXR1cm4gVmFsdWVSYW5nZTtcbn0oKSk7XG5leHBvcnRzLllFQVJfUkFOR0UgPSBuZXcgVmFsdWVSYW5nZSgtOTk5OTk5OTk5LCA5OTk5OTk5OTkpO1xuZXhwb3J0cy5NT05USF9PRl9ZRUFSX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoMSwgMTIpO1xuZXhwb3J0cy5EQVlfT0ZfTU9OVEhfUkFOR0UgPSBuZXcgVmFsdWVSYW5nZSgxLCAzMSk7XG5leHBvcnRzLkhPVVJfT0ZfREFZX1JBTkdFID0gbmV3IFZhbHVlUmFuZ2UoMCwgMjMpO1xuZXhwb3J0cy5NSU5VVEVfT0ZfSE9VUl9SQU5HRSA9IG5ldyBWYWx1ZVJhbmdlKDAsIDU5KTtcbmV4cG9ydHMuU0VDT05EX09GX01JTlVURV9SQU5HRSA9IG5ldyBWYWx1ZVJhbmdlKDAsIDU5KTtcbmV4cG9ydHMuTkFOT1NFQ09ORF9PRl9TRUNPTkRfUkFOR0UgPSBuZXcgVmFsdWVSYW5nZSgwLCA5OTk5OTk5OTkpO1xuZXhwb3J0cy5NSU5VVEVTX1BFUl9IT1VSID0gNjA7XG5leHBvcnRzLlNFQ09ORFNfUEVSX01JTlVURSA9IDYwO1xuZXhwb3J0cy5TRUNPTkRTX1BFUl9IT1VSID0gZXhwb3J0cy5TRUNPTkRTX1BFUl9NSU5VVEUgKiBleHBvcnRzLk1JTlVURVNfUEVSX0hPVVI7XG5leHBvcnRzLk5BTk9TX1BFUl9TRUNPTkQgPSAxMDAwMDAwMDAwO1xuZXhwb3J0cy5OQU5PU19QRVJfTUlMTElTRUNPTkQgPSAxMDAwMDAwO1xuZXhwb3J0cy5OQU5PU19QRVJfTUlOVVRFID0gZXhwb3J0cy5OQU5PU19QRVJfU0VDT05EICogZXhwb3J0cy5TRUNPTkRTX1BFUl9NSU5VVEU7XG5leHBvcnRzLk5BTk9TX1BFUl9IT1VSID0gZXhwb3J0cy5OQU5PU19QRVJfTUlOVVRFICogZXhwb3J0cy5NSU5VVEVTX1BFUl9IT1VSO1xuZXhwb3J0cy5EQVlTXzAwMDBfVE9fMTk3MCA9IDcxOTUyODtcbmV4cG9ydHMuREFZU19QRVJfNDAwX1lFQVJfQ1lDTEUgPSAxNDYwOTc7XG5leHBvcnRzLlNFQ09ORFNfUEVSX0RBWSA9IDg2NDAwO1xuZnVuY3Rpb24gbm9ybWFsaXplU2Vjb25kc0ZvckR1cmF0aW9uKHNlY29uZHMsIG5hbm9zZWNvbmRzKSB7XG4gICAgcmV0dXJuICgwLCBpbnRlZ2VyXzEuaW50KShzZWNvbmRzKS5hZGQoZmxvb3JEaXYobmFub3NlY29uZHMsIGV4cG9ydHMuTkFOT1NfUEVSX1NFQ09ORCkpO1xufVxuZXhwb3J0cy5ub3JtYWxpemVTZWNvbmRzRm9yRHVyYXRpb24gPSBub3JtYWxpemVTZWNvbmRzRm9yRHVyYXRpb247XG5mdW5jdGlvbiBub3JtYWxpemVOYW5vc2Vjb25kc0ZvckR1cmF0aW9uKG5hbm9zZWNvbmRzKSB7XG4gICAgcmV0dXJuIGZsb29yTW9kKG5hbm9zZWNvbmRzLCBleHBvcnRzLk5BTk9TX1BFUl9TRUNPTkQpO1xufVxuZXhwb3J0cy5ub3JtYWxpemVOYW5vc2Vjb25kc0ZvckR1cmF0aW9uID0gbm9ybWFsaXplTmFub3NlY29uZHNGb3JEdXJhdGlvbjtcbi8qKlxuICogQ29udmVydHMgZ2l2ZW4gbG9jYWwgdGltZSBpbnRvIGEgc2luZ2xlIGludGVnZXIgcmVwcmVzZW50aW5nIHRoaXMgc2FtZSB0aW1lIGluIG5hbm9zZWNvbmRzIG9mIHRoZSBkYXkuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gaG91ciB0aGUgaG91ciBvZiB0aGUgbG9jYWwgdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1pbnV0ZSB0aGUgbWludXRlIG9mIHRoZSBsb2NhbCB0aW1lIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gc2Vjb25kIHRoZSBzZWNvbmQgb2YgdGhlIGxvY2FsIHRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBuYW5vc2Vjb25kIHRoZSBuYW5vc2Vjb25kIG9mIHRoZSBsb2NhbCB0aW1lIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBuYW5vc2Vjb25kcyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGxvY2FsIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsVGltZVRvTmFub09mRGF5KGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kKSB7XG4gICAgaG91ciA9ICgwLCBpbnRlZ2VyXzEuaW50KShob3VyKTtcbiAgICBtaW51dGUgPSAoMCwgaW50ZWdlcl8xLmludCkobWludXRlKTtcbiAgICBzZWNvbmQgPSAoMCwgaW50ZWdlcl8xLmludCkoc2Vjb25kKTtcbiAgICBuYW5vc2Vjb25kID0gKDAsIGludGVnZXJfMS5pbnQpKG5hbm9zZWNvbmQpO1xuICAgIHZhciB0b3RhbE5hbm9zID0gaG91ci5tdWx0aXBseShleHBvcnRzLk5BTk9TX1BFUl9IT1VSKTtcbiAgICB0b3RhbE5hbm9zID0gdG90YWxOYW5vcy5hZGQobWludXRlLm11bHRpcGx5KGV4cG9ydHMuTkFOT1NfUEVSX01JTlVURSkpO1xuICAgIHRvdGFsTmFub3MgPSB0b3RhbE5hbm9zLmFkZChzZWNvbmQubXVsdGlwbHkoZXhwb3J0cy5OQU5PU19QRVJfU0VDT05EKSk7XG4gICAgcmV0dXJuIHRvdGFsTmFub3MuYWRkKG5hbm9zZWNvbmQpO1xufVxuZXhwb3J0cy5sb2NhbFRpbWVUb05hbm9PZkRheSA9IGxvY2FsVGltZVRvTmFub09mRGF5O1xuLyoqXG4gKiBDb252ZXJ0cyBnaXZlbiBsb2NhbCBkYXRlIHRpbWUgaW50byBhIHNpbmdsZSBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGlzIHNhbWUgdGltZSBpbiBlcG9jaCBzZWNvbmRzIFVUQy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB5ZWFyIHRoZSB5ZWFyIG9mIHRoZSBsb2NhbCBkYXRlLXRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtb250aCB0aGUgbW9udGggb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGRheSB0aGUgZGF5IG9mIHRoZSBsb2NhbCBkYXRlLXRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBob3VyIHRoZSBob3VyIG9mIHRoZSBsb2NhbCBkYXRlLXRpbWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBtaW51dGUgdGhlIG1pbnV0ZSBvZiB0aGUgbG9jYWwgZGF0ZS10aW1lIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gc2Vjb25kIHRoZSBzZWNvbmQgb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG5hbm9zZWNvbmQgdGhlIG5hbm9zZWNvbmQgb2YgdGhlIGxvY2FsIGRhdGUtdGltZSB0byBjb252ZXJ0LlxuICogQHJldHVybiB7SW50ZWdlcn0gZXBvY2ggc2Vjb25kIGluIFVUQyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGxvY2FsIGRhdGUgdGltZS5cbiAqL1xuZnVuY3Rpb24gbG9jYWxEYXRlVGltZVRvRXBvY2hTZWNvbmQoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICB2YXIgZXBvY2hEYXkgPSBkYXRlVG9FcG9jaERheSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB2YXIgbG9jYWxUaW1lU2Vjb25kcyA9IGxvY2FsVGltZVRvU2Vjb25kT2ZEYXkoaG91ciwgbWludXRlLCBzZWNvbmQpO1xuICAgIHJldHVybiBlcG9jaERheS5tdWx0aXBseShleHBvcnRzLlNFQ09ORFNfUEVSX0RBWSkuYWRkKGxvY2FsVGltZVNlY29uZHMpO1xufVxuZXhwb3J0cy5sb2NhbERhdGVUaW1lVG9FcG9jaFNlY29uZCA9IGxvY2FsRGF0ZVRpbWVUb0Vwb2NoU2Vjb25kO1xuLyoqXG4gKiBDb252ZXJ0cyBnaXZlbiBsb2NhbCBkYXRlIGludG8gYSBzaW5nbGUgaW50ZWdlciByZXByZXNlbnRpbmcgaXQncyBlcG9jaCBkYXkuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30geWVhciB0aGUgeWVhciBvZiB0aGUgbG9jYWwgZGF0ZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1vbnRoIHRoZSBtb250aCBvZiB0aGUgbG9jYWwgZGF0ZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGRheSB0aGUgZGF5IG9mIHRoZSBsb2NhbCBkYXRlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfSBlcG9jaCBkYXkgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBkYXRlLlxuICovXG5mdW5jdGlvbiBkYXRlVG9FcG9jaERheSh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgeWVhciA9ICgwLCBpbnRlZ2VyXzEuaW50KSh5ZWFyKTtcbiAgICBtb250aCA9ICgwLCBpbnRlZ2VyXzEuaW50KShtb250aCk7XG4gICAgZGF5ID0gKDAsIGludGVnZXJfMS5pbnQpKGRheSk7XG4gICAgdmFyIGVwb2NoRGF5ID0geWVhci5tdWx0aXBseSgzNjUpO1xuICAgIGlmICh5ZWFyLmdyZWF0ZXJUaGFuT3JFcXVhbCgwKSkge1xuICAgICAgICBlcG9jaERheSA9IGVwb2NoRGF5LmFkZCh5ZWFyXG4gICAgICAgICAgICAuYWRkKDMpXG4gICAgICAgICAgICAuZGl2KDQpXG4gICAgICAgICAgICAuc3VidHJhY3QoeWVhci5hZGQoOTkpLmRpdigxMDApKVxuICAgICAgICAgICAgLmFkZCh5ZWFyLmFkZCgzOTkpLmRpdig0MDApKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlcG9jaERheSA9IGVwb2NoRGF5LnN1YnRyYWN0KHllYXJcbiAgICAgICAgICAgIC5kaXYoLTQpXG4gICAgICAgICAgICAuc3VidHJhY3QoeWVhci5kaXYoLTEwMCkpXG4gICAgICAgICAgICAuYWRkKHllYXIuZGl2KC00MDApKSk7XG4gICAgfVxuICAgIGVwb2NoRGF5ID0gZXBvY2hEYXkuYWRkKG1vbnRoXG4gICAgICAgIC5tdWx0aXBseSgzNjcpXG4gICAgICAgIC5zdWJ0cmFjdCgzNjIpXG4gICAgICAgIC5kaXYoMTIpKTtcbiAgICBlcG9jaERheSA9IGVwb2NoRGF5LmFkZChkYXkuc3VidHJhY3QoMSkpO1xuICAgIGlmIChtb250aC5ncmVhdGVyVGhhbigyKSkge1xuICAgICAgICBlcG9jaERheSA9IGVwb2NoRGF5LnN1YnRyYWN0KDEpO1xuICAgICAgICBpZiAoIWlzTGVhcFllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIGVwb2NoRGF5ID0gZXBvY2hEYXkuc3VidHJhY3QoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVwb2NoRGF5LnN1YnRyYWN0KGV4cG9ydHMuREFZU18wMDAwX1RPXzE5NzApO1xufVxuZXhwb3J0cy5kYXRlVG9FcG9jaERheSA9IGRhdGVUb0Vwb2NoRGF5O1xuLyoqXG4gKiBGb3JtYXQgZ2l2ZW4gZHVyYXRpb24gdG8gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1vbnRocyB0aGUgbnVtYmVyIG9mIG1vbnRocy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBkYXlzIHRoZSBudW1iZXIgb2YgZGF5cy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBzZWNvbmRzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBuYW5vc2Vjb25kcyB0aGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzLlxuICogQHJldHVybiB7c3RyaW5nfSBJU08gc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBnaXZlbiBkdXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZHVyYXRpb25Ub0lzb1N0cmluZyhtb250aHMsIGRheXMsIHNlY29uZHMsIG5hbm9zZWNvbmRzKSB7XG4gICAgdmFyIG1vbnRoc1N0cmluZyA9IGZvcm1hdE51bWJlcihtb250aHMpO1xuICAgIHZhciBkYXlzU3RyaW5nID0gZm9ybWF0TnVtYmVyKGRheXMpO1xuICAgIHZhciBzZWNvbmRzQW5kTmFub3NlY29uZHNTdHJpbmcgPSBmb3JtYXRTZWNvbmRzQW5kTmFub3NlY29uZHNGb3JEdXJhdGlvbihzZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgcmV0dXJuIFwiUFwiLmNvbmNhdChtb250aHNTdHJpbmcsIFwiTVwiKS5jb25jYXQoZGF5c1N0cmluZywgXCJEVFwiKS5jb25jYXQoc2Vjb25kc0FuZE5hbm9zZWNvbmRzU3RyaW5nLCBcIlNcIik7XG59XG5leHBvcnRzLmR1cmF0aW9uVG9Jc29TdHJpbmcgPSBkdXJhdGlvblRvSXNvU3RyaW5nO1xuLyoqXG4gKiBGb3JtYXRzIGdpdmVuIHRpbWUgdG8gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IGhvdXIgdGhlIGhvdXIgdmFsdWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbWludXRlIHRoZSBtaW51dGUgdmFsdWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gc2Vjb25kIHRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbmFub3NlY29uZCB0aGUgbmFub3NlY29uZCB2YWx1ZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gSVNPIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgZ2l2ZW4gdGltZS5cbiAqL1xuZnVuY3Rpb24gdGltZVRvSXNvU3RyaW5nKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kKSB7XG4gICAgdmFyIGhvdXJTdHJpbmcgPSBmb3JtYXROdW1iZXIoaG91ciwgMik7XG4gICAgdmFyIG1pbnV0ZVN0cmluZyA9IGZvcm1hdE51bWJlcihtaW51dGUsIDIpO1xuICAgIHZhciBzZWNvbmRTdHJpbmcgPSBmb3JtYXROdW1iZXIoc2Vjb25kLCAyKTtcbiAgICB2YXIgbmFub3NlY29uZFN0cmluZyA9IGZvcm1hdE5hbm9zZWNvbmQobmFub3NlY29uZCk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGhvdXJTdHJpbmcsIFwiOlwiKS5jb25jYXQobWludXRlU3RyaW5nLCBcIjpcIikuY29uY2F0KHNlY29uZFN0cmluZykuY29uY2F0KG5hbm9zZWNvbmRTdHJpbmcpO1xufVxuZXhwb3J0cy50aW1lVG9Jc29TdHJpbmcgPSB0aW1lVG9Jc29TdHJpbmc7XG4vKipcbiAqIEZvcm1hdHMgZ2l2ZW4gdGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzIHRvIHN0cmluZyByZXByZXNlbnRhdGlvbiBsaWtlICfCsUhIOk1NJywgJ8KxSEg6TU06U1MnIG9yICdaJyBmb3IgVVRDLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG9mZnNldFNlY29uZHMgdGhlIG9mZnNldCBpbiBzZWNvbmRzLlxuICogQHJldHVybiB7c3RyaW5nfSBJU08gc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBnaXZlbiBvZmZzZXQuXG4gKi9cbmZ1bmN0aW9uIHRpbWVab25lT2Zmc2V0VG9Jc29TdHJpbmcob2Zmc2V0U2Vjb25kcykge1xuICAgIG9mZnNldFNlY29uZHMgPSAoMCwgaW50ZWdlcl8xLmludCkob2Zmc2V0U2Vjb25kcyk7XG4gICAgaWYgKG9mZnNldFNlY29uZHMuZXF1YWxzKDApKSB7XG4gICAgICAgIHJldHVybiAnWic7XG4gICAgfVxuICAgIHZhciBpc05lZ2F0aXZlID0gb2Zmc2V0U2Vjb25kcy5pc05lZ2F0aXZlKCk7XG4gICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgb2Zmc2V0U2Vjb25kcyA9IG9mZnNldFNlY29uZHMubXVsdGlwbHkoLTEpO1xuICAgIH1cbiAgICB2YXIgc2lnblByZWZpeCA9IGlzTmVnYXRpdmUgPyAnLScgOiAnKyc7XG4gICAgdmFyIGhvdXJzID0gZm9ybWF0TnVtYmVyKG9mZnNldFNlY29uZHMuZGl2KGV4cG9ydHMuU0VDT05EU19QRVJfSE9VUiksIDIpO1xuICAgIHZhciBtaW51dGVzID0gZm9ybWF0TnVtYmVyKG9mZnNldFNlY29uZHMuZGl2KGV4cG9ydHMuU0VDT05EU19QRVJfTUlOVVRFKS5tb2R1bG8oZXhwb3J0cy5NSU5VVEVTX1BFUl9IT1VSKSwgMik7XG4gICAgdmFyIHNlY29uZHNWYWx1ZSA9IG9mZnNldFNlY29uZHMubW9kdWxvKGV4cG9ydHMuU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgICB2YXIgc2Vjb25kcyA9IHNlY29uZHNWYWx1ZS5lcXVhbHMoMCkgPyBudWxsIDogZm9ybWF0TnVtYmVyKHNlY29uZHNWYWx1ZSwgMik7XG4gICAgcmV0dXJuIHNlY29uZHMgIT0gbnVsbFxuICAgICAgICA/IFwiXCIuY29uY2F0KHNpZ25QcmVmaXgpLmNvbmNhdChob3VycywgXCI6XCIpLmNvbmNhdChtaW51dGVzLCBcIjpcIikuY29uY2F0KHNlY29uZHMpXG4gICAgICAgIDogXCJcIi5jb25jYXQoc2lnblByZWZpeCkuY29uY2F0KGhvdXJzLCBcIjpcIikuY29uY2F0KG1pbnV0ZXMpO1xufVxuZXhwb3J0cy50aW1lWm9uZU9mZnNldFRvSXNvU3RyaW5nID0gdGltZVpvbmVPZmZzZXRUb0lzb1N0cmluZztcbi8qKlxuICogRm9ybWF0cyBnaXZlbiBkYXRlIHRvIGFuIElTTyA4NjAxIHN0cmluZy5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB5ZWFyIHRoZSBkYXRlIHllYXIuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbW9udGggdGhlIGRhdGUgbW9udGguXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gZGF5IHRoZSBkYXRlIGRheS5cbiAqIEByZXR1cm4ge3N0cmluZ30gSVNPIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgZ2l2ZW4gZGF0ZS5cbiAqL1xuZnVuY3Rpb24gZGF0ZVRvSXNvU3RyaW5nKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICB2YXIgeWVhclN0cmluZyA9IGZvcm1hdFllYXIoeWVhcik7XG4gICAgdmFyIG1vbnRoU3RyaW5nID0gZm9ybWF0TnVtYmVyKG1vbnRoLCAyKTtcbiAgICB2YXIgZGF5U3RyaW5nID0gZm9ybWF0TnVtYmVyKGRheSwgMik7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHllYXJTdHJpbmcsIFwiLVwiKS5jb25jYXQobW9udGhTdHJpbmcsIFwiLVwiKS5jb25jYXQoZGF5U3RyaW5nKTtcbn1cbmV4cG9ydHMuZGF0ZVRvSXNvU3RyaW5nID0gZGF0ZVRvSXNvU3RyaW5nO1xuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBpc28gZGF0ZSBzdHJpbmcgdG8gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlzb1N0cmluZyBUaGUgaXNvIGRhdGUgc3RyaW5nXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIGRhdGVcbiAqL1xuZnVuY3Rpb24gaXNvU3RyaW5nVG9TdGFuZGFyZERhdGUoaXNvU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGlzb1N0cmluZyk7XG59XG5leHBvcnRzLmlzb1N0cmluZ1RvU3RhbmRhcmREYXRlID0gaXNvU3RyaW5nVG9TdGFuZGFyZERhdGU7XG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHV0YyB0aW1lc3RhbXAgdG8gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHV0YyBUaW1lc3RhbXAgaW4gVVRDXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIGRhdGVcbiAqL1xuZnVuY3Rpb24gdG9TdGFuZGFyZERhdGUodXRjKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHV0Yyk7XG59XG5leHBvcnRzLnRvU3RhbmRhcmREYXRlID0gdG9TdGFuZGFyZERhdGU7XG4vKipcbiAqIFNob3J0Y3V0IGZvciBjcmVhdGluZyBhIG5ldyBTdGFuZGFyZERhdGVcbiAqIEBwYXJhbSBkYXRlXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHN0YW5kYXJkIGRhdGVcbiAqL1xuZnVuY3Rpb24gbmV3RGF0ZShkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xufVxuZXhwb3J0cy5uZXdEYXRlID0gbmV3RGF0ZTtcbi8qKlxuICogR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgbmFub3NlY29uZHMgZnJvbSB0aGUgbWlsbGlzZWNvbmRzIG9mIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUgYW5kIG9wdGlvbmFsIG5hbm9zZWNvbmQgcGFydC5cbiAqIEBwYXJhbSB7Z2xvYmFsLkRhdGV9IHN0YW5kYXJkRGF0ZSB0aGUgc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxiaWdpbnR8dW5kZWZpbmVkfSBuYW5vc2Vjb25kcyB0aGUgb3B0aW9uYWwgbnVtYmVyIG9mIG5hbm9zZWNvbmRzLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ8YmlnaW50fSB0aGUgdG90YWwgYW1vdW50IG9mIG5hbm9zZWNvbmRzLlxuICovXG5mdW5jdGlvbiB0b3RhbE5hbm9zZWNvbmRzKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZHMpIHtcbiAgICBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzICE9PSBudWxsICYmIG5hbm9zZWNvbmRzICE9PSB2b2lkIDAgPyBuYW5vc2Vjb25kcyA6IDA7XG4gICAgdmFyIG5hbm9zRnJvbU1pbGxpcyA9IHN0YW5kYXJkRGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAqIGV4cG9ydHMuTkFOT1NfUEVSX01JTExJU0VDT05EO1xuICAgIHJldHVybiBhZGQobmFub3NlY29uZHMsIG5hbm9zRnJvbU1pbGxpcyk7XG59XG5leHBvcnRzLnRvdGFsTmFub3NlY29uZHMgPSB0b3RhbE5hbm9zZWNvbmRzO1xuLyoqXG4gKiBHZXQgdGhlIHRpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUuXG4gKlxuICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIHRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSB0aW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIHRpbWVab25lT2Zmc2V0SW5TZWNvbmRzKHN0YW5kYXJkRGF0ZSkge1xuICAgIHZhciBzZWNvbmRzUG9ydGlvbiA9IHN0YW5kYXJkRGF0ZS5nZXRTZWNvbmRzKCkgLSBzdGFuZGFyZERhdGUuZ2V0VVRDU2Vjb25kcygpO1xuICAgIHZhciBtaW51dGVzUG9ydGlvbiA9IHN0YW5kYXJkRGF0ZS5nZXRNaW51dGVzKCkgLSBzdGFuZGFyZERhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgIHZhciBob3Vyc1BvcnRpb24gPSBzdGFuZGFyZERhdGUuZ2V0SG91cnMoKSAtIHN0YW5kYXJkRGF0ZS5nZXRVVENIb3VycygpO1xuICAgIHZhciBkYXlzUG9ydGlvbiA9IF9nZXREYXlPZmZzZXQoc3RhbmRhcmREYXRlKTtcbiAgICByZXR1cm4gaG91cnNQb3J0aW9uICogZXhwb3J0cy5TRUNPTkRTX1BFUl9IT1VSICsgbWludXRlc1BvcnRpb24gKiBleHBvcnRzLlNFQ09ORFNfUEVSX01JTlVURSArIHNlY29uZHNQb3J0aW9uICsgZGF5c1BvcnRpb24gKiBleHBvcnRzLlNFQ09ORFNfUEVSX0RBWTtcbn1cbmV4cG9ydHMudGltZVpvbmVPZmZzZXRJblNlY29uZHMgPSB0aW1lWm9uZU9mZnNldEluU2Vjb25kcztcbi8qKlxuICogR2V0IHRoZSBkaWZmZXJlbmNlIGluIGRheXMgZnJvbSB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBkYXRlIGluIGxvY2FsIHRpbWUgYW5kIFVUQy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIHRoZSBkYXRlIHRvIGV2YWx1YXRlXG4gKiBAcmV0dXJucyAge251bWJlcn0gdGhlIGRpZmZlcmVuY2UgaW4gZGF5cyBiZXR3ZWVuIGRhdGUgbG9jYWwgdGltZSBhbmQgVVRDXG4gKi9cbmZ1bmN0aW9uIF9nZXREYXlPZmZzZXQoc3RhbmRhcmREYXRlKSB7XG4gICAgaWYgKHN0YW5kYXJkRGF0ZS5nZXRNb250aCgpID09PSBzdGFuZGFyZERhdGUuZ2V0VVRDTW9udGgoKSkge1xuICAgICAgICByZXR1cm4gc3RhbmRhcmREYXRlLmdldERhdGUoKSAtIHN0YW5kYXJkRGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChzdGFuZGFyZERhdGUuZ2V0RnVsbFllYXIoKSA+IHN0YW5kYXJkRGF0ZS5nZXRVVENGdWxsWWVhcigpKSB8fCAoc3RhbmRhcmREYXRlLmdldE1vbnRoKCkgPiBzdGFuZGFyZERhdGUuZ2V0VVRDTW9udGgoKSAmJiBzdGFuZGFyZERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc3RhbmRhcmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgIHJldHVybiBzdGFuZGFyZERhdGUuZ2V0RGF0ZSgpICsgX2RheXNVbnRpbE5leHRNb250aChzdGFuZGFyZERhdGUuZ2V0VVRDTW9udGgoKSwgc3RhbmRhcmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkpIC0gc3RhbmRhcmREYXRlLmdldFVUQ0RhdGUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGFuZGFyZERhdGUuZ2V0RGF0ZSgpIC0gKHN0YW5kYXJkRGF0ZS5nZXRVVENEYXRlKCkgKyBfZGF5c1VudGlsTmV4dE1vbnRoKHN0YW5kYXJkRGF0ZS5nZXRNb250aCgpLCBzdGFuZGFyZERhdGUuZ2V0RnVsbFllYXIoKSkpO1xuICAgIH1cbn1cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoLCBpbmNsdWRpbmcgYSBjaGVjayBmb3IgbGVhcCB5ZWFycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1vbnRoIHRoZSBtb250aCBvZiB0aGUgZGF0ZSB0byBldmFsdXRhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB5ZWFyIHRoZSBtb250aCBvZiB0aGUgZGF0ZSB0byBldmFsdXRhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSB0b3RhbCBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGggZXZhbHVhdGVkXG4gKi9cbmZ1bmN0aW9uIF9kYXlzVW50aWxOZXh0TW9udGgobW9udGgsIHllYXIpIHtcbiAgICBpZiAobW9udGggPT09IDEpIHtcbiAgICAgICAgaWYgKHllYXIgJSA0MDAgPT09IDAgfHwgKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gMjk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMjg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoWzAsIDIsIDQsIDYsIDcsIDksIDExXS5pbmNsdWRlcyhtb250aCkpIHtcbiAgICAgICAgcmV0dXJuIDMxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgIH1cbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHllYXIgdmFsdWUgaXMgdmFsaWQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSB5ZWFyIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgb2YgdGhlIHllYXIgaWYgaXQgaXMgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFllYXIoeWVhcikge1xuICAgIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUoeWVhciwgZXhwb3J0cy5ZRUFSX1JBTkdFLCAnWWVhcicpO1xufVxuZXhwb3J0cy5hc3NlcnRWYWxpZFllYXIgPSBhc3NlcnRWYWxpZFllYXI7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBtb250aCB2YWx1ZSBpcyB2YWxpZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IG1vbnRoIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgb2YgdGhlIG1vbnRoIGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRNb250aChtb250aCkge1xuICAgIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUobW9udGgsIGV4cG9ydHMuTU9OVEhfT0ZfWUVBUl9SQU5HRSwgJ01vbnRoJyk7XG59XG5leHBvcnRzLmFzc2VydFZhbGlkTW9udGggPSBhc3NlcnRWYWxpZE1vbnRoO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZGF5IHZhbHVlIGlzIHZhbGlkLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gZGF5IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgb2YgdGhlIGRheSBpZiBpdCBpcyB2YWxpZC4gRXhjZXB0aW9uIGlzIHRocm93biBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkRGF5KGRheSkge1xuICAgIHJldHVybiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUoZGF5LCBleHBvcnRzLkRBWV9PRl9NT05USF9SQU5HRSwgJ0RheScpO1xufVxuZXhwb3J0cy5hc3NlcnRWYWxpZERheSA9IGFzc2VydFZhbGlkRGF5O1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgaG91ciB2YWx1ZSBpcyB2YWxpZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IGhvdXIgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ9IHRoZSB2YWx1ZSBvZiB0aGUgaG91ciBpZiBpdCBpcyB2YWxpZC4gRXhjZXB0aW9uIGlzIHRocm93biBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkSG91cihob3VyKSB7XG4gICAgcmV0dXJuIGFzc2VydFZhbGlkVGVtcG9yYWxWYWx1ZShob3VyLCBleHBvcnRzLkhPVVJfT0ZfREFZX1JBTkdFLCAnSG91cicpO1xufVxuZXhwb3J0cy5hc3NlcnRWYWxpZEhvdXIgPSBhc3NlcnRWYWxpZEhvdXI7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBtaW51dGUgdmFsdWUgaXMgdmFsaWQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSBtaW51dGUgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7SW50ZWdlcnxudW1iZXJ9IHRoZSB2YWx1ZSBvZiB0aGUgbWludXRlIGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRNaW51dGUobWludXRlKSB7XG4gICAgcmV0dXJuIGFzc2VydFZhbGlkVGVtcG9yYWxWYWx1ZShtaW51dGUsIGV4cG9ydHMuTUlOVVRFX09GX0hPVVJfUkFOR0UsICdNaW51dGUnKTtcbn1cbmV4cG9ydHMuYXNzZXJ0VmFsaWRNaW51dGUgPSBhc3NlcnRWYWxpZE1pbnV0ZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHNlY29uZCB2YWx1ZSBpcyB2YWxpZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ9IHNlY29uZCB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bWJlcn0gdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgaWYgaXQgaXMgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFNlY29uZChzZWNvbmQpIHtcbiAgICByZXR1cm4gYXNzZXJ0VmFsaWRUZW1wb3JhbFZhbHVlKHNlY29uZCwgZXhwb3J0cy5TRUNPTkRfT0ZfTUlOVVRFX1JBTkdFLCAnU2Vjb25kJyk7XG59XG5leHBvcnRzLmFzc2VydFZhbGlkU2Vjb25kID0gYXNzZXJ0VmFsaWRTZWNvbmQ7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBuYW5vc2Vjb25kIHZhbHVlIGlzIHZhbGlkLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcn0gbmFub3NlY29uZCB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtJbnRlZ2VyfG51bWJlcn0gdGhlIHZhbHVlIG9mIHRoZSBuYW5vc2Vjb25kIGlmIGl0IGlzIHZhbGlkLiBFeGNlcHRpb24gaXMgdGhyb3duIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWROYW5vc2Vjb25kKG5hbm9zZWNvbmQpIHtcbiAgICByZXR1cm4gYXNzZXJ0VmFsaWRUZW1wb3JhbFZhbHVlKG5hbm9zZWNvbmQsIGV4cG9ydHMuTkFOT1NFQ09ORF9PRl9TRUNPTkRfUkFOR0UsICdOYW5vc2Vjb25kJyk7XG59XG5leHBvcnRzLmFzc2VydFZhbGlkTmFub3NlY29uZCA9IGFzc2VydFZhbGlkTmFub3NlY29uZDtcbnZhciB0aW1lWm9uZVZhbGlkaXR5Q2FjaGUgPSBuZXcgTWFwKCk7XG52YXIgbmV3SW52YWxpZFpvbmVJZEVycm9yID0gZnVuY3Rpb24gKHpvbmVJZCwgZmllbGROYW1lKSB7IHJldHVybiAoMCwgZXJyb3JfMS5uZXdFcnJvcikoXCJcIi5jb25jYXQoZmllbGROYW1lLCBcIiBpcyBleHBlY3RlZCB0byBiZSBhIHZhbGlkIFpvbmVJZCBidXQgd2FzOiBcXFwiXCIpLmNvbmNhdCh6b25lSWQsIFwiXFxcIlwiKSk7IH07XG5mdW5jdGlvbiBhc3NlcnRWYWxpZFpvbmVJZChmaWVsZE5hbWUsIHpvbmVJZCkge1xuICAgIHZhciBjYWNoZWRSZXN1bHQgPSB0aW1lWm9uZVZhbGlkaXR5Q2FjaGUuZ2V0KHpvbmVJZCk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYWNoZWRSZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ld0ludmFsaWRab25lSWRFcnJvcih6b25lSWQsIGZpZWxkTmFtZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIEludGwuRGF0ZVRpbWVGb3JtYXQodW5kZWZpbmVkLCB7IHRpbWVab25lOiB6b25lSWQgfSk7XG4gICAgICAgIHRpbWVab25lVmFsaWRpdHlDYWNoZS5zZXQoem9uZUlkLCB0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGltZVpvbmVWYWxpZGl0eUNhY2hlLnNldCh6b25lSWQsIGZhbHNlKTtcbiAgICAgICAgdGhyb3cgbmV3SW52YWxpZFpvbmVJZEVycm9yKHpvbmVJZCwgZmllbGROYW1lKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFZhbGlkWm9uZUlkID0gYXNzZXJ0VmFsaWRab25lSWQ7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiBleHBlY3RlZCB0eXBlIGFuZCBpcyBpbiB0aGUgZXhwZWN0ZWQgcmFuZ2UuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfSB2YWx1ZSB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge1ZhbHVlUmFuZ2V9IHJhbmdlIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSB2YWx1ZS5cbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVtYmVyfSB0aGUgdmFsdWUgaWYgdmFsaWQuIEV4Y2VwdGlvbiBpcyB0aHJvd24gb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFRlbXBvcmFsVmFsdWUodmFsdWUsIHJhbmdlLCBuYW1lKSB7XG4gICAgKDAsIHV0aWxfMS5hc3NlcnROdW1iZXJPckludGVnZXIpKHZhbHVlLCBuYW1lKTtcbiAgICBpZiAoIXJhbmdlLmNvbnRhaW5zKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyAoMCwgZXJyb3JfMS5uZXdFcnJvcikoXCJcIi5jb25jYXQobmFtZSwgXCIgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gcmFuZ2UgXCIpLmNvbmNhdChyYW5nZS50b1N0cmluZygpLCBcIiBidXQgd2FzOiBcIikuY29uY2F0KHZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBnaXZlbiBsb2NhbCB0aW1lIGludG8gYSBzaW5nbGUgaW50ZWdlciByZXByZXNlbnRpbmcgdGhpcyBzYW1lIHRpbWUgaW4gc2Vjb25kcyBvZiB0aGUgZGF5LiBOYW5vc2Vjb25kcyBhcmUgc2tpcHBlZC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBob3VyIHRoZSBob3VyIG9mIHRoZSBsb2NhbCB0aW1lLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG1pbnV0ZSB0aGUgbWludXRlIG9mIHRoZSBsb2NhbCB0aW1lLlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHNlY29uZCB0aGUgc2Vjb25kIG9mIHRoZSBsb2NhbCB0aW1lLlxuICogQHJldHVybiB7SW50ZWdlcn0gc2Vjb25kcyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGxvY2FsIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsVGltZVRvU2Vjb25kT2ZEYXkoaG91ciwgbWludXRlLCBzZWNvbmQpIHtcbiAgICBob3VyID0gKDAsIGludGVnZXJfMS5pbnQpKGhvdXIpO1xuICAgIG1pbnV0ZSA9ICgwLCBpbnRlZ2VyXzEuaW50KShtaW51dGUpO1xuICAgIHNlY29uZCA9ICgwLCBpbnRlZ2VyXzEuaW50KShzZWNvbmQpO1xuICAgIHZhciB0b3RhbFNlY29uZHMgPSBob3VyLm11bHRpcGx5KGV4cG9ydHMuU0VDT05EU19QRVJfSE9VUik7XG4gICAgdG90YWxTZWNvbmRzID0gdG90YWxTZWNvbmRzLmFkZChtaW51dGUubXVsdGlwbHkoZXhwb3J0cy5TRUNPTkRTX1BFUl9NSU5VVEUpKTtcbiAgICByZXR1cm4gdG90YWxTZWNvbmRzLmFkZChzZWNvbmQpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBnaXZlbiB5ZWFyIGlzIGEgbGVhcCB5ZWFyLiBVc2VzIGFsZ29yaXRobSBkZXNjcmliZWQgaGVyZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGVhcF95ZWFyI0FsZ29yaXRobX0uXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30geWVhciB0aGUgeWVhciB0byBjaGVjay4gV2lsbCBiZSBjb252ZXJ0ZWQgdG8ge0BsaW5rIEludGVnZXJ9IGZvciBhbGwgY2FsY3VsYXRpb25zLlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIHllYXIgaXMgYSBsZWFwIHllYXIsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICB5ZWFyID0gKDAsIGludGVnZXJfMS5pbnQpKHllYXIpO1xuICAgIGlmICgheWVhci5tb2R1bG8oNCkuZXF1YWxzKDApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXllYXIubW9kdWxvKDEwMCkuZXF1YWxzKDApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgheWVhci5tb2R1bG8oNDAwKS5lcXVhbHMoMCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30geCB0aGUgZGl2aWRlbnQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30geSB0aGUgZGl2aXNvci5cbiAqIEByZXR1cm4ge0ludGVnZXJ9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGZsb29yRGl2KHgsIHkpIHtcbiAgICB4ID0gKDAsIGludGVnZXJfMS5pbnQpKHgpO1xuICAgIHkgPSAoMCwgaW50ZWdlcl8xLmludCkoeSk7XG4gICAgdmFyIHJlc3VsdCA9IHguZGl2KHkpO1xuICAgIGlmICh4LmlzUG9zaXRpdmUoKSAhPT0geS5pc1Bvc2l0aXZlKCkgJiYgcmVzdWx0Lm11bHRpcGx5KHkpLm5vdEVxdWFscyh4KSkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc3VidHJhY3QoMSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZsb29yRGl2ID0gZmxvb3JEaXY7XG4vKipcbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB4IHRoZSBkaXZpZGVudC5cbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB5IHRoZSBkaXZpc29yLlxuICogQHJldHVybiB7SW50ZWdlcn0gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gZmxvb3JNb2QoeCwgeSkge1xuICAgIHggPSAoMCwgaW50ZWdlcl8xLmludCkoeCk7XG4gICAgeSA9ICgwLCBpbnRlZ2VyXzEuaW50KSh5KTtcbiAgICByZXR1cm4geC5zdWJ0cmFjdChmbG9vckRpdih4LCB5KS5tdWx0aXBseSh5KSk7XG59XG5leHBvcnRzLmZsb29yTW9kID0gZmxvb3JNb2Q7XG4vKipcbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSBzZWNvbmRzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byBmb3JtYXQuXG4gKiBAcGFyYW0ge0ludGVnZXJ8bnVtYmVyfHN0cmluZ30gbmFub3NlY29uZHMgdGhlIG51bWJlciBvZiBuYW5vc2Vjb25kcyB0byBmb3JtYXQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0U2Vjb25kc0FuZE5hbm9zZWNvbmRzRm9yRHVyYXRpb24oc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgICBzZWNvbmRzID0gKDAsIGludGVnZXJfMS5pbnQpKHNlY29uZHMpO1xuICAgIG5hbm9zZWNvbmRzID0gKDAsIGludGVnZXJfMS5pbnQpKG5hbm9zZWNvbmRzKTtcbiAgICB2YXIgc2Vjb25kc1N0cmluZztcbiAgICB2YXIgbmFub3NlY29uZHNTdHJpbmc7XG4gICAgdmFyIHNlY29uZHNOZWdhdGl2ZSA9IHNlY29uZHMuaXNOZWdhdGl2ZSgpO1xuICAgIHZhciBuYW5vc2Vjb25kc0dyZWF0ZXJUaGFuWmVybyA9IG5hbm9zZWNvbmRzLmdyZWF0ZXJUaGFuKDApO1xuICAgIGlmIChzZWNvbmRzTmVnYXRpdmUgJiYgbmFub3NlY29uZHNHcmVhdGVyVGhhblplcm8pIHtcbiAgICAgICAgaWYgKHNlY29uZHMuZXF1YWxzKC0xKSkge1xuICAgICAgICAgICAgc2Vjb25kc1N0cmluZyA9ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWNvbmRzU3RyaW5nID0gc2Vjb25kcy5hZGQoMSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2Vjb25kc1N0cmluZyA9IHNlY29uZHMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKG5hbm9zZWNvbmRzR3JlYXRlclRoYW5aZXJvKSB7XG4gICAgICAgIGlmIChzZWNvbmRzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIG5hbm9zZWNvbmRzU3RyaW5nID0gZm9ybWF0TmFub3NlY29uZChuYW5vc2Vjb25kc1xuICAgICAgICAgICAgICAgIC5uZWdhdGUoKVxuICAgICAgICAgICAgICAgIC5hZGQoMiAqIGV4cG9ydHMuTkFOT1NfUEVSX1NFQ09ORClcbiAgICAgICAgICAgICAgICAubW9kdWxvKGV4cG9ydHMuTkFOT1NfUEVSX1NFQ09ORCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmFub3NlY29uZHNTdHJpbmcgPSBmb3JtYXROYW5vc2Vjb25kKG5hbm9zZWNvbmRzLmFkZChleHBvcnRzLk5BTk9TX1BFUl9TRUNPTkQpLm1vZHVsbyhleHBvcnRzLk5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmFub3NlY29uZHNTdHJpbmcgIT0gbnVsbCA/IHNlY29uZHNTdHJpbmcgKyBuYW5vc2Vjb25kc1N0cmluZyA6IHNlY29uZHNTdHJpbmc7XG59XG4vKipcbiAqIEBwYXJhbSB7SW50ZWdlcnxudW1iZXJ8c3RyaW5nfSB2YWx1ZSB0aGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzIHRvIGZvcm1hdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gZm9ybWF0dGVkIGFuZCBwb3NzaWJseSBsZWZ0LXBhZGRlZCBuYW5vc2Vjb25kcyBwYXJ0IGFzIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0TmFub3NlY29uZCh2YWx1ZSkge1xuICAgIHZhbHVlID0gKDAsIGludGVnZXJfMS5pbnQpKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWUuZXF1YWxzKDApID8gJycgOiAnLicgKyBmb3JtYXROdW1iZXIodmFsdWUsIDkpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IHllYXIgVGhlIHllYXIgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZvcm1hdHRlZCB5ZWFyXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFllYXIoeWVhcikge1xuICAgIHZhciB5ZWFySW50ZWdlciA9ICgwLCBpbnRlZ2VyXzEuaW50KSh5ZWFyKTtcbiAgICBpZiAoeWVhckludGVnZXIuaXNOZWdhdGl2ZSgpIHx8IHllYXJJbnRlZ2VyLmdyZWF0ZXJUaGFuKDk5OTkpKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoeWVhckludGVnZXIsIDYsIHsgdXNlUG9zaXRpdmVTaWduOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHllYXJJbnRlZ2VyLCA0KTtcbn1cbi8qKlxuICogQHBhcmFtIHtJbnRlZ2VyfG51bWJlcnxzdHJpbmd9IG51bSB0aGUgbnVtYmVyIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RyaW5nTGVuZ3RoPXVuZGVmaW5lZF0gdGhlIHN0cmluZyBsZW5ndGggdG8gbGVmdC1wYWQgdG8uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZvcm1hdHRlZCBhbmQgcG9zc2libHkgbGVmdC1wYWRkZWQgbnVtYmVyIGFzIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSwgc3RyaW5nTGVuZ3RoLCBwYXJhbXMpIHtcbiAgICBudW0gPSAoMCwgaW50ZWdlcl8xLmludCkobnVtKTtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IG51bS5pc05lZ2F0aXZlKCk7XG4gICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gbnVtLm5lZ2F0ZSgpO1xuICAgIH1cbiAgICB2YXIgbnVtU3RyaW5nID0gbnVtLnRvU3RyaW5nKCk7XG4gICAgaWYgKHN0cmluZ0xlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIC8vIGxlZnQgcGFkIHRoZSBzdHJpbmcgd2l0aCB6ZXJvZXNcbiAgICAgICAgd2hpbGUgKG51bVN0cmluZy5sZW5ndGggPCBzdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgICAgIG51bVN0cmluZyA9ICcwJyArIG51bVN0cmluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICByZXR1cm4gJy0nICsgbnVtU3RyaW5nO1xuICAgIH1cbiAgICBlbHNlIGlmICgocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnVzZVBvc2l0aXZlU2lnbikgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuICcrJyArIG51bVN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bVN0cmluZztcbn1cbmZ1bmN0aW9uIGFkZCh4LCB5KSB7XG4gICAgaWYgKHggaW5zdGFuY2VvZiBpbnRlZ2VyXzEuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4geC5hZGQoeSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4geCArIEJpZ0ludCh5KTtcbiAgICB9XG4gICAgcmV0dXJuIHggKyB5O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/temporal-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/transaction-executor.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/transaction-executor.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransactionExecutor = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar error_1 = __webpack_require__(/*! ../error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/constants.js\");\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\nfunction setTimeoutWrapper(callback, ms) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    return setTimeout.apply(void 0, __spreadArray([callback, ms], __read(args), false));\n}\nfunction clearTimeoutWrapper(timeoutId) {\n    return clearTimeout(timeoutId);\n}\nvar TransactionExecutor = /** @class */ (function () {\n    function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor, dependencies) {\n        if (dependencies === void 0) { dependencies = {\n            setTimeout: setTimeoutWrapper,\n            clearTimeout: clearTimeoutWrapper\n        }; }\n        this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\n        this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\n        this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n        this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n        this._setTimeout = dependencies.setTimeout;\n        this._clearTimeout = dependencies.clearTimeout;\n        this._inFlightTimeoutIds = [];\n        this.pipelineBegin = false;\n        this.telemetryApi = constants_1.TELEMETRY_APIS.MANAGED_TRANSACTION;\n        this._verifyAfterConstruction();\n    }\n    TransactionExecutor.prototype.execute = function (transactionCreator, transactionWork, transactionWrapper) {\n        var _this = this;\n        var context = {\n            apiTransactionConfig: {\n                api: this.telemetryApi,\n                onTelemetrySuccess: function () {\n                    context.apiTransactionConfig = undefined;\n                }\n            }\n        };\n        return new Promise(function (resolve, reject) {\n            _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject, transactionWrapper, context).catch(reject);\n        }).catch(function (error) {\n            var retryStartTimeMs = Date.now();\n            var retryDelayMs = _this._initialRetryDelayMs;\n            return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs, transactionWrapper, context);\n        });\n    };\n    TransactionExecutor.prototype.close = function () {\n        var _this = this;\n        // cancel all existing timeouts to prevent further retries\n        this._inFlightTimeoutIds.forEach(function (timeoutId) { return _this._clearTimeout(timeoutId); });\n        this._inFlightTimeoutIds = [];\n    };\n    TransactionExecutor.prototype._retryTransactionPromise = function (transactionCreator, transactionWork, error, retryStartTime, retryDelayMs, transactionWrapper, executionContext) {\n        var _this = this;\n        var elapsedTimeMs = Date.now() - retryStartTime;\n        if (elapsedTimeMs > this._maxRetryTimeMs || !(0, error_1.isRetriableError)(error)) {\n            return Promise.reject(error);\n        }\n        return new Promise(function (resolve, reject) {\n            var nextRetryTime = _this._computeDelayWithJitter(retryDelayMs);\n            var timeoutId = _this._setTimeout(function () {\n                // filter out this timeoutId when time has come and function is being executed\n                _this._inFlightTimeoutIds = _this._inFlightTimeoutIds.filter(function (id) { return id !== timeoutId; });\n                _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject, transactionWrapper, executionContext).catch(reject);\n            }, nextRetryTime);\n            // add newly created timeoutId to the list of all in-flight timeouts\n            _this._inFlightTimeoutIds.push(timeoutId);\n        }).catch(function (error) {\n            var nextRetryDelayMs = retryDelayMs * _this._multiplier;\n            return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs, transactionWrapper, executionContext);\n        });\n    };\n    TransactionExecutor.prototype._executeTransactionInsidePromise = function (transactionCreator, transactionWork, resolve, reject, transactionWrapper, executionContext) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tx, txPromise, _a, error_2, wrap, wrappedTx, resultPromise;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 4, , 5]);\n                        txPromise = transactionCreator((executionContext === null || executionContext === void 0 ? void 0 : executionContext.apiTransactionConfig) != null\n                            ? __assign({}, executionContext === null || executionContext === void 0 ? void 0 : executionContext.apiTransactionConfig) : undefined);\n                        if (!this.pipelineBegin) return [3 /*break*/, 1];\n                        _a = txPromise;\n                        return [3 /*break*/, 3];\n                    case 1: return [4 /*yield*/, txPromise];\n                    case 2:\n                        _a = _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        tx = _a;\n                        return [3 /*break*/, 5];\n                    case 4:\n                        error_2 = _b.sent();\n                        // failed to create a transaction\n                        reject(error_2);\n                        return [2 /*return*/];\n                    case 5:\n                        wrap = transactionWrapper !== null && transactionWrapper !== void 0 ? transactionWrapper : (function (tx) { return tx; });\n                        wrappedTx = wrap(tx);\n                        resultPromise = this._safeExecuteTransactionWork(wrappedTx, transactionWork);\n                        resultPromise\n                            .then(function (result) {\n                            return _this._handleTransactionWorkSuccess(result, tx, resolve, reject);\n                        })\n                            .catch(function (error) { return _this._handleTransactionWorkFailure(error, tx, reject); });\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    TransactionExecutor.prototype._safeExecuteTransactionWork = function (tx, transactionWork) {\n        try {\n            var result = transactionWork(tx);\n            // user defined callback is supposed to return a promise, but it might not; so to protect against an\n            // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\n            // validation step without type checks\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    };\n    TransactionExecutor.prototype._handleTransactionWorkSuccess = function (result, tx, resolve, reject) {\n        if (tx.isOpen()) {\n            // transaction work returned resolved promise and transaction has not been committed/rolled back\n            // try to commit the transaction\n            tx.commit()\n                .then(function () {\n                // transaction was committed, return result to the user\n                resolve(result);\n            })\n                .catch(function (error) {\n                // transaction failed to commit, propagate the failure\n                reject(error);\n            });\n        }\n        else {\n            // transaction work returned resolved promise and transaction is already committed/rolled back\n            // return the result returned by given transaction work\n            resolve(result);\n        }\n    };\n    TransactionExecutor.prototype._handleTransactionWorkFailure = function (error, tx, reject) {\n        if (tx.isOpen()) {\n            // transaction work failed and the transaction is still open, roll it back and propagate the failure\n            tx.rollback()\n                .catch(function (ignore) {\n                // ignore the rollback error\n            })\n                .then(function () { return reject(error); }) // propagate the original error we got from the transaction work\n                .catch(reject);\n        }\n        else {\n            // transaction is already rolled back, propagate the error\n            reject(error);\n        }\n    };\n    TransactionExecutor.prototype._computeDelayWithJitter = function (delayMs) {\n        var jitter = delayMs * this._jitterFactor;\n        var min = delayMs - jitter;\n        var max = delayMs + jitter;\n        return Math.random() * (max - min) + min;\n    };\n    TransactionExecutor.prototype._verifyAfterConstruction = function () {\n        if (this._maxRetryTimeMs < 0) {\n            throw (0, error_1.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs.toString());\n        }\n        if (this._initialRetryDelayMs < 0) {\n            throw (0, error_1.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs.toString());\n        }\n        if (this._multiplier < 1.0) {\n            throw (0, error_1.newError)('Multiplier should be >= 1.0: ' + this._multiplier.toString());\n        }\n        if (this._jitterFactor < 0 || this._jitterFactor > 1) {\n            throw (0, error_1.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor.toFixed());\n        }\n    };\n    return TransactionExecutor;\n}());\nexports.TransactionExecutor = TransactionExecutor;\nfunction _valueOrDefault(value, defaultValue) {\n    if (value != null) {\n        return value;\n    }\n    return defaultValue;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3RyYW5zYWN0aW9uLWV4ZWN1dG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHFFQUFVO0FBQ2hDLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3ZDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx3Q0FBd0M7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDBCQUEwQjtBQUN2SDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksWUFBWTtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNEQUFzRCxnRUFBZ0U7QUFDdEg7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEYsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvdHJhbnNhY3Rpb24tZXhlY3V0b3IuanM/Mzk2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uRXhlY3V0b3IgPSB2b2lkIDA7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbnZhciBlcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIERFRkFVTFRfTUFYX1JFVFJZX1RJTUVfTVMgPSAzMCAqIDEwMDA7IC8vIDMwIHNlY29uZHNcbnZhciBERUZBVUxUX0lOSVRJQUxfUkVUUllfREVMQVlfTVMgPSAxMDAwOyAvLyAxIHNlY29uZHNcbnZhciBERUZBVUxUX1JFVFJZX0RFTEFZX01VTFRJUExJRVIgPSAyLjA7XG52YXIgREVGQVVMVF9SRVRSWV9ERUxBWV9KSVRURVJfRkFDVE9SID0gMC4yO1xuZnVuY3Rpb24gc2V0VGltZW91dFdyYXBwZXIoY2FsbGJhY2ssIG1zKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gc2V0VGltZW91dC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW2NhbGxiYWNrLCBtc10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIGNsZWFyVGltZW91dFdyYXBwZXIodGltZW91dElkKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xufVxudmFyIFRyYW5zYWN0aW9uRXhlY3V0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNhY3Rpb25FeGVjdXRvcihtYXhSZXRyeVRpbWVNcywgaW5pdGlhbFJldHJ5RGVsYXlNcywgbXVsdGlwbGllciwgaml0dGVyRmFjdG9yLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQ6IHNldFRpbWVvdXRXcmFwcGVyLFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXRXcmFwcGVyXG4gICAgICAgIH07IH1cbiAgICAgICAgdGhpcy5fbWF4UmV0cnlUaW1lTXMgPSBfdmFsdWVPckRlZmF1bHQobWF4UmV0cnlUaW1lTXMsIERFRkFVTFRfTUFYX1JFVFJZX1RJTUVfTVMpO1xuICAgICAgICB0aGlzLl9pbml0aWFsUmV0cnlEZWxheU1zID0gX3ZhbHVlT3JEZWZhdWx0KGluaXRpYWxSZXRyeURlbGF5TXMsIERFRkFVTFRfSU5JVElBTF9SRVRSWV9ERUxBWV9NUyk7XG4gICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSBfdmFsdWVPckRlZmF1bHQobXVsdGlwbGllciwgREVGQVVMVF9SRVRSWV9ERUxBWV9NVUxUSVBMSUVSKTtcbiAgICAgICAgdGhpcy5faml0dGVyRmFjdG9yID0gX3ZhbHVlT3JEZWZhdWx0KGppdHRlckZhY3RvciwgREVGQVVMVF9SRVRSWV9ERUxBWV9KSVRURVJfRkFDVE9SKTtcbiAgICAgICAgdGhpcy5fc2V0VGltZW91dCA9IGRlcGVuZGVuY2llcy5zZXRUaW1lb3V0O1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQgPSBkZXBlbmRlbmNpZXMuY2xlYXJUaW1lb3V0O1xuICAgICAgICB0aGlzLl9pbkZsaWdodFRpbWVvdXRJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5waXBlbGluZUJlZ2luID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGVsZW1ldHJ5QXBpID0gY29uc3RhbnRzXzEuVEVMRU1FVFJZX0FQSVMuTUFOQUdFRF9UUkFOU0FDVElPTjtcbiAgICAgICAgdGhpcy5fdmVyaWZ5QWZ0ZXJDb25zdHJ1Y3Rpb24oKTtcbiAgICB9XG4gICAgVHJhbnNhY3Rpb25FeGVjdXRvci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkNyZWF0b3IsIHRyYW5zYWN0aW9uV29yaywgdHJhbnNhY3Rpb25XcmFwcGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgYXBpVHJhbnNhY3Rpb25Db25maWc6IHtcbiAgICAgICAgICAgICAgICBhcGk6IHRoaXMudGVsZW1ldHJ5QXBpLFxuICAgICAgICAgICAgICAgIG9uVGVsZW1ldHJ5U3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFwaVRyYW5zYWN0aW9uQ29uZmlnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLl9leGVjdXRlVHJhbnNhY3Rpb25JbnNpZGVQcm9taXNlKHRyYW5zYWN0aW9uQ3JlYXRvciwgdHJhbnNhY3Rpb25Xb3JrLCByZXNvbHZlLCByZWplY3QsIHRyYW5zYWN0aW9uV3JhcHBlciwgY29udGV4dCkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgcmV0cnlTdGFydFRpbWVNcyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB2YXIgcmV0cnlEZWxheU1zID0gX3RoaXMuX2luaXRpYWxSZXRyeURlbGF5TXM7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3JldHJ5VHJhbnNhY3Rpb25Qcm9taXNlKHRyYW5zYWN0aW9uQ3JlYXRvciwgdHJhbnNhY3Rpb25Xb3JrLCBlcnJvciwgcmV0cnlTdGFydFRpbWVNcywgcmV0cnlEZWxheU1zLCB0cmFuc2FjdGlvbldyYXBwZXIsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uRXhlY3V0b3IucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBjYW5jZWwgYWxsIGV4aXN0aW5nIHRpbWVvdXRzIHRvIHByZXZlbnQgZnVydGhlciByZXRyaWVzXG4gICAgICAgIHRoaXMuX2luRmxpZ2h0VGltZW91dElkcy5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lb3V0SWQpIHsgcmV0dXJuIF90aGlzLl9jbGVhclRpbWVvdXQodGltZW91dElkKTsgfSk7XG4gICAgICAgIHRoaXMuX2luRmxpZ2h0VGltZW91dElkcyA9IFtdO1xuICAgIH07XG4gICAgVHJhbnNhY3Rpb25FeGVjdXRvci5wcm90b3R5cGUuX3JldHJ5VHJhbnNhY3Rpb25Qcm9taXNlID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uQ3JlYXRvciwgdHJhbnNhY3Rpb25Xb3JrLCBlcnJvciwgcmV0cnlTdGFydFRpbWUsIHJldHJ5RGVsYXlNcywgdHJhbnNhY3Rpb25XcmFwcGVyLCBleGVjdXRpb25Db250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZU1zID0gRGF0ZS5ub3coKSAtIHJldHJ5U3RhcnRUaW1lO1xuICAgICAgICBpZiAoZWxhcHNlZFRpbWVNcyA+IHRoaXMuX21heFJldHJ5VGltZU1zIHx8ICEoMCwgZXJyb3JfMS5pc1JldHJpYWJsZUVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UmV0cnlUaW1lID0gX3RoaXMuX2NvbXB1dGVEZWxheVdpdGhKaXR0ZXIocmV0cnlEZWxheU1zKTtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0SWQgPSBfdGhpcy5fc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB0aGlzIHRpbWVvdXRJZCB3aGVuIHRpbWUgaGFzIGNvbWUgYW5kIGZ1bmN0aW9uIGlzIGJlaW5nIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgX3RoaXMuX2luRmxpZ2h0VGltZW91dElkcyA9IF90aGlzLl9pbkZsaWdodFRpbWVvdXRJZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgIT09IHRpbWVvdXRJZDsgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2V4ZWN1dGVUcmFuc2FjdGlvbkluc2lkZVByb21pc2UodHJhbnNhY3Rpb25DcmVhdG9yLCB0cmFuc2FjdGlvbldvcmssIHJlc29sdmUsIHJlamVjdCwgdHJhbnNhY3Rpb25XcmFwcGVyLCBleGVjdXRpb25Db250ZXh0KS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfSwgbmV4dFJldHJ5VGltZSk7XG4gICAgICAgICAgICAvLyBhZGQgbmV3bHkgY3JlYXRlZCB0aW1lb3V0SWQgdG8gdGhlIGxpc3Qgb2YgYWxsIGluLWZsaWdodCB0aW1lb3V0c1xuICAgICAgICAgICAgX3RoaXMuX2luRmxpZ2h0VGltZW91dElkcy5wdXNoKHRpbWVvdXRJZCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG5leHRSZXRyeURlbGF5TXMgPSByZXRyeURlbGF5TXMgKiBfdGhpcy5fbXVsdGlwbGllcjtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmV0cnlUcmFuc2FjdGlvblByb21pc2UodHJhbnNhY3Rpb25DcmVhdG9yLCB0cmFuc2FjdGlvbldvcmssIGVycm9yLCByZXRyeVN0YXJ0VGltZSwgbmV4dFJldHJ5RGVsYXlNcywgdHJhbnNhY3Rpb25XcmFwcGVyLCBleGVjdXRpb25Db250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUcmFuc2FjdGlvbkV4ZWN1dG9yLnByb3RvdHlwZS5fZXhlY3V0ZVRyYW5zYWN0aW9uSW5zaWRlUHJvbWlzZSA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkNyZWF0b3IsIHRyYW5zYWN0aW9uV29yaywgcmVzb2x2ZSwgcmVqZWN0LCB0cmFuc2FjdGlvbldyYXBwZXIsIGV4ZWN1dGlvbkNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHR4LCB0eFByb21pc2UsIF9hLCBlcnJvcl8yLCB3cmFwLCB3cmFwcGVkVHgsIHJlc3VsdFByb21pc2U7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4UHJvbWlzZSA9IHRyYW5zYWN0aW9uQ3JlYXRvcigoZXhlY3V0aW9uQ29udGV4dCA9PT0gbnVsbCB8fCBleGVjdXRpb25Db250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRpb25Db250ZXh0LmFwaVRyYW5zYWN0aW9uQ29uZmlnKSAhPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBfX2Fzc2lnbih7fSwgZXhlY3V0aW9uQ29udGV4dCA9PT0gbnVsbCB8fCBleGVjdXRpb25Db250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRpb25Db250ZXh0LmFwaVRyYW5zYWN0aW9uQ29uZmlnKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGlwZWxpbmVCZWdpbikgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHR4UHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIHR4UHJvbWlzZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgdG8gY3JlYXRlIGEgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcl8yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcCA9IHRyYW5zYWN0aW9uV3JhcHBlciAhPT0gbnVsbCAmJiB0cmFuc2FjdGlvbldyYXBwZXIgIT09IHZvaWQgMCA/IHRyYW5zYWN0aW9uV3JhcHBlciA6IChmdW5jdGlvbiAodHgpIHsgcmV0dXJuIHR4OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZWRUeCA9IHdyYXAodHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IHRoaXMuX3NhZmVFeGVjdXRlVHJhbnNhY3Rpb25Xb3JrKHdyYXBwZWRUeCwgdHJhbnNhY3Rpb25Xb3JrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVUcmFuc2FjdGlvbldvcmtTdWNjZXNzKHJlc3VsdCwgdHgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIF90aGlzLl9oYW5kbGVUcmFuc2FjdGlvbldvcmtGYWlsdXJlKGVycm9yLCB0eCwgcmVqZWN0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJhbnNhY3Rpb25FeGVjdXRvci5wcm90b3R5cGUuX3NhZmVFeGVjdXRlVHJhbnNhY3Rpb25Xb3JrID0gZnVuY3Rpb24gKHR4LCB0cmFuc2FjdGlvbldvcmspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2FjdGlvbldvcmsodHgpO1xuICAgICAgICAgICAgLy8gdXNlciBkZWZpbmVkIGNhbGxiYWNrIGlzIHN1cHBvc2VkIHRvIHJldHVybiBhIHByb21pc2UsIGJ1dCBpdCBtaWdodCBub3Q7IHNvIHRvIHByb3RlY3QgYWdhaW5zdCBhblxuICAgICAgICAgICAgLy8gaW5jb3JyZWN0IEFQSSB1c2FnZSB3ZSB3cmFwIHRoZSByZXR1cm5lZCB2YWx1ZSB3aXRoIGEgcmVzb2x2ZWQgcHJvbWlzZTsgdGhpcyBpcyBlZmZlY3RpdmVseSBhXG4gICAgICAgICAgICAvLyB2YWxpZGF0aW9uIHN0ZXAgd2l0aG91dCB0eXBlIGNoZWNrc1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNhY3Rpb25FeGVjdXRvci5wcm90b3R5cGUuX2hhbmRsZVRyYW5zYWN0aW9uV29ya1N1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0LCB0eCwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICh0eC5pc09wZW4oKSkge1xuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gd29yayByZXR1cm5lZCByZXNvbHZlZCBwcm9taXNlIGFuZCB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gY29tbWl0dGVkL3JvbGxlZCBiYWNrXG4gICAgICAgICAgICAvLyB0cnkgdG8gY29tbWl0IHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgdHguY29tbWl0KClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gd2FzIGNvbW1pdHRlZCwgcmV0dXJuIHJlc3VsdCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIGZhaWxlZCB0byBjb21taXQsIHByb3BhZ2F0ZSB0aGUgZmFpbHVyZVxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIHdvcmsgcmV0dXJuZWQgcmVzb2x2ZWQgcHJvbWlzZSBhbmQgdHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBjb21taXR0ZWQvcm9sbGVkIGJhY2tcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IGdpdmVuIHRyYW5zYWN0aW9uIHdvcmtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNhY3Rpb25FeGVjdXRvci5wcm90b3R5cGUuX2hhbmRsZVRyYW5zYWN0aW9uV29ya0ZhaWx1cmUgPSBmdW5jdGlvbiAoZXJyb3IsIHR4LCByZWplY3QpIHtcbiAgICAgICAgaWYgKHR4LmlzT3BlbigpKSB7XG4gICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiB3b3JrIGZhaWxlZCBhbmQgdGhlIHRyYW5zYWN0aW9uIGlzIHN0aWxsIG9wZW4sIHJvbGwgaXQgYmFjayBhbmQgcHJvcGFnYXRlIHRoZSBmYWlsdXJlXG4gICAgICAgICAgICB0eC5yb2xsYmFjaygpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdGhlIHJvbGxiYWNrIGVycm9yXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChlcnJvcik7IH0pIC8vIHByb3BhZ2F0ZSB0aGUgb3JpZ2luYWwgZXJyb3Igd2UgZ290IGZyb20gdGhlIHRyYW5zYWN0aW9uIHdvcmtcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIGlzIGFscmVhZHkgcm9sbGVkIGJhY2ssIHByb3BhZ2F0ZSB0aGUgZXJyb3JcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uRXhlY3V0b3IucHJvdG90eXBlLl9jb21wdXRlRGVsYXlXaXRoSml0dGVyID0gZnVuY3Rpb24gKGRlbGF5TXMpIHtcbiAgICAgICAgdmFyIGppdHRlciA9IGRlbGF5TXMgKiB0aGlzLl9qaXR0ZXJGYWN0b3I7XG4gICAgICAgIHZhciBtaW4gPSBkZWxheU1zIC0gaml0dGVyO1xuICAgICAgICB2YXIgbWF4ID0gZGVsYXlNcyArIGppdHRlcjtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uRXhlY3V0b3IucHJvdG90eXBlLl92ZXJpZnlBZnRlckNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21heFJldHJ5VGltZU1zIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdNYXggcmV0cnkgdGltZSBzaG91bGQgYmUgPj0gMDogJyArIHRoaXMuX21heFJldHJ5VGltZU1zLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsUmV0cnlEZWxheU1zIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdJbml0aWFsIHJldHJ5IGRlbGF5IHNob3VsZCA+PSAwOiAnICsgdGhpcy5faW5pdGlhbFJldHJ5RGVsYXlNcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbXVsdGlwbGllciA8IDEuMCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdNdWx0aXBsaWVyIHNob3VsZCBiZSA+PSAxLjA6ICcgKyB0aGlzLl9tdWx0aXBsaWVyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9qaXR0ZXJGYWN0b3IgPCAwIHx8IHRoaXMuX2ppdHRlckZhY3RvciA+IDEpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnSml0dGVyIGZhY3RvciBzaG91bGQgYmUgaW4gWzAuMCwgMS4wXTogJyArIHRoaXMuX2ppdHRlckZhY3Rvci50b0ZpeGVkKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25FeGVjdXRvcjtcbn0oKSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uRXhlY3V0b3IgPSBUcmFuc2FjdGlvbkV4ZWN1dG9yO1xuZnVuY3Rpb24gX3ZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/transaction-executor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/tx-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/tx-config.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TxConfig = void 0;\nvar util = __importStar(__webpack_require__(/*! ./util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\"));\nvar error_1 = __webpack_require__(/*! ../error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar integer_1 = __webpack_require__(/*! ../integer */ \"(rsc)/./node_modules/neo4j-driver-core/lib/integer.js\");\n/**\n * Internal holder of the transaction configuration.\n * It performs input validation and value conversion for further serialization by the Bolt protocol layer.\n * Users of the driver provide transaction configuration as regular objects `{timeout: 10, metadata: {key: 'value'}}`.\n * Driver converts such objects to {@link TxConfig} immediately and uses converted values everywhere.\n */\nvar TxConfig = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} config the raw configuration object.\n     */\n    function TxConfig(config, log) {\n        assertValidConfig(config);\n        this.timeout = extractTimeout(config, log);\n        this.metadata = extractMetadata(config);\n    }\n    /**\n     * Get an empty config object.\n     * @return {TxConfig} an empty config.\n     */\n    TxConfig.empty = function () {\n        return EMPTY_CONFIG;\n    };\n    /**\n     * Check if this config object is empty. I.e. has no configuration values specified.\n     * @return {boolean} `true` if this object is empty, `false` otherwise.\n     */\n    TxConfig.prototype.isEmpty = function () {\n        return Object.values(this).every(function (value) { return value == null; });\n    };\n    return TxConfig;\n}());\nexports.TxConfig = TxConfig;\nvar EMPTY_CONFIG = new TxConfig({});\n/**\n * @return {Integer|null}\n */\nfunction extractTimeout(config, log) {\n    if (util.isObject(config) && config.timeout != null) {\n        util.assertNumberOrInteger(config.timeout, 'Transaction timeout');\n        if (isTimeoutFloat(config) && (log === null || log === void 0 ? void 0 : log.isInfoEnabled()) === true) {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            log === null || log === void 0 ? void 0 : log.info(\"Transaction timeout expected to be an integer, got: \".concat(config.timeout, \". The value will be rounded up.\"));\n        }\n        var timeout = (0, integer_1.int)(config.timeout, { ceilFloat: true });\n        if (timeout.isNegative()) {\n            throw (0, error_1.newError)('Transaction timeout should not be negative');\n        }\n        return timeout;\n    }\n    return null;\n}\nfunction isTimeoutFloat(config) {\n    return typeof config.timeout === 'number' && !Number.isInteger(config.timeout);\n}\n/**\n * @return {object|null}\n */\nfunction extractMetadata(config) {\n    if (util.isObject(config) && config.metadata != null) {\n        var metadata = config.metadata;\n        util.assertObject(metadata, 'config.metadata');\n        if (Object.keys(metadata).length !== 0) {\n            // not an empty object\n            return metadata;\n        }\n    }\n    return null;\n}\nfunction assertValidConfig(config) {\n    if (config != null) {\n        util.assertObject(config, 'Transaction config');\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3R4LWNvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsd0JBQXdCLG1CQUFPLENBQUMsMkVBQVE7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLHFFQUFVO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSx3QkFBd0IsY0FBYztBQUNwSCxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsNERBQTRELHVCQUF1QjtBQUNuRjtBQUNBO0FBQ0EsQ0FBQztBQUNELGdCQUFnQjtBQUNoQixrQ0FBa0M7QUFDbEM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvaW50ZXJuYWwvdHgtY29uZmlnLmpzP2YzNmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR4Q29uZmlnID0gdm9pZCAwO1xudmFyIHV0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbFwiKSk7XG52YXIgZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvclwiKTtcbnZhciBpbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vaW50ZWdlclwiKTtcbi8qKlxuICogSW50ZXJuYWwgaG9sZGVyIG9mIHRoZSB0cmFuc2FjdGlvbiBjb25maWd1cmF0aW9uLlxuICogSXQgcGVyZm9ybXMgaW5wdXQgdmFsaWRhdGlvbiBhbmQgdmFsdWUgY29udmVyc2lvbiBmb3IgZnVydGhlciBzZXJpYWxpemF0aW9uIGJ5IHRoZSBCb2x0IHByb3RvY29sIGxheWVyLlxuICogVXNlcnMgb2YgdGhlIGRyaXZlciBwcm92aWRlIHRyYW5zYWN0aW9uIGNvbmZpZ3VyYXRpb24gYXMgcmVndWxhciBvYmplY3RzIGB7dGltZW91dDogMTAsIG1ldGFkYXRhOiB7a2V5OiAndmFsdWUnfX1gLlxuICogRHJpdmVyIGNvbnZlcnRzIHN1Y2ggb2JqZWN0cyB0byB7QGxpbmsgVHhDb25maWd9IGltbWVkaWF0ZWx5IGFuZCB1c2VzIGNvbnZlcnRlZCB2YWx1ZXMgZXZlcnl3aGVyZS5cbiAqL1xudmFyIFR4Q29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgdGhlIHJhdyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUeENvbmZpZyhjb25maWcsIGxvZykge1xuICAgICAgICBhc3NlcnRWYWxpZENvbmZpZyhjb25maWcpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBleHRyYWN0VGltZW91dChjb25maWcsIGxvZyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBleHRyYWN0TWV0YWRhdGEoY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuIGVtcHR5IGNvbmZpZyBvYmplY3QuXG4gICAgICogQHJldHVybiB7VHhDb25maWd9IGFuIGVtcHR5IGNvbmZpZy5cbiAgICAgKi9cbiAgICBUeENvbmZpZy5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX0NPTkZJRztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgY29uZmlnIG9iamVjdCBpcyBlbXB0eS4gSS5lLiBoYXMgbm8gY29uZmlndXJhdGlvbiB2YWx1ZXMgc3BlY2lmaWVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGlzIG9iamVjdCBpcyBlbXB0eSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgVHhDb25maWcucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMpLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT0gbnVsbDsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHhDb25maWc7XG59KCkpO1xuZXhwb3J0cy5UeENvbmZpZyA9IFR4Q29uZmlnO1xudmFyIEVNUFRZX0NPTkZJRyA9IG5ldyBUeENvbmZpZyh7fSk7XG4vKipcbiAqIEByZXR1cm4ge0ludGVnZXJ8bnVsbH1cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFRpbWVvdXQoY29uZmlnLCBsb2cpIHtcbiAgICBpZiAodXRpbC5pc09iamVjdChjb25maWcpICYmIGNvbmZpZy50aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgdXRpbC5hc3NlcnROdW1iZXJPckludGVnZXIoY29uZmlnLnRpbWVvdXQsICdUcmFuc2FjdGlvbiB0aW1lb3V0Jyk7XG4gICAgICAgIGlmIChpc1RpbWVvdXRGbG9hdChjb25maWcpICYmIChsb2cgPT09IG51bGwgfHwgbG9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2cuaXNJbmZvRW5hYmxlZCgpKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgbG9nID09PSBudWxsIHx8IGxvZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nLmluZm8oXCJUcmFuc2FjdGlvbiB0aW1lb3V0IGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIsIGdvdDogXCIuY29uY2F0KGNvbmZpZy50aW1lb3V0LCBcIi4gVGhlIHZhbHVlIHdpbGwgYmUgcm91bmRlZCB1cC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lb3V0ID0gKDAsIGludGVnZXJfMS5pbnQpKGNvbmZpZy50aW1lb3V0LCB7IGNlaWxGbG9hdDogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKHRpbWVvdXQuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JfMS5uZXdFcnJvcikoJ1RyYW5zYWN0aW9uIHRpbWVvdXQgc2hvdWxkIG5vdCBiZSBuZWdhdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzVGltZW91dEZsb2F0KGNvbmZpZykge1xuICAgIHJldHVybiB0eXBlb2YgY29uZmlnLnRpbWVvdXQgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNJbnRlZ2VyKGNvbmZpZy50aW1lb3V0KTtcbn1cbi8qKlxuICogQHJldHVybiB7b2JqZWN0fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNZXRhZGF0YShjb25maWcpIHtcbiAgICBpZiAodXRpbC5pc09iamVjdChjb25maWcpICYmIGNvbmZpZy5tZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGNvbmZpZy5tZXRhZGF0YTtcbiAgICAgICAgdXRpbC5hc3NlcnRPYmplY3QobWV0YWRhdGEsICdjb25maWcubWV0YWRhdGEnKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1ldGFkYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIC8vIG5vdCBhbiBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGFzc2VydFZhbGlkQ29uZmlnKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB1dGlsLmFzc2VydE9iamVjdChjb25maWcsICdUcmFuc2FjdGlvbiBjb25maWcnKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/tx-config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/url-util.js":
/*!*****************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/url-util.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Url = exports.formatIPv6Address = exports.formatIPv4Address = exports.defaultPortForScheme = exports.parseDatabaseUrl = void 0;\nvar util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\nvar DEFAULT_BOLT_PORT = 7687;\nvar DEFAULT_HTTP_PORT = 7474;\nvar DEFAULT_HTTPS_PORT = 7473;\nvar Url = /** @class */ (function () {\n    function Url(scheme, host, port, hostAndPort, query) {\n        /**\n         * Nullable scheme (protocol) of the URL.\n         * Example: 'bolt', 'neo4j', 'http', 'https', etc.\n         * @type {string}\n         */\n        this.scheme = scheme;\n        /**\n         * Nonnull host name or IP address. IPv6 not wrapped in square brackets.\n         * Example: 'neo4j.com', 'localhost', '127.0.0.1', '192.168.10.15', '::1', '2001:4860:4860::8844', etc.\n         * @type {string}\n         */\n        this.host = host;\n        /**\n         * Nonnull number representing port. Default port for the given scheme is used if given URL string\n         * does not contain port. Example: 7687 for bolt, 7474 for HTTP and 7473 for HTTPS.\n         * @type {number}\n         */\n        this.port = port;\n        /**\n         * Nonnull host name or IP address plus port, separated by ':'. IPv6 wrapped in square brackets.\n         * Example: 'neo4j.com', 'neo4j.com:7687', '127.0.0.1', '127.0.0.1:8080', '[2001:4860:4860::8844]',\n         * '[2001:4860:4860::8844]:9090', etc.\n         * @type {string}\n         */\n        this.hostAndPort = hostAndPort;\n        /**\n         * Nonnull object representing parsed query string key-value pairs. Duplicated keys not supported.\n         * Example: '{}', '{'key1': 'value1', 'key2': 'value2'}', etc.\n         * @type {Object}\n         */\n        this.query = query;\n    }\n    return Url;\n}());\nexports.Url = Url;\nfunction parseDatabaseUrl(url) {\n    var _a;\n    (0, util_1.assertString)(url, 'URL');\n    var sanitized = sanitizeUrl(url);\n    var parsedUrl = uriJsParse(sanitized.url);\n    var scheme = sanitized.schemeMissing\n        ? null\n        : extractScheme(parsedUrl.scheme);\n    var host = extractHost(parsedUrl.host); // no square brackets for IPv6\n    var formattedHost = formatHost(host); // has square brackets for IPv6\n    var port = extractPort(parsedUrl.port, scheme);\n    var hostAndPort = \"\".concat(formattedHost, \":\").concat(port);\n    var query = extractQuery(\n    // @ts-expect-error\n    (_a = parsedUrl.query) !== null && _a !== void 0 ? _a : extractResourceQueryString(parsedUrl.resourceName), url);\n    return new Url(scheme, host, port, hostAndPort, query);\n}\nexports.parseDatabaseUrl = parseDatabaseUrl;\nfunction extractResourceQueryString(resource) {\n    if (typeof resource !== 'string') {\n        return null;\n    }\n    var _a = __read(resource.split('?'), 2), query = _a[1];\n    return query;\n}\nfunction sanitizeUrl(url) {\n    url = url.trim();\n    if (!url.includes('://')) {\n        // url does not contain scheme, add dummy 'none://' to make parser work correctly\n        return { schemeMissing: true, url: \"none://\".concat(url) };\n    }\n    return { schemeMissing: false, url: url };\n}\nfunction extractScheme(scheme) {\n    if (scheme != null) {\n        scheme = scheme.trim();\n        if (scheme.charAt(scheme.length - 1) === ':') {\n            scheme = scheme.substring(0, scheme.length - 1);\n        }\n        return scheme;\n    }\n    return null;\n}\nfunction extractHost(host, url) {\n    if (host == null) {\n        throw new Error('Unable to extract host from null or undefined URL');\n    }\n    return host.trim();\n}\nfunction extractPort(portString, scheme) {\n    var port = typeof portString === 'string' ? parseInt(portString, 10) : portString;\n    return port != null && !isNaN(port) ? port : defaultPortForScheme(scheme);\n}\nfunction extractQuery(queryString, url) {\n    var query = queryString != null ? trimAndSanitizeQuery(queryString) : null;\n    var context = {};\n    if (query != null) {\n        query.split('&').forEach(function (pair) {\n            var keyValue = pair.split('=');\n            if (keyValue.length !== 2) {\n                throw new Error(\"Invalid parameters: '\".concat(keyValue.toString(), \"' in URL '\").concat(url, \"'.\"));\n            }\n            var key = trimAndVerifyQueryElement(keyValue[0], 'key', url);\n            var value = trimAndVerifyQueryElement(keyValue[1], 'value', url);\n            if (context[key] !== undefined) {\n                throw new Error(\"Duplicated query parameters with key '\".concat(key, \"' in URL '\").concat(url, \"'\"));\n            }\n            context[key] = value;\n        });\n    }\n    return context;\n}\nfunction trimAndSanitizeQuery(query) {\n    query = (query !== null && query !== void 0 ? query : '').trim();\n    if ((query === null || query === void 0 ? void 0 : query.charAt(0)) === '?') {\n        query = query.substring(1, query.length);\n    }\n    return query;\n}\nfunction trimAndVerifyQueryElement(element, name, url) {\n    element = (element !== null && element !== void 0 ? element : '').trim();\n    if (element === '') {\n        throw new Error(\"Illegal empty \".concat(name, \" in URL query '\").concat(url, \"'\"));\n    }\n    return element;\n}\nfunction escapeIPv6Address(address) {\n    var startsWithSquareBracket = address.charAt(0) === '[';\n    var endsWithSquareBracket = address.charAt(address.length - 1) === ']';\n    if (!startsWithSquareBracket && !endsWithSquareBracket) {\n        return \"[\".concat(address, \"]\");\n    }\n    else if (startsWithSquareBracket && endsWithSquareBracket) {\n        return address;\n    }\n    else {\n        throw new Error(\"Illegal IPv6 address \".concat(address));\n    }\n}\nfunction formatHost(host) {\n    if (host === '' || host == null) {\n        throw new Error(\"Illegal host \".concat(host));\n    }\n    var isIPv6Address = host.includes(':');\n    return isIPv6Address ? escapeIPv6Address(host) : host;\n}\nfunction formatIPv4Address(address, port) {\n    return \"\".concat(address, \":\").concat(port);\n}\nexports.formatIPv4Address = formatIPv4Address;\nfunction formatIPv6Address(address, port) {\n    var escapedAddress = escapeIPv6Address(address);\n    return \"\".concat(escapedAddress, \":\").concat(port);\n}\nexports.formatIPv6Address = formatIPv6Address;\nfunction defaultPortForScheme(scheme) {\n    if (scheme === 'http') {\n        return DEFAULT_HTTP_PORT;\n    }\n    else if (scheme === 'https') {\n        return DEFAULT_HTTPS_PORT;\n    }\n    else {\n        return DEFAULT_BOLT_PORT;\n    }\n}\nexports.defaultPortForScheme = defaultPortForScheme;\nfunction uriJsParse(value) {\n    // JS version of Python partition function\n    function partition(s, delimiter) {\n        var i = s.indexOf(delimiter);\n        if (i >= 0)\n            return [s.substring(0, i), s[i], s.substring(i + 1)];\n        else\n            return [s, '', ''];\n    }\n    // JS version of Python rpartition function\n    function rpartition(s, delimiter) {\n        var i = s.lastIndexOf(delimiter);\n        if (i >= 0)\n            return [s.substring(0, i), s[i], s.substring(i + 1)];\n        else\n            return ['', '', s];\n    }\n    function between(s, ldelimiter, rdelimiter) {\n        var lpartition = partition(s, ldelimiter);\n        var rpartition = partition(lpartition[2], rdelimiter);\n        return [rpartition[0], rpartition[2]];\n    }\n    // Parse an authority string into an object\n    // with the following keys:\n    // - userInfo (optional, might contain both user name and password)\n    // - host\n    // - port (optional, included only as a string)\n    function parseAuthority(value) {\n        var parsed = {};\n        var parts;\n        // Parse user info\n        parts = rpartition(value, '@');\n        if (parts[1] === '@') {\n            parsed.userInfo = decodeURIComponent(parts[0]);\n            value = parts[2];\n        }\n        // Parse host and port\n        var _a = __read(between(value, '[', ']'), 2), ipv6Host = _a[0], rest = _a[1];\n        if (ipv6Host !== '') {\n            parsed.host = ipv6Host;\n            parts = partition(rest, ':');\n        }\n        else {\n            parts = partition(value, ':');\n            parsed.host = parts[0];\n        }\n        if (parts[1] === ':') {\n            parsed.port = parts[2];\n        }\n        return parsed;\n    }\n    var parsed = {};\n    var parts;\n    // Parse scheme\n    parts = partition(value, ':');\n    if (parts[1] === ':') {\n        parsed.scheme = decodeURIComponent(parts[0]);\n        value = parts[2];\n    }\n    // Parse fragment\n    parts = partition(value, '#');\n    if (parts[1] === '#') {\n        parsed.fragment = decodeURIComponent(parts[2]);\n        value = parts[0];\n    }\n    // Parse query\n    parts = partition(value, '?');\n    if (parts[1] === '?') {\n        parsed.query = parts[2];\n        value = parts[0];\n    }\n    // Parse authority and path\n    if (value.startsWith('//')) {\n        parts = partition(value.substr(2), '/');\n        parsed = __assign(__assign({}, parsed), parseAuthority(parts[0]));\n        parsed.path = parts[1] + parts[2];\n    }\n    else {\n        parsed.path = value;\n    }\n    return parsed;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3VybC11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyw0QkFBNEIsR0FBRyx3QkFBd0I7QUFDN0gsYUFBYSxtQkFBTyxDQUFDLDJFQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLLG1DQUFtQztBQUMvRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3VybC11dGlsLmpzP2E0MTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXJsID0gZXhwb3J0cy5mb3JtYXRJUHY2QWRkcmVzcyA9IGV4cG9ydHMuZm9ybWF0SVB2NEFkZHJlc3MgPSBleHBvcnRzLmRlZmF1bHRQb3J0Rm9yU2NoZW1lID0gZXhwb3J0cy5wYXJzZURhdGFiYXNlVXJsID0gdm9pZCAwO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgREVGQVVMVF9CT0xUX1BPUlQgPSA3Njg3O1xudmFyIERFRkFVTFRfSFRUUF9QT1JUID0gNzQ3NDtcbnZhciBERUZBVUxUX0hUVFBTX1BPUlQgPSA3NDczO1xudmFyIFVybCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmwoc2NoZW1lLCBob3N0LCBwb3J0LCBob3N0QW5kUG9ydCwgcXVlcnkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bGxhYmxlIHNjaGVtZSAocHJvdG9jb2wpIG9mIHRoZSBVUkwuXG4gICAgICAgICAqIEV4YW1wbGU6ICdib2x0JywgJ25lbzRqJywgJ2h0dHAnLCAnaHR0cHMnLCBldGMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVtZSA9IHNjaGVtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbm51bGwgaG9zdCBuYW1lIG9yIElQIGFkZHJlc3MuIElQdjYgbm90IHdyYXBwZWQgaW4gc3F1YXJlIGJyYWNrZXRzLlxuICAgICAgICAgKiBFeGFtcGxlOiAnbmVvNGouY29tJywgJ2xvY2FsaG9zdCcsICcxMjcuMC4wLjEnLCAnMTkyLjE2OC4xMC4xNScsICc6OjEnLCAnMjAwMTo0ODYwOjQ4NjA6Ojg4NDQnLCBldGMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICAvKipcbiAgICAgICAgICogTm9ubnVsbCBudW1iZXIgcmVwcmVzZW50aW5nIHBvcnQuIERlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHNjaGVtZSBpcyB1c2VkIGlmIGdpdmVuIFVSTCBzdHJpbmdcbiAgICAgICAgICogZG9lcyBub3QgY29udGFpbiBwb3J0LiBFeGFtcGxlOiA3Njg3IGZvciBib2x0LCA3NDc0IGZvciBIVFRQIGFuZCA3NDczIGZvciBIVFRQUy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9ydCA9IHBvcnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb25udWxsIGhvc3QgbmFtZSBvciBJUCBhZGRyZXNzIHBsdXMgcG9ydCwgc2VwYXJhdGVkIGJ5ICc6Jy4gSVB2NiB3cmFwcGVkIGluIHNxdWFyZSBicmFja2V0cy5cbiAgICAgICAgICogRXhhbXBsZTogJ25lbzRqLmNvbScsICduZW80ai5jb206NzY4NycsICcxMjcuMC4wLjEnLCAnMTI3LjAuMC4xOjgwODAnLCAnWzIwMDE6NDg2MDo0ODYwOjo4ODQ0XScsXG4gICAgICAgICAqICdbMjAwMTo0ODYwOjQ4NjA6Ojg4NDRdOjkwOTAnLCBldGMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvc3RBbmRQb3J0ID0gaG9zdEFuZFBvcnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb25udWxsIG9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIHF1ZXJ5IHN0cmluZyBrZXktdmFsdWUgcGFpcnMuIER1cGxpY2F0ZWQga2V5cyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAgKiBFeGFtcGxlOiAne30nLCAneydrZXkxJzogJ3ZhbHVlMScsICdrZXkyJzogJ3ZhbHVlMid9JywgZXRjLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIH1cbiAgICByZXR1cm4gVXJsO1xufSgpKTtcbmV4cG9ydHMuVXJsID0gVXJsO1xuZnVuY3Rpb24gcGFyc2VEYXRhYmFzZVVybCh1cmwpIHtcbiAgICB2YXIgX2E7XG4gICAgKDAsIHV0aWxfMS5hc3NlcnRTdHJpbmcpKHVybCwgJ1VSTCcpO1xuICAgIHZhciBzYW5pdGl6ZWQgPSBzYW5pdGl6ZVVybCh1cmwpO1xuICAgIHZhciBwYXJzZWRVcmwgPSB1cmlKc1BhcnNlKHNhbml0aXplZC51cmwpO1xuICAgIHZhciBzY2hlbWUgPSBzYW5pdGl6ZWQuc2NoZW1lTWlzc2luZ1xuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBleHRyYWN0U2NoZW1lKHBhcnNlZFVybC5zY2hlbWUpO1xuICAgIHZhciBob3N0ID0gZXh0cmFjdEhvc3QocGFyc2VkVXJsLmhvc3QpOyAvLyBubyBzcXVhcmUgYnJhY2tldHMgZm9yIElQdjZcbiAgICB2YXIgZm9ybWF0dGVkSG9zdCA9IGZvcm1hdEhvc3QoaG9zdCk7IC8vIGhhcyBzcXVhcmUgYnJhY2tldHMgZm9yIElQdjZcbiAgICB2YXIgcG9ydCA9IGV4dHJhY3RQb3J0KHBhcnNlZFVybC5wb3J0LCBzY2hlbWUpO1xuICAgIHZhciBob3N0QW5kUG9ydCA9IFwiXCIuY29uY2F0KGZvcm1hdHRlZEhvc3QsIFwiOlwiKS5jb25jYXQocG9ydCk7XG4gICAgdmFyIHF1ZXJ5ID0gZXh0cmFjdFF1ZXJ5KFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAoX2EgPSBwYXJzZWRVcmwucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4dHJhY3RSZXNvdXJjZVF1ZXJ5U3RyaW5nKHBhcnNlZFVybC5yZXNvdXJjZU5hbWUpLCB1cmwpO1xuICAgIHJldHVybiBuZXcgVXJsKHNjaGVtZSwgaG9zdCwgcG9ydCwgaG9zdEFuZFBvcnQsIHF1ZXJ5KTtcbn1cbmV4cG9ydHMucGFyc2VEYXRhYmFzZVVybCA9IHBhcnNlRGF0YWJhc2VVcmw7XG5mdW5jdGlvbiBleHRyYWN0UmVzb3VyY2VRdWVyeVN0cmluZyhyZXNvdXJjZSkge1xuICAgIGlmICh0eXBlb2YgcmVzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgX2EgPSBfX3JlYWQocmVzb3VyY2Uuc3BsaXQoJz8nKSwgMiksIHF1ZXJ5ID0gX2FbMV07XG4gICAgcmV0dXJuIHF1ZXJ5O1xufVxuZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKSB7XG4gICAgdXJsID0gdXJsLnRyaW0oKTtcbiAgICBpZiAoIXVybC5pbmNsdWRlcygnOi8vJykpIHtcbiAgICAgICAgLy8gdXJsIGRvZXMgbm90IGNvbnRhaW4gc2NoZW1lLCBhZGQgZHVtbXkgJ25vbmU6Ly8nIHRvIG1ha2UgcGFyc2VyIHdvcmsgY29ycmVjdGx5XG4gICAgICAgIHJldHVybiB7IHNjaGVtZU1pc3Npbmc6IHRydWUsIHVybDogXCJub25lOi8vXCIuY29uY2F0KHVybCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2NoZW1lTWlzc2luZzogZmFsc2UsIHVybDogdXJsIH07XG59XG5mdW5jdGlvbiBleHRyYWN0U2NoZW1lKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUgIT0gbnVsbCkge1xuICAgICAgICBzY2hlbWUgPSBzY2hlbWUudHJpbSgpO1xuICAgICAgICBpZiAoc2NoZW1lLmNoYXJBdChzY2hlbWUubGVuZ3RoIC0gMSkgPT09ICc6Jykge1xuICAgICAgICAgICAgc2NoZW1lID0gc2NoZW1lLnN1YnN0cmluZygwLCBzY2hlbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBleHRyYWN0SG9zdChob3N0LCB1cmwpIHtcbiAgICBpZiAoaG9zdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGV4dHJhY3QgaG9zdCBmcm9tIG51bGwgb3IgdW5kZWZpbmVkIFVSTCcpO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdC50cmltKCk7XG59XG5mdW5jdGlvbiBleHRyYWN0UG9ydChwb3J0U3RyaW5nLCBzY2hlbWUpIHtcbiAgICB2YXIgcG9ydCA9IHR5cGVvZiBwb3J0U3RyaW5nID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHBvcnRTdHJpbmcsIDEwKSA6IHBvcnRTdHJpbmc7XG4gICAgcmV0dXJuIHBvcnQgIT0gbnVsbCAmJiAhaXNOYU4ocG9ydCkgPyBwb3J0IDogZGVmYXVsdFBvcnRGb3JTY2hlbWUoc2NoZW1lKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeShxdWVyeVN0cmluZywgdXJsKSB7XG4gICAgdmFyIHF1ZXJ5ID0gcXVlcnlTdHJpbmcgIT0gbnVsbCA/IHRyaW1BbmRTYW5pdGl6ZVF1ZXJ5KHF1ZXJ5U3RyaW5nKSA6IG51bGw7XG4gICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICBpZiAocXVlcnkgIT0gbnVsbCkge1xuICAgICAgICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IHBhaXIuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIGlmIChrZXlWYWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlcnM6ICdcIi5jb25jYXQoa2V5VmFsdWUudG9TdHJpbmcoKSwgXCInIGluIFVSTCAnXCIpLmNvbmNhdCh1cmwsIFwiJy5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IHRyaW1BbmRWZXJpZnlRdWVyeUVsZW1lbnQoa2V5VmFsdWVbMF0sICdrZXknLCB1cmwpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdHJpbUFuZFZlcmlmeVF1ZXJ5RWxlbWVudChrZXlWYWx1ZVsxXSwgJ3ZhbHVlJywgdXJsKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0W2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZWQgcXVlcnkgcGFyYW1ldGVycyB3aXRoIGtleSAnXCIuY29uY2F0KGtleSwgXCInIGluIFVSTCAnXCIpLmNvbmNhdCh1cmwsIFwiJ1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gdHJpbUFuZFNhbml0aXplUXVlcnkocXVlcnkpIHtcbiAgICBxdWVyeSA9IChxdWVyeSAhPT0gbnVsbCAmJiBxdWVyeSAhPT0gdm9pZCAwID8gcXVlcnkgOiAnJykudHJpbSgpO1xuICAgIGlmICgocXVlcnkgPT09IG51bGwgfHwgcXVlcnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHF1ZXJ5LmNoYXJBdCgwKSkgPT09ICc/Jykge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LnN1YnN0cmluZygxLCBxdWVyeS5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiB0cmltQW5kVmVyaWZ5UXVlcnlFbGVtZW50KGVsZW1lbnQsIG5hbWUsIHVybCkge1xuICAgIGVsZW1lbnQgPSAoZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50ICE9PSB2b2lkIDAgPyBlbGVtZW50IDogJycpLnRyaW0oKTtcbiAgICBpZiAoZWxlbWVudCA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBlbXB0eSBcIi5jb25jYXQobmFtZSwgXCIgaW4gVVJMIHF1ZXJ5ICdcIikuY29uY2F0KHVybCwgXCInXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBlc2NhcGVJUHY2QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdmFyIHN0YXJ0c1dpdGhTcXVhcmVCcmFja2V0ID0gYWRkcmVzcy5jaGFyQXQoMCkgPT09ICdbJztcbiAgICB2YXIgZW5kc1dpdGhTcXVhcmVCcmFja2V0ID0gYWRkcmVzcy5jaGFyQXQoYWRkcmVzcy5sZW5ndGggLSAxKSA9PT0gJ10nO1xuICAgIGlmICghc3RhcnRzV2l0aFNxdWFyZUJyYWNrZXQgJiYgIWVuZHNXaXRoU3F1YXJlQnJhY2tldCkge1xuICAgICAgICByZXR1cm4gXCJbXCIuY29uY2F0KGFkZHJlc3MsIFwiXVwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnRzV2l0aFNxdWFyZUJyYWNrZXQgJiYgZW5kc1dpdGhTcXVhcmVCcmFja2V0KSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBJUHY2IGFkZHJlc3MgXCIuY29uY2F0KGFkZHJlc3MpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRIb3N0KGhvc3QpIHtcbiAgICBpZiAoaG9zdCA9PT0gJycgfHwgaG9zdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaG9zdCBcIi5jb25jYXQoaG9zdCkpO1xuICAgIH1cbiAgICB2YXIgaXNJUHY2QWRkcmVzcyA9IGhvc3QuaW5jbHVkZXMoJzonKTtcbiAgICByZXR1cm4gaXNJUHY2QWRkcmVzcyA/IGVzY2FwZUlQdjZBZGRyZXNzKGhvc3QpIDogaG9zdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdElQdjRBZGRyZXNzKGFkZHJlc3MsIHBvcnQpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoYWRkcmVzcywgXCI6XCIpLmNvbmNhdChwb3J0KTtcbn1cbmV4cG9ydHMuZm9ybWF0SVB2NEFkZHJlc3MgPSBmb3JtYXRJUHY0QWRkcmVzcztcbmZ1bmN0aW9uIGZvcm1hdElQdjZBZGRyZXNzKGFkZHJlc3MsIHBvcnQpIHtcbiAgICB2YXIgZXNjYXBlZEFkZHJlc3MgPSBlc2NhcGVJUHY2QWRkcmVzcyhhZGRyZXNzKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoZXNjYXBlZEFkZHJlc3MsIFwiOlwiKS5jb25jYXQocG9ydCk7XG59XG5leHBvcnRzLmZvcm1hdElQdjZBZGRyZXNzID0gZm9ybWF0SVB2NkFkZHJlc3M7XG5mdW5jdGlvbiBkZWZhdWx0UG9ydEZvclNjaGVtZShzY2hlbWUpIHtcbiAgICBpZiAoc2NoZW1lID09PSAnaHR0cCcpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfSFRUUF9QT1JUO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfSFRUUFNfUE9SVDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBERUZBVUxUX0JPTFRfUE9SVDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHRQb3J0Rm9yU2NoZW1lID0gZGVmYXVsdFBvcnRGb3JTY2hlbWU7XG5mdW5jdGlvbiB1cmlKc1BhcnNlKHZhbHVlKSB7XG4gICAgLy8gSlMgdmVyc2lvbiBvZiBQeXRob24gcGFydGl0aW9uIGZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gcGFydGl0aW9uKHMsIGRlbGltaXRlcikge1xuICAgICAgICB2YXIgaSA9IHMuaW5kZXhPZihkZWxpbWl0ZXIpO1xuICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFtzLnN1YnN0cmluZygwLCBpKSwgc1tpXSwgcy5zdWJzdHJpbmcoaSArIDEpXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIFtzLCAnJywgJyddO1xuICAgIH1cbiAgICAvLyBKUyB2ZXJzaW9uIG9mIFB5dGhvbiBycGFydGl0aW9uIGZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gcnBhcnRpdGlvbihzLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgdmFyIGkgPSBzLmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG4gICAgICAgIGlmIChpID49IDApXG4gICAgICAgICAgICByZXR1cm4gW3Muc3Vic3RyaW5nKDAsIGkpLCBzW2ldLCBzLnN1YnN0cmluZyhpICsgMSldO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gWycnLCAnJywgc107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJldHdlZW4ocywgbGRlbGltaXRlciwgcmRlbGltaXRlcikge1xuICAgICAgICB2YXIgbHBhcnRpdGlvbiA9IHBhcnRpdGlvbihzLCBsZGVsaW1pdGVyKTtcbiAgICAgICAgdmFyIHJwYXJ0aXRpb24gPSBwYXJ0aXRpb24obHBhcnRpdGlvblsyXSwgcmRlbGltaXRlcik7XG4gICAgICAgIHJldHVybiBbcnBhcnRpdGlvblswXSwgcnBhcnRpdGlvblsyXV07XG4gICAgfVxuICAgIC8vIFBhcnNlIGFuIGF1dGhvcml0eSBzdHJpbmcgaW50byBhbiBvYmplY3RcbiAgICAvLyB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAvLyAtIHVzZXJJbmZvIChvcHRpb25hbCwgbWlnaHQgY29udGFpbiBib3RoIHVzZXIgbmFtZSBhbmQgcGFzc3dvcmQpXG4gICAgLy8gLSBob3N0XG4gICAgLy8gLSBwb3J0IChvcHRpb25hbCwgaW5jbHVkZWQgb25seSBhcyBhIHN0cmluZylcbiAgICBmdW5jdGlvbiBwYXJzZUF1dGhvcml0eSh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFyc2VkID0ge307XG4gICAgICAgIHZhciBwYXJ0cztcbiAgICAgICAgLy8gUGFyc2UgdXNlciBpbmZvXG4gICAgICAgIHBhcnRzID0gcnBhcnRpdGlvbih2YWx1ZSwgJ0AnKTtcbiAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnQCcpIHtcbiAgICAgICAgICAgIHBhcnNlZC51c2VySW5mbyA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1swXSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnRzWzJdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIGhvc3QgYW5kIHBvcnRcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGJldHdlZW4odmFsdWUsICdbJywgJ10nKSwgMiksIGlwdjZIb3N0ID0gX2FbMF0sIHJlc3QgPSBfYVsxXTtcbiAgICAgICAgaWYgKGlwdjZIb3N0ICE9PSAnJykge1xuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY2SG9zdDtcbiAgICAgICAgICAgIHBhcnRzID0gcGFydGl0aW9uKHJlc3QsICc6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cyA9IHBhcnRpdGlvbih2YWx1ZSwgJzonKTtcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnOicpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wb3J0ID0gcGFydHNbMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgdmFyIHBhcnNlZCA9IHt9O1xuICAgIHZhciBwYXJ0cztcbiAgICAvLyBQYXJzZSBzY2hlbWVcbiAgICBwYXJ0cyA9IHBhcnRpdGlvbih2YWx1ZSwgJzonKTtcbiAgICBpZiAocGFydHNbMV0gPT09ICc6Jykge1xuICAgICAgICBwYXJzZWQuc2NoZW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzBdKTtcbiAgICAgICAgdmFsdWUgPSBwYXJ0c1syXTtcbiAgICB9XG4gICAgLy8gUGFyc2UgZnJhZ21lbnRcbiAgICBwYXJ0cyA9IHBhcnRpdGlvbih2YWx1ZSwgJyMnKTtcbiAgICBpZiAocGFydHNbMV0gPT09ICcjJykge1xuICAgICAgICBwYXJzZWQuZnJhZ21lbnQgPSBkZWNvZGVVUklDb21wb25lbnQocGFydHNbMl0pO1xuICAgICAgICB2YWx1ZSA9IHBhcnRzWzBdO1xuICAgIH1cbiAgICAvLyBQYXJzZSBxdWVyeVxuICAgIHBhcnRzID0gcGFydGl0aW9uKHZhbHVlLCAnPycpO1xuICAgIGlmIChwYXJ0c1sxXSA9PT0gJz8nKSB7XG4gICAgICAgIHBhcnNlZC5xdWVyeSA9IHBhcnRzWzJdO1xuICAgICAgICB2YWx1ZSA9IHBhcnRzWzBdO1xuICAgIH1cbiAgICAvLyBQYXJzZSBhdXRob3JpdHkgYW5kIHBhdGhcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgICAgICBwYXJ0cyA9IHBhcnRpdGlvbih2YWx1ZS5zdWJzdHIoMiksICcvJyk7XG4gICAgICAgIHBhcnNlZCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJzZWQpLCBwYXJzZUF1dGhvcml0eShwYXJ0c1swXSkpO1xuICAgICAgICBwYXJzZWQucGF0aCA9IHBhcnRzWzFdICsgcGFydHNbMl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJzZWQucGF0aCA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/url-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js":
/*!*************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/internal/util.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ENCRYPTION_OFF = exports.ENCRYPTION_ON = exports.equals = exports.validateQueryAndParameters = exports.toNumber = exports.assertValidDate = exports.assertNumberOrInteger = exports.assertNumber = exports.assertString = exports.assertObject = exports.isString = exports.isObject = exports.isEmptyObjectOrNull = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nvar integer_1 = __importStar(__webpack_require__(/*! ../integer */ \"(rsc)/./node_modules/neo4j-driver-core/lib/integer.js\"));\nvar json_1 = __webpack_require__(/*! ../json */ \"(rsc)/./node_modules/neo4j-driver-core/lib/json.js\");\nvar ENCRYPTION_ON = 'ENCRYPTION_ON';\nexports.ENCRYPTION_ON = ENCRYPTION_ON;\nvar ENCRYPTION_OFF = 'ENCRYPTION_OFF';\nexports.ENCRYPTION_OFF = ENCRYPTION_OFF;\n/**\n * Verifies if the object is null or empty\n * @param obj The subject object\n * @returns {boolean} True if it's empty object or null\n */\nfunction isEmptyObjectOrNull(obj) {\n    if (obj === null) {\n        return true;\n    }\n    if (!isObject(obj)) {\n        return false;\n    }\n    for (var prop in obj) {\n        if (obj[prop] !== undefined) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isEmptyObjectOrNull = isEmptyObjectOrNull;\n/**\n * Verify if it's an object\n * @param obj The subject\n * @returns {boolean} True if it's an object\n */\nfunction isObject(obj) {\n    return typeof obj === 'object' && !Array.isArray(obj) && obj !== null;\n}\nexports.isObject = isObject;\n/**\n * Check and normalize given query and parameters.\n * @param {string|{text: string, parameters: Object}} query the query to check.\n * @param {Object} parameters\n * @return {{validatedQuery: string|{text: string, parameters: Object}, params: Object}} the normalized query with parameters.\n * @throws TypeError when either given query or parameters are invalid.\n */\nfunction validateQueryAndParameters(query, parameters, opt) {\n    var _a, _b;\n    var validatedQuery = '';\n    var params = parameters !== null && parameters !== void 0 ? parameters : {};\n    var skipAsserts = (_a = opt === null || opt === void 0 ? void 0 : opt.skipAsserts) !== null && _a !== void 0 ? _a : false;\n    if (typeof query === 'string') {\n        validatedQuery = query;\n    }\n    else if (query instanceof String) {\n        validatedQuery = query.toString();\n    }\n    else if (typeof query === 'object' && query.text != null) {\n        validatedQuery = query.text;\n        params = (_b = query.parameters) !== null && _b !== void 0 ? _b : {};\n    }\n    if (!skipAsserts) {\n        assertCypherQuery(validatedQuery);\n        assertQueryParameters(params);\n    }\n    return { validatedQuery: validatedQuery, params: params };\n}\nexports.validateQueryAndParameters = validateQueryAndParameters;\n/**\n * Assert it's a object\n * @param {any} obj The subject\n * @param {string} objName The object name\n * @returns {object} The subject object\n * @throws {TypeError} when the supplied param is not an object\n */\nfunction assertObject(obj, objName) {\n    if (!isObject(obj)) {\n        throw new TypeError(objName + ' expected to be an object but was: ' + (0, json_1.stringify)(obj));\n    }\n    return obj;\n}\nexports.assertObject = assertObject;\n/**\n * Assert it's a string\n * @param {any} obj The subject\n * @param {string} objName The object name\n * @returns {string} The subject string\n * @throws {TypeError} when the supplied param is not a string\n */\nfunction assertString(obj, objName) {\n    if (!isString(obj)) {\n        throw new TypeError((0, json_1.stringify)(objName) + ' expected to be string but was: ' + (0, json_1.stringify)(obj));\n    }\n    return obj;\n}\nexports.assertString = assertString;\n/**\n * Assert it's a number\n * @param {any} obj The subject\n * @param {string} objName The object name\n * @returns {number} The number\n * @throws {TypeError} when the supplied param is not a number\n */\nfunction assertNumber(obj, objName) {\n    if (typeof obj !== 'number') {\n        throw new TypeError(objName + ' expected to be a number but was: ' + (0, json_1.stringify)(obj));\n    }\n    return obj;\n}\nexports.assertNumber = assertNumber;\n/**\n * Assert it's a number or integer\n * @param {any} obj The subject\n * @param {string} objName The object name\n * @returns {number|Integer} The subject object\n * @throws {TypeError} when the supplied param is not a number or integer\n */\nfunction assertNumberOrInteger(obj, objName) {\n    if (typeof obj !== 'number' && typeof obj !== 'bigint' && !(0, integer_1.isInt)(obj)) {\n        throw new TypeError(objName +\n            ' expected to be either a number or an Integer object but was: ' +\n            (0, json_1.stringify)(obj));\n    }\n    return obj;\n}\nexports.assertNumberOrInteger = assertNumberOrInteger;\n/**\n * Assert it's a valid datae\n * @param {any} obj The subject\n * @param {string} objName The object name\n * @returns {Date} The valida date\n * @throws {TypeError} when the supplied param is not a valid date\n */\nfunction assertValidDate(obj, objName) {\n    if (Object.prototype.toString.call(obj) !== '[object Date]') {\n        throw new TypeError(objName +\n            ' expected to be a standard JavaScript Date but was: ' +\n            (0, json_1.stringify)(obj));\n    }\n    if (Number.isNaN(obj.getTime())) {\n        throw new TypeError(objName +\n            ' expected to be valid JavaScript Date but its time was NaN: ' +\n            (0, json_1.stringify)(obj));\n    }\n    return obj;\n}\nexports.assertValidDate = assertValidDate;\n/**\n * Validates a cypher query string\n * @param {any} obj The query\n * @returns {void}\n * @throws {TypeError} if the query is not valid\n */\nfunction assertCypherQuery(obj) {\n    assertString(obj, 'Cypher query');\n    if (obj.trim().length === 0) {\n        throw new TypeError('Cypher query is expected to be a non-empty string.');\n    }\n}\n/**\n * Validates if the query parameters is an object\n * @param {any} obj The parameters\n * @returns {void}\n * @throws {TypeError} if the parameters is not valid\n */\nfunction assertQueryParameters(obj) {\n    if (!isObject(obj)) {\n        // objects created with `Object.create(null)` do not have a constructor property\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        var constructor = obj.constructor != null ? ' ' + obj.constructor.name : '';\n        throw new TypeError(\"Query parameters are expected to either be undefined/null or an object, given:\".concat(constructor, \" \").concat(JSON.stringify(obj)));\n    }\n}\n/**\n * Verify if the supplied object is a string\n *\n * @param str The string\n * @returns {boolean} True if the supplied object is an string\n */\nfunction isString(str) {\n    return Object.prototype.toString.call(str) === '[object String]';\n}\nexports.isString = isString;\n/**\n * Verifies if object are the equals\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nfunction equals(a, b) {\n    var e_1, _a;\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null) {\n        return false;\n    }\n    if (typeof a === 'object' && typeof b === 'object') {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        if (keysA.length !== keysB.length) {\n            return false;\n        }\n        try {\n            for (var keysA_1 = __values(keysA), keysA_1_1 = keysA_1.next(); !keysA_1_1.done; keysA_1_1 = keysA_1.next()) {\n                var key = keysA_1_1.value;\n                if (!equals(a[key], b[key])) {\n                    return false;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (keysA_1_1 && !keysA_1_1.done && (_a = keysA_1.return)) _a.call(keysA_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return true;\n    }\n    return false;\n}\nexports.equals = equals;\n/**\n * Converts (Integer | bigint) to number.\n *\n * @private\n * @param {NumberOrInteger} value The number or integer\n * @returns {number} The number\n */\nfunction toNumber(value) {\n    if (value instanceof integer_1.default) {\n        return value.toNumber();\n    }\n    else if (typeof value === 'bigint') {\n        return (0, integer_1.int)(value).toNumber();\n    }\n    else {\n        return value;\n    }\n}\nexports.toNumber = toNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2ludGVybmFsL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGNBQWMsR0FBRyxrQ0FBa0MsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRywyQkFBMkI7QUFDMVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHlFQUFZO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQyxtRUFBUztBQUM5QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsV0FBVyxRQUFRLG1DQUFtQztBQUN0RCxXQUFXLFFBQVE7QUFDbkIsYUFBYSx3QkFBd0IsaUNBQWlDLG1CQUFtQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxnQkFBZ0I7QUFDN0IsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2IsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2IsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxpQkFBaUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9pbnRlcm5hbC91dGlsLmpzPzJmNmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRU5DUllQVElPTl9PRkYgPSBleHBvcnRzLkVOQ1JZUFRJT05fT04gPSBleHBvcnRzLmVxdWFscyA9IGV4cG9ydHMudmFsaWRhdGVRdWVyeUFuZFBhcmFtZXRlcnMgPSBleHBvcnRzLnRvTnVtYmVyID0gZXhwb3J0cy5hc3NlcnRWYWxpZERhdGUgPSBleHBvcnRzLmFzc2VydE51bWJlck9ySW50ZWdlciA9IGV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gZXhwb3J0cy5hc3NlcnRTdHJpbmcgPSBleHBvcnRzLmFzc2VydE9iamVjdCA9IGV4cG9ydHMuaXNTdHJpbmcgPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc0VtcHR5T2JqZWN0T3JOdWxsID0gdm9pZCAwO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbnZhciBpbnRlZ2VyXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2ludGVnZXJcIikpO1xudmFyIGpzb25fMSA9IHJlcXVpcmUoXCIuLi9qc29uXCIpO1xudmFyIEVOQ1JZUFRJT05fT04gPSAnRU5DUllQVElPTl9PTic7XG5leHBvcnRzLkVOQ1JZUFRJT05fT04gPSBFTkNSWVBUSU9OX09OO1xudmFyIEVOQ1JZUFRJT05fT0ZGID0gJ0VOQ1JZUFRJT05fT0ZGJztcbmV4cG9ydHMuRU5DUllQVElPTl9PRkYgPSBFTkNSWVBUSU9OX09GRjtcbi8qKlxuICogVmVyaWZpZXMgaWYgdGhlIG9iamVjdCBpcyBudWxsIG9yIGVtcHR5XG4gKiBAcGFyYW0gb2JqIFRoZSBzdWJqZWN0IG9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgaXQncyBlbXB0eSBvYmplY3Qgb3IgbnVsbFxuICovXG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0T3JOdWxsKG9iaikge1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0VtcHR5T2JqZWN0T3JOdWxsID0gaXNFbXB0eU9iamVjdE9yTnVsbDtcbi8qKlxuICogVmVyaWZ5IGlmIGl0J3MgYW4gb2JqZWN0XG4gKiBAcGFyYW0gb2JqIFRoZSBzdWJqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBpdCdzIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKSAmJiBvYmogIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vKipcbiAqIENoZWNrIGFuZCBub3JtYWxpemUgZ2l2ZW4gcXVlcnkgYW5kIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge3N0cmluZ3x7dGV4dDogc3RyaW5nLCBwYXJhbWV0ZXJzOiBPYmplY3R9fSBxdWVyeSB0aGUgcXVlcnkgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVyc1xuICogQHJldHVybiB7e3ZhbGlkYXRlZFF1ZXJ5OiBzdHJpbmd8e3RleHQ6IHN0cmluZywgcGFyYW1ldGVyczogT2JqZWN0fSwgcGFyYW1zOiBPYmplY3R9fSB0aGUgbm9ybWFsaXplZCBxdWVyeSB3aXRoIHBhcmFtZXRlcnMuXG4gKiBAdGhyb3dzIFR5cGVFcnJvciB3aGVuIGVpdGhlciBnaXZlbiBxdWVyeSBvciBwYXJhbWV0ZXJzIGFyZSBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5QW5kUGFyYW1ldGVycyhxdWVyeSwgcGFyYW1ldGVycywgb3B0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgdmFsaWRhdGVkUXVlcnkgPSAnJztcbiAgICB2YXIgcGFyYW1zID0gcGFyYW1ldGVycyAhPT0gbnVsbCAmJiBwYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBwYXJhbWV0ZXJzIDoge307XG4gICAgdmFyIHNraXBBc3NlcnRzID0gKF9hID0gb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LnNraXBBc3NlcnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxpZGF0ZWRRdWVyeSA9IHF1ZXJ5O1xuICAgIH1cbiAgICBlbHNlIGlmIChxdWVyeSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICB2YWxpZGF0ZWRRdWVyeSA9IHF1ZXJ5LnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgcXVlcnkudGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHZhbGlkYXRlZFF1ZXJ5ID0gcXVlcnkudGV4dDtcbiAgICAgICAgcGFyYW1zID0gKF9iID0gcXVlcnkucGFyYW1ldGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgfVxuICAgIGlmICghc2tpcEFzc2VydHMpIHtcbiAgICAgICAgYXNzZXJ0Q3lwaGVyUXVlcnkodmFsaWRhdGVkUXVlcnkpO1xuICAgICAgICBhc3NlcnRRdWVyeVBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWRhdGVkUXVlcnk6IHZhbGlkYXRlZFF1ZXJ5LCBwYXJhbXM6IHBhcmFtcyB9O1xufVxuZXhwb3J0cy52YWxpZGF0ZVF1ZXJ5QW5kUGFyYW1ldGVycyA9IHZhbGlkYXRlUXVlcnlBbmRQYXJhbWV0ZXJzO1xuLyoqXG4gKiBBc3NlcnQgaXQncyBhIG9iamVjdFxuICogQHBhcmFtIHthbnl9IG9iaiBUaGUgc3ViamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWUgVGhlIG9iamVjdCBuYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgc3ViamVjdCBvYmplY3RcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gd2hlbiB0aGUgc3VwcGxpZWQgcGFyYW0gaXMgbm90IGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBhc3NlcnRPYmplY3Qob2JqLCBvYmpOYW1lKSB7XG4gICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Iob2JqTmFtZSArICcgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0IGJ1dCB3YXM6ICcgKyAoMCwganNvbl8xLnN0cmluZ2lmeSkob2JqKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnRzLmFzc2VydE9iamVjdCA9IGFzc2VydE9iamVjdDtcbi8qKlxuICogQXNzZXJ0IGl0J3MgYSBzdHJpbmdcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIHN1YmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lIFRoZSBvYmplY3QgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHN1YmplY3Qgc3RyaW5nXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IHdoZW4gdGhlIHN1cHBsaWVkIHBhcmFtIGlzIG5vdCBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmcob2JqLCBvYmpOYW1lKSB7XG4gICAgaWYgKCFpc1N0cmluZyhvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKDAsIGpzb25fMS5zdHJpbmdpZnkpKG9iak5hbWUpICsgJyBleHBlY3RlZCB0byBiZSBzdHJpbmcgYnV0IHdhczogJyArICgwLCBqc29uXzEuc3RyaW5naWZ5KShvYmopKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydHMuYXNzZXJ0U3RyaW5nID0gYXNzZXJ0U3RyaW5nO1xuLyoqXG4gKiBBc3NlcnQgaXQncyBhIG51bWJlclxuICogQHBhcmFtIHthbnl9IG9iaiBUaGUgc3ViamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWUgVGhlIG9iamVjdCBuYW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IHdoZW4gdGhlIHN1cHBsaWVkIHBhcmFtIGlzIG5vdCBhIG51bWJlclxuICovXG5mdW5jdGlvbiBhc3NlcnROdW1iZXIob2JqLCBvYmpOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Iob2JqTmFtZSArICcgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXIgYnV0IHdhczogJyArICgwLCBqc29uXzEuc3RyaW5naWZ5KShvYmopKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gYXNzZXJ0TnVtYmVyO1xuLyoqXG4gKiBBc3NlcnQgaXQncyBhIG51bWJlciBvciBpbnRlZ2VyXG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBzdWJqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZSBUaGUgb2JqZWN0IG5hbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ8SW50ZWdlcn0gVGhlIHN1YmplY3Qgb2JqZWN0XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IHdoZW4gdGhlIHN1cHBsaWVkIHBhcmFtIGlzIG5vdCBhIG51bWJlciBvciBpbnRlZ2VyXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE51bWJlck9ySW50ZWdlcihvYmosIG9iak5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ251bWJlcicgJiYgdHlwZW9mIG9iaiAhPT0gJ2JpZ2ludCcgJiYgISgwLCBpbnRlZ2VyXzEuaXNJbnQpKG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvYmpOYW1lICtcbiAgICAgICAgICAgICcgZXhwZWN0ZWQgdG8gYmUgZWl0aGVyIGEgbnVtYmVyIG9yIGFuIEludGVnZXIgb2JqZWN0IGJ1dCB3YXM6ICcgK1xuICAgICAgICAgICAgKDAsIGpzb25fMS5zdHJpbmdpZnkpKG9iaikpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0cy5hc3NlcnROdW1iZXJPckludGVnZXIgPSBhc3NlcnROdW1iZXJPckludGVnZXI7XG4vKipcbiAqIEFzc2VydCBpdCdzIGEgdmFsaWQgZGF0YWVcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIHN1YmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lIFRoZSBvYmplY3QgbmFtZVxuICogQHJldHVybnMge0RhdGV9IFRoZSB2YWxpZGEgZGF0ZVxuICogQHRocm93cyB7VHlwZUVycm9yfSB3aGVuIHRoZSBzdXBwbGllZCBwYXJhbSBpcyBub3QgYSB2YWxpZCBkYXRlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkRGF0ZShvYmosIG9iak5hbWUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iak5hbWUgK1xuICAgICAgICAgICAgJyBleHBlY3RlZCB0byBiZSBhIHN0YW5kYXJkIEphdmFTY3JpcHQgRGF0ZSBidXQgd2FzOiAnICtcbiAgICAgICAgICAgICgwLCBqc29uXzEuc3RyaW5naWZ5KShvYmopKTtcbiAgICB9XG4gICAgaWYgKE51bWJlci5pc05hTihvYmouZ2V0VGltZSgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG9iak5hbWUgK1xuICAgICAgICAgICAgJyBleHBlY3RlZCB0byBiZSB2YWxpZCBKYXZhU2NyaXB0IERhdGUgYnV0IGl0cyB0aW1lIHdhcyBOYU46ICcgK1xuICAgICAgICAgICAgKDAsIGpzb25fMS5zdHJpbmdpZnkpKG9iaikpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0cy5hc3NlcnRWYWxpZERhdGUgPSBhc3NlcnRWYWxpZERhdGU7XG4vKipcbiAqIFZhbGlkYXRlcyBhIGN5cGhlciBxdWVyeSBzdHJpbmdcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIHF1ZXJ5XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgdGhlIHF1ZXJ5IGlzIG5vdCB2YWxpZFxuICovXG5mdW5jdGlvbiBhc3NlcnRDeXBoZXJRdWVyeShvYmopIHtcbiAgICBhc3NlcnRTdHJpbmcob2JqLCAnQ3lwaGVyIHF1ZXJ5Jyk7XG4gICAgaWYgKG9iai50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0N5cGhlciBxdWVyeSBpcyBleHBlY3RlZCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyk7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgaWYgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMgaXMgYW4gb2JqZWN0XG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgdGhlIHBhcmFtZXRlcnMgaXMgbm90IHZhbGlkXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFF1ZXJ5UGFyYW1ldGVycyhvYmopIHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgLy8gb2JqZWN0cyBjcmVhdGVkIHdpdGggYE9iamVjdC5jcmVhdGUobnVsbClgIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgcHJvcGVydHlcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvciAhPSBudWxsID8gJyAnICsgb2JqLmNvbnN0cnVjdG9yLm5hbWUgOiAnJztcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlF1ZXJ5IHBhcmFtZXRlcnMgYXJlIGV4cGVjdGVkIHRvIGVpdGhlciBiZSB1bmRlZmluZWQvbnVsbCBvciBhbiBvYmplY3QsIGdpdmVuOlwiLmNvbmNhdChjb25zdHJ1Y3RvciwgXCIgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShvYmopKSk7XG4gICAgfVxufVxuLyoqXG4gKiBWZXJpZnkgaWYgdGhlIHN1cHBsaWVkIG9iamVjdCBpcyBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN1cHBsaWVkIG9iamVjdCBpcyBhbiBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbi8qKlxuICogVmVyaWZpZXMgaWYgb2JqZWN0IGFyZSB0aGUgZXF1YWxzXG4gKiBAcGFyYW0ge3Vua25vd259IGFcbiAqIEBwYXJhbSB7dW5rbm93bn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzQV8xID0gX192YWx1ZXMoa2V5c0EpLCBrZXlzQV8xXzEgPSBrZXlzQV8xLm5leHQoKTsgIWtleXNBXzFfMS5kb25lOyBrZXlzQV8xXzEgPSBrZXlzQV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzQV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzQV8xXzEgJiYgIWtleXNBXzFfMS5kb25lICYmIChfYSA9IGtleXNBXzEucmV0dXJuKSkgX2EuY2FsbChrZXlzQV8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5lcXVhbHMgPSBlcXVhbHM7XG4vKipcbiAqIENvbnZlcnRzIChJbnRlZ2VyIHwgYmlnaW50KSB0byBudW1iZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSB2YWx1ZSBUaGUgbnVtYmVyIG9yIGludGVnZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBpbnRlZ2VyXzEuZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gKDAsIGludGVnZXJfMS5pbnQpKHZhbHVlKS50b051bWJlcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/json.js":
/*!****************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/json.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringify = void 0;\nvar object_util_1 = __webpack_require__(/*! ./internal/object-util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/object-util.js\");\n/**\n * Custom version on JSON.stringify that can handle values that normally don't support serialization, such as BigInt.\n * @private\n * @param val A JavaScript value, usually an object or array, to be converted.\n * @returns A JSON string representing the given value.\n */\nfunction stringify(val, opts) {\n    return JSON.stringify(val, function (_, value) {\n        if ((0, object_util_1.isBrokenObject)(value)) {\n            return {\n                __isBrokenObject__: true,\n                __reason__: (0, object_util_1.getBrokenObjectReason)(value)\n            };\n        }\n        if (typeof value === 'bigint') {\n            return \"\".concat(value, \"n\");\n        }\n        if ((opts === null || opts === void 0 ? void 0 : opts.sortedElements) === true &&\n            typeof value === 'object' &&\n            !Array.isArray(value)) {\n            return Object.keys(value).sort().reduce(function (obj, key) {\n                // @ts-expect-error: no way to avoid implicit 'any'\n                obj[key] = value[key];\n                return obj;\n            }, {});\n        }\n        if ((opts === null || opts === void 0 ? void 0 : opts.useCustomToString) === true &&\n            typeof value === 'object' &&\n            !Array.isArray(value) &&\n            typeof value.toString === 'function' &&\n            value.toString !== Object.prototype.toString) {\n            return value === null || value === void 0 ? void 0 : value.toString();\n        }\n        return value;\n    });\n}\nexports.stringify = stringify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL2pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsb0JBQW9CLG1CQUFPLENBQUMsa0dBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9qc29uLmpzPzkwOTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSB2b2lkIDA7XG52YXIgb2JqZWN0X3V0aWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL29iamVjdC11dGlsXCIpO1xuLyoqXG4gKiBDdXN0b20gdmVyc2lvbiBvbiBKU09OLnN0cmluZ2lmeSB0aGF0IGNhbiBoYW5kbGUgdmFsdWVzIHRoYXQgbm9ybWFsbHkgZG9uJ3Qgc3VwcG9ydCBzZXJpYWxpemF0aW9uLCBzdWNoIGFzIEJpZ0ludC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gdmFsIEEgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXksIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCwgb3B0cykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwsIGZ1bmN0aW9uIChfLCB2YWx1ZSkge1xuICAgICAgICBpZiAoKDAsIG9iamVjdF91dGlsXzEuaXNCcm9rZW5PYmplY3QpKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfX2lzQnJva2VuT2JqZWN0X186IHRydWUsXG4gICAgICAgICAgICAgICAgX19yZWFzb25fXzogKDAsIG9iamVjdF91dGlsXzEuZ2V0QnJva2VuT2JqZWN0UmVhc29uKSh2YWx1ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNvcnRlZEVsZW1lbnRzKSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbm8gd2F5IHRvIGF2b2lkIGltcGxpY2l0ICdhbnknXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMudXNlQ3VzdG9tVG9TdHJpbmcpID09PSB0cnVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgdmFsdWUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/json.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/notification-filter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/notification-filter.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.notificationFilterDisabledClassification = exports.notificationFilterDisabledCategory = exports.notificationFilterMinimumSeverityLevel = void 0;\n/**\n * @typedef {'WARNING' | 'INFORMATION' | 'OFF'} NotificationFilterMinimumSeverityLevel\n */\n/**\n * Constants that represents the minimum Severity level in the {@link NotificationFilter}\n */\nvar notificationFilterMinimumSeverityLevel = {\n    OFF: 'OFF',\n    WARNING: 'WARNING',\n    INFORMATION: 'INFORMATION'\n};\nexports.notificationFilterMinimumSeverityLevel = notificationFilterMinimumSeverityLevel;\nObject.freeze(notificationFilterMinimumSeverityLevel);\n/**\n * @typedef {'HINT' | 'UNRECOGNIZED' | 'UNSUPPORTED' |'PERFORMANCE' | 'TOPOLOGY' | 'SECURITY' | 'DEPRECATION' | 'GENERIC' | 'SCHEMA'} NotificationFilterDisabledCategory\n */\n/**\n * Constants that represents the disabled categories in the {@link NotificationFilter}\n */\nvar notificationFilterDisabledCategory = {\n    HINT: 'HINT',\n    UNRECOGNIZED: 'UNRECOGNIZED',\n    UNSUPPORTED: 'UNSUPPORTED',\n    PERFORMANCE: 'PERFORMANCE',\n    TOPOLOGY: 'TOPOLOGY',\n    SECURITY: 'SECURITY',\n    DEPRECATION: 'DEPRECATION',\n    GENERIC: 'GENERIC',\n    SCHEMA: 'SCHEMA'\n};\nexports.notificationFilterDisabledCategory = notificationFilterDisabledCategory;\nObject.freeze(notificationFilterDisabledCategory);\n/**\n * @typedef {NotificationFilterDisabledCategory} NotificationFilterDisabledClassification\n * @experimental\n */\n/**\n * Constants that represents the disabled classifications in the {@link NotificationFilter}\n *\n * @type {notificationFilterDisabledCategory}\n * @experimental\n */\nvar notificationFilterDisabledClassification = notificationFilterDisabledCategory;\nexports.notificationFilterDisabledClassification = notificationFilterDisabledClassification;\n/**\n * The notification filter object which can be configured in\n * the session and driver creation.\n *\n * Values not defined are interpreted as default.\n *\n * @interface\n */\nvar NotificationFilter = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     */\n    function NotificationFilter() {\n        /**\n         * The minimum level of all notifications to receive.\n         *\n         * @public\n         * @type {?NotificationFilterMinimumSeverityLevel}\n         */\n        this.minimumSeverityLevel = undefined;\n        /**\n         * Categories the user would like to opt-out of receiving.\n         *\n         *\n         * This property is equivalent to {@link NotificationFilter#disabledClassifications}\n         * and it must not be enabled at same time.\n         *\n         * @type {?NotificationFilterDisabledCategory[]}\n         */\n        this.disabledCategories = undefined;\n        /**\n         * Classifications the user would like to opt-out of receiving.\n         *\n         * This property is equivalent to {@link NotificationFilter#disabledCategories}\n         * and it must not be enabled at same time.\n         *\n         * @type {?NotificationFilterDisabledClassification[]}\n         * @experimental\n         */\n        this.disabledClassifications = undefined;\n        throw new Error('Not implemented');\n    }\n    return NotificationFilter;\n}());\nexports[\"default\"] = NotificationFilter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL25vdGlmaWNhdGlvbi1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0RBQWdELEdBQUcsMENBQTBDLEdBQUcsOENBQThDO0FBQzlJO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLGFBQWEseUhBQXlIO0FBQ3RJO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvbm90aWZpY2F0aW9uLWZpbHRlci5qcz8yN2E1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENsYXNzaWZpY2F0aW9uID0gZXhwb3J0cy5ub3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENhdGVnb3J5ID0gZXhwb3J0cy5ub3RpZmljYXRpb25GaWx0ZXJNaW5pbXVtU2V2ZXJpdHlMZXZlbCA9IHZvaWQgMDtcbi8qKlxuICogQHR5cGVkZWYgeydXQVJOSU5HJyB8ICdJTkZPUk1BVElPTicgfCAnT0ZGJ30gTm90aWZpY2F0aW9uRmlsdGVyTWluaW11bVNldmVyaXR5TGV2ZWxcbiAqL1xuLyoqXG4gKiBDb25zdGFudHMgdGhhdCByZXByZXNlbnRzIHRoZSBtaW5pbXVtIFNldmVyaXR5IGxldmVsIGluIHRoZSB7QGxpbmsgTm90aWZpY2F0aW9uRmlsdGVyfVxuICovXG52YXIgbm90aWZpY2F0aW9uRmlsdGVyTWluaW11bVNldmVyaXR5TGV2ZWwgPSB7XG4gICAgT0ZGOiAnT0ZGJyxcbiAgICBXQVJOSU5HOiAnV0FSTklORycsXG4gICAgSU5GT1JNQVRJT046ICdJTkZPUk1BVElPTidcbn07XG5leHBvcnRzLm5vdGlmaWNhdGlvbkZpbHRlck1pbmltdW1TZXZlcml0eUxldmVsID0gbm90aWZpY2F0aW9uRmlsdGVyTWluaW11bVNldmVyaXR5TGV2ZWw7XG5PYmplY3QuZnJlZXplKG5vdGlmaWNhdGlvbkZpbHRlck1pbmltdW1TZXZlcml0eUxldmVsKTtcbi8qKlxuICogQHR5cGVkZWYgeydISU5UJyB8ICdVTlJFQ09HTklaRUQnIHwgJ1VOU1VQUE9SVEVEJyB8J1BFUkZPUk1BTkNFJyB8ICdUT1BPTE9HWScgfCAnU0VDVVJJVFknIHwgJ0RFUFJFQ0FUSU9OJyB8ICdHRU5FUklDJyB8ICdTQ0hFTUEnfSBOb3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENhdGVnb3J5XG4gKi9cbi8qKlxuICogQ29uc3RhbnRzIHRoYXQgcmVwcmVzZW50cyB0aGUgZGlzYWJsZWQgY2F0ZWdvcmllcyBpbiB0aGUge0BsaW5rIE5vdGlmaWNhdGlvbkZpbHRlcn1cbiAqL1xudmFyIG5vdGlmaWNhdGlvbkZpbHRlckRpc2FibGVkQ2F0ZWdvcnkgPSB7XG4gICAgSElOVDogJ0hJTlQnLFxuICAgIFVOUkVDT0dOSVpFRDogJ1VOUkVDT0dOSVpFRCcsXG4gICAgVU5TVVBQT1JURUQ6ICdVTlNVUFBPUlRFRCcsXG4gICAgUEVSRk9STUFOQ0U6ICdQRVJGT1JNQU5DRScsXG4gICAgVE9QT0xPR1k6ICdUT1BPTE9HWScsXG4gICAgU0VDVVJJVFk6ICdTRUNVUklUWScsXG4gICAgREVQUkVDQVRJT046ICdERVBSRUNBVElPTicsXG4gICAgR0VORVJJQzogJ0dFTkVSSUMnLFxuICAgIFNDSEVNQTogJ1NDSEVNQSdcbn07XG5leHBvcnRzLm5vdGlmaWNhdGlvbkZpbHRlckRpc2FibGVkQ2F0ZWdvcnkgPSBub3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENhdGVnb3J5O1xuT2JqZWN0LmZyZWV6ZShub3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENhdGVnb3J5KTtcbi8qKlxuICogQHR5cGVkZWYge05vdGlmaWNhdGlvbkZpbHRlckRpc2FibGVkQ2F0ZWdvcnl9IE5vdGlmaWNhdGlvbkZpbHRlckRpc2FibGVkQ2xhc3NpZmljYXRpb25cbiAqIEBleHBlcmltZW50YWxcbiAqL1xuLyoqXG4gKiBDb25zdGFudHMgdGhhdCByZXByZXNlbnRzIHRoZSBkaXNhYmxlZCBjbGFzc2lmaWNhdGlvbnMgaW4gdGhlIHtAbGluayBOb3RpZmljYXRpb25GaWx0ZXJ9XG4gKlxuICogQHR5cGUge25vdGlmaWNhdGlvbkZpbHRlckRpc2FibGVkQ2F0ZWdvcnl9XG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbnZhciBub3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENsYXNzaWZpY2F0aW9uID0gbm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDYXRlZ29yeTtcbmV4cG9ydHMubm90aWZpY2F0aW9uRmlsdGVyRGlzYWJsZWRDbGFzc2lmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbkZpbHRlckRpc2FibGVkQ2xhc3NpZmljYXRpb247XG4vKipcbiAqIFRoZSBub3RpZmljYXRpb24gZmlsdGVyIG9iamVjdCB3aGljaCBjYW4gYmUgY29uZmlndXJlZCBpblxuICogdGhlIHNlc3Npb24gYW5kIGRyaXZlciBjcmVhdGlvbi5cbiAqXG4gKiBWYWx1ZXMgbm90IGRlZmluZWQgYXJlIGludGVycHJldGVkIGFzIGRlZmF1bHQuXG4gKlxuICogQGludGVyZmFjZVxuICovXG52YXIgTm90aWZpY2F0aW9uRmlsdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uRmlsdGVyKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbmltdW0gbGV2ZWwgb2YgYWxsIG5vdGlmaWNhdGlvbnMgdG8gcmVjZWl2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAdHlwZSB7P05vdGlmaWNhdGlvbkZpbHRlck1pbmltdW1TZXZlcml0eUxldmVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5pbXVtU2V2ZXJpdHlMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdGVnb3JpZXMgdGhlIHVzZXIgd291bGQgbGlrZSB0byBvcHQtb3V0IG9mIHJlY2VpdmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBpcyBlcXVpdmFsZW50IHRvIHtAbGluayBOb3RpZmljYXRpb25GaWx0ZXIjZGlzYWJsZWRDbGFzc2lmaWNhdGlvbnN9XG4gICAgICAgICAqIGFuZCBpdCBtdXN0IG5vdCBiZSBlbmFibGVkIGF0IHNhbWUgdGltZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgez9Ob3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENhdGVnb3J5W119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkQ2F0ZWdvcmllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzaWZpY2F0aW9ucyB0aGUgdXNlciB3b3VsZCBsaWtlIHRvIG9wdC1vdXQgb2YgcmVjZWl2aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGlzIGVxdWl2YWxlbnQgdG8ge0BsaW5rIE5vdGlmaWNhdGlvbkZpbHRlciNkaXNhYmxlZENhdGVnb3JpZXN9XG4gICAgICAgICAqIGFuZCBpdCBtdXN0IG5vdCBiZSBlbmFibGVkIGF0IHNhbWUgdGltZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgez9Ob3RpZmljYXRpb25GaWx0ZXJEaXNhYmxlZENsYXNzaWZpY2F0aW9uW119XG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzYWJsZWRDbGFzc2lmaWNhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBOb3RpZmljYXRpb25GaWx0ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTm90aWZpY2F0aW9uRmlsdGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/notification-filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/notification.js":
/*!************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/notification.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buildNotificationsFromMetadata = exports.buildGqlStatusObjectFromMetadata = exports.polyfillNotification = exports.polyfillGqlStatusObject = exports.GqlStatusObject = exports.Notification = exports.notificationClassification = exports.notificationCategory = exports.notificationSeverityLevel = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar json = __importStar(__webpack_require__(/*! ./json */ \"(rsc)/./node_modules/neo4j-driver-core/lib/json.js\"));\nvar internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/index.js\");\nvar gql_constants_1 = __webpack_require__(/*! ./gql-constants */ \"(rsc)/./node_modules/neo4j-driver-core/lib/gql-constants.js\");\nvar unknownGqlStatus = {\n    WARNING: {\n        gql_status: '01N42',\n        status_description: 'warn: unknown warning'\n    },\n    NO_DATA: {\n        gql_status: '02N42',\n        status_description: 'note: no data - unknown subcondition'\n    },\n    INFORMATION: {\n        gql_status: '03N42',\n        status_description: 'info: unknown notification'\n    },\n    ERROR: {\n        gql_status: '50N42',\n        status_description: 'error: general processing exception - unexpected error'\n    }\n};\n/**\n * @typedef {'WARNING' | 'INFORMATION' | 'UNKNOWN'} NotificationSeverityLevel\n */\n/**\n * Constants that represents the Severity level in the {@link Notification}\n */\nvar notificationSeverityLevel = {\n    WARNING: 'WARNING',\n    INFORMATION: 'INFORMATION',\n    UNKNOWN: 'UNKNOWN'\n};\nexports.notificationSeverityLevel = notificationSeverityLevel;\nObject.freeze(notificationSeverityLevel);\nvar severityLevels = Object.values(notificationSeverityLevel);\n/**\n * @typedef {'HINT' | 'UNRECOGNIZED' | 'UNSUPPORTED' |'PERFORMANCE' | 'TOPOLOGY' | 'SECURITY' | 'DEPRECATION' | 'GENERIC' | 'SCHEMA' | 'UNKNOWN' } NotificationCategory\n */\n/**\n * Constants that represents the Category in the {@link Notification}\n */\nvar notificationCategory = {\n    HINT: 'HINT',\n    UNRECOGNIZED: 'UNRECOGNIZED',\n    UNSUPPORTED: 'UNSUPPORTED',\n    PERFORMANCE: 'PERFORMANCE',\n    DEPRECATION: 'DEPRECATION',\n    TOPOLOGY: 'TOPOLOGY',\n    SECURITY: 'SECURITY',\n    GENERIC: 'GENERIC',\n    SCHEMA: 'SCHEMA',\n    UNKNOWN: 'UNKNOWN'\n};\nexports.notificationCategory = notificationCategory;\nObject.freeze(notificationCategory);\nvar categories = Object.values(notificationCategory);\n/**\n * @typedef {NotificationCategory} NotificationClassification\n * @experimental\n */\n/**\n * Constants that represents the Classification in the {@link GqlStatusObject}\n * @type {notificationCategory}\n * @experimental\n */\nvar notificationClassification = notificationCategory;\nexports.notificationClassification = notificationClassification;\n/**\n * Class for Cypher notifications\n * @access public\n */\nvar Notification = /** @class */ (function () {\n    /**\n     * Create a Notification instance\n     * @constructor\n     * @param {Object} notification - Object with notification data\n     */\n    function Notification(notification) {\n        /**\n         * The code\n         * @type {string}\n         * @public\n         */\n        this.code = notification.code;\n        /**\n         * The title\n         * @type {string}\n         * @public\n         */\n        this.title = notification.title;\n        /**\n         * The description\n         * @type {string}\n         * @public\n         */\n        this.description = notification.description;\n        /**\n         * The raw severity\n         *\n         * Use {@link Notification#rawSeverityLevel} for the raw value or {@link Notification#severityLevel} for an enumerated value.\n         *\n         * @type {string}\n         * @public\n         * @deprecated This property will be removed in 6.0.\n         */\n        this.severity = notification.severity;\n        /**\n         * The position which the notification had occur.\n         *\n         * @type {NotificationPosition}\n         * @public\n         */\n        this.position = _constructPosition(notification.position);\n        /**\n         * The severity level\n         *\n         * @type {NotificationSeverityLevel}\n         * @public\n         * @example\n         * const { summary } = await session.run(\"RETURN 1\")\n         *\n         * for (const notification of summary.notifications) {\n         *     switch(notification.severityLevel) {\n         *         case neo4j.notificationSeverityLevel.INFORMATION: // or simply 'INFORMATION'\n         *             console.info(`${notification.title} - ${notification.description}`)\n         *             break\n         *         case neo4j.notificationSeverityLevel.WARNING: // or simply 'WARNING'\n         *             console.warn(`${notification.title} - ${notification.description}`)\n         *             break\n         *         case neo4j.notificationSeverityLevel.UNKNOWN: // or simply 'UNKNOWN'\n         *         default:\n         *             // the raw info came from the server could be found at notification.rawSeverityLevel\n         *             console.log(`${notification.title} - ${notification.description}`)\n         *             break\n         *     }\n         * }\n         */\n        this.severityLevel = _asEnumerableSeverity(notification.severity);\n        /**\n         * The severity level returned by the server without any validation.\n         *\n         * @type {string}\n         * @public\n         */\n        this.rawSeverityLevel = notification.severity;\n        /**\n         * The category\n         *\n         * @type {NotificationCategory}\n         * @public\n         * @example\n         * const { summary } = await session.run(\"RETURN 1\")\n         *\n         * for (const notification of summary.notifications) {\n         *     switch(notification.category) {\n         *         case neo4j.notificationCategory.QUERY: // or simply 'QUERY'\n         *             console.info(`${notification.title} - ${notification.description}`)\n         *             break\n         *         case neo4j.notificationCategory.PERFORMANCE: // or simply 'PERFORMANCE'\n         *             console.warn(`${notification.title} - ${notification.description}`)\n         *             break\n         *         case neo4j.notificationCategory.UNKNOWN: // or simply 'UNKNOWN'\n         *         default:\n         *             // the raw info came from the server could be found at notification.rawCategory\n         *             console.log(`${notification.title} - ${notification.description}`)\n         *             break\n         *     }\n         * }\n         */\n        this.category = _asEnumerableClassification(notification.category);\n        /**\n         * The category returned by the server without any validation.\n         *\n         * @type {string|undefined}\n         * @public\n         */\n        this.rawCategory = notification.category;\n    }\n    return Notification;\n}());\nexports.Notification = Notification;\n/**\n * Representation for GqlStatusObject found when executing a query.\n * <p>\n * This object represents a status of query execution.\n * This status is a superset of {@link Notification}.\n *\n * @experimental\n * @public\n */\nvar GqlStatusObject = /** @class */ (function () {\n    /**\n     *\n     * @param rawGqlStatusObject\n     * @private\n     */\n    function GqlStatusObject(rawGqlStatusObject) {\n        var _a;\n        /**\n         * The GQLSTATUS\n         *\n         * @type {string}\n         * @public\n         */\n        this.gqlStatus = rawGqlStatusObject.gql_status;\n        /**\n         * The GQLSTATUS description\n         *\n         * @type {string}\n         * @public\n         */\n        this.statusDescription = rawGqlStatusObject.status_description;\n        /**\n         * The diagnostic record as it is.\n         *\n         * @type {object}\n         * @public\n         */\n        this.diagnosticRecord = (_a = rawGqlStatusObject.diagnostic_record) !== null && _a !== void 0 ? _a : {};\n        /**\n         * The position at which the notification had occurred.\n         *\n         * @type {NotificationPosition | undefined}\n         * @public\n         */\n        this.position = this.diagnosticRecord._position != null ? _constructPosition(this.diagnosticRecord._position) : undefined;\n        /**\n         * The severity\n         *\n         * @type {NotificationSeverityLevel}\n         * @public\n         * @example\n         * const { summary } = await session.run(\"RETURN 1\")\n         *\n         * for (const gqlStatusObject of summary.gqlStatusObjects) {\n         *     switch(gqlStatusObject.severity) {\n         *         case neo4j.notificationSeverityLevel.INFORMATION: // or simply 'INFORMATION'\n         *             console.info(gqlStatusObject.statusDescription)\n         *             break\n         *         case neo4j.notificationSeverityLevel.WARNING: // or simply 'WARNING'\n         *             console.warn(gqlStatusObject.statusDescription)\n         *             break\n         *         case neo4j.notificationSeverityLevel.UNKNOWN: // or simply 'UNKNOWN'\n         *         default:\n         *             // the raw info came from the server could be found at gqlStatusObject.rawSeverity\n         *             console.log(gqlStatusObject.statusDescription)\n         *             break\n         *     }\n         * }\n         */\n        this.severity = _asEnumerableSeverity(this.diagnosticRecord._severity);\n        /**\n         * The severity returned in the diagnostic record from the server without any validation.\n         *\n         * @type {string | undefined}\n         * @public\n         */\n        this.rawSeverity = this.diagnosticRecord._severity;\n        /**\n         * The classification\n         *\n         * @type {NotificationClassification}\n         * @public\n         * @example\n         * const { summary } = await session.run(\"RETURN 1\")\n         *\n         * for (const gqlStatusObject of summary.gqlStatusObjects) {\n         *     switch(gqlStatusObject.classification) {\n         *         case neo4j.notificationClassification.QUERY: // or simply 'QUERY'\n         *             console.info(gqlStatusObject.statusDescription)\n         *             break\n         *         case neo4j.notificationClassification.PERFORMANCE: // or simply 'PERFORMANCE'\n         *             console.warn(gqlStatusObject.statusDescription)\n         *             break\n         *         case neo4j.notificationClassification.UNKNOWN: // or simply 'UNKNOWN'\n         *         default:\n         *             // the raw info came from the server can be found at notification.rawCategory\n         *             console.log(gqlStatusObject.statusDescription)\n         *             break\n         *     }\n         * }\n         */\n        this.classification = _asEnumerableClassification(this.diagnosticRecord._classification);\n        /**\n         * The category returned by the server without any validation.\n         *\n         * @type {string|undefined}\n         * @public\n         */\n        this.rawClassification = this.diagnosticRecord._classification;\n        /**\n         * Indicates if this object represents a notification and it can be filtered using\n         * NotificationFilter.\n         *\n         * Only GqlStatusObject which is Notification has meaningful position, severity and\n         * classification.\n         *\n         * @type {boolean}\n         * @public\n         */\n        this.isNotification = rawGqlStatusObject.neo4j_code != null;\n        Object.freeze(this);\n    }\n    Object.defineProperty(GqlStatusObject.prototype, \"diagnosticRecordAsJsonString\", {\n        /**\n         * The json string representation of the diagnostic record.\n         * The goal of this method is provide a serialized object for human inspection.\n         *\n         * @type {string}\n         * @public\n         */\n        get: function () {\n            return json.stringify(this.diagnosticRecord, { useCustomToString: true });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return GqlStatusObject;\n}());\nexports.GqlStatusObject = GqlStatusObject;\n/**\n *\n * @private\n * @param status\n * @returns {Notification|undefined}\n */\nfunction polyfillNotification(status) {\n    var _a, _b, _c;\n    // Non notification status should have neo4j_code\n    if (status.neo4j_code == null) {\n        return undefined;\n    }\n    return new Notification({\n        code: status.neo4j_code,\n        title: status.title,\n        description: status.description,\n        severity: (_a = status.diagnostic_record) === null || _a === void 0 ? void 0 : _a._severity,\n        category: (_b = status.diagnostic_record) === null || _b === void 0 ? void 0 : _b._classification,\n        position: (_c = status.diagnostic_record) === null || _c === void 0 ? void 0 : _c._position\n    });\n}\nexports.polyfillNotification = polyfillNotification;\n/**\n * @private\n * @param notification\n * @returns {GqlStatusObject}\n */\nfunction polyfillGqlStatusObject(notification) {\n    var _a;\n    var defaultStatus = notification.severity === notificationSeverityLevel.WARNING ? unknownGqlStatus.WARNING : unknownGqlStatus.INFORMATION;\n    var polyfilledRawObj = {\n        gql_status: defaultStatus.gql_status,\n        status_description: (_a = notification.description) !== null && _a !== void 0 ? _a : defaultStatus.status_description,\n        neo4j_code: notification.code,\n        title: notification.title,\n        diagnostic_record: __assign({}, gql_constants_1.rawPolyfilledDiagnosticRecord)\n    };\n    if (notification.severity != null) {\n        polyfilledRawObj.diagnostic_record._severity = notification.severity;\n    }\n    if (notification.category != null) {\n        polyfilledRawObj.diagnostic_record._classification = notification.category;\n    }\n    if (notification.position != null) {\n        polyfilledRawObj.diagnostic_record._position = notification.position;\n    }\n    return new GqlStatusObject(polyfilledRawObj);\n}\nexports.polyfillGqlStatusObject = polyfillGqlStatusObject;\n/**\n * This objects are used for polyfilling the first status on the status list\n *\n * @private\n */\nvar staticGqlStatusObjects = {\n    SUCCESS: new GqlStatusObject({\n        gql_status: '00000',\n        status_description: 'note: successful completion',\n        diagnostic_record: gql_constants_1.rawPolyfilledDiagnosticRecord\n    }),\n    NO_DATA: new GqlStatusObject({\n        gql_status: '02000',\n        status_description: 'note: no data',\n        diagnostic_record: gql_constants_1.rawPolyfilledDiagnosticRecord\n    }),\n    NO_DATA_UNKNOWN_SUBCONDITION: new GqlStatusObject(__assign(__assign({}, unknownGqlStatus.NO_DATA), { diagnostic_record: gql_constants_1.rawPolyfilledDiagnosticRecord })),\n    OMITTED_RESULT: new GqlStatusObject({\n        gql_status: '00001',\n        status_description: 'note: successful completion - omitted result',\n        diagnostic_record: gql_constants_1.rawPolyfilledDiagnosticRecord\n    })\n};\nObject.freeze(staticGqlStatusObjects);\n/**\n *\n * @private\n * @param metadata\n * @returns\n */\nfunction buildGqlStatusObjectFromMetadata(metadata) {\n    var _a, _b;\n    function getGqlStatusObjectFromStreamSummary(summary) {\n        if ((summary === null || summary === void 0 ? void 0 : summary.have_records_streamed) === true) {\n            return staticGqlStatusObjects.SUCCESS;\n        }\n        if ((summary === null || summary === void 0 ? void 0 : summary.has_keys) === false) {\n            return staticGqlStatusObjects.OMITTED_RESULT;\n        }\n        if ((summary === null || summary === void 0 ? void 0 : summary.pulled) === true) {\n            return staticGqlStatusObjects.NO_DATA;\n        }\n        return staticGqlStatusObjects.NO_DATA_UNKNOWN_SUBCONDITION;\n    }\n    if (metadata.statuses != null) {\n        return metadata.statuses.map(function (status) { return new GqlStatusObject(status); });\n    }\n    var clientGenerated = getGqlStatusObjectFromStreamSummary(metadata.stream_summary);\n    var polyfilledObjects = __spreadArray([clientGenerated], __read(((_b = (_a = metadata.notifications) === null || _a === void 0 ? void 0 : _a.map(polyfillGqlStatusObject)) !== null && _b !== void 0 ? _b : [])), false);\n    return polyfilledObjects.sort(function (a, b) { return calculateWeight(a) - calculateWeight(b); });\n}\nexports.buildGqlStatusObjectFromMetadata = buildGqlStatusObjectFromMetadata;\nvar gqlStatusWeightByClass = Object.freeze({\n    '02': 0,\n    '01': 1,\n    '00': 2\n});\n/**\n * GqlStatus weight\n *\n * @private\n */\nfunction calculateWeight(gqlStatusObject) {\n    var _a, _b;\n    var gqlClass = (_a = gqlStatusObject.gqlStatus) === null || _a === void 0 ? void 0 : _a.slice(0, 2);\n    // @ts-expect-error\n    return (_b = gqlStatusWeightByClass[gqlClass]) !== null && _b !== void 0 ? _b : 9999;\n}\n/**\n *\n * @private\n * @param metadata\n * @returns\n */\nfunction buildNotificationsFromMetadata(metadata) {\n    if (metadata.notifications != null) {\n        return metadata.notifications.map(function (n) { return new Notification(n); });\n    }\n    if (metadata.statuses != null) {\n        return metadata.statuses.map(polyfillNotification).filter(function (n) { return n != null; });\n    }\n    return [];\n}\nexports.buildNotificationsFromMetadata = buildNotificationsFromMetadata;\n/**\n *\n * @private\n * @param pos\n * @returns {NotificationPosition}\n */\nfunction _constructPosition(pos) {\n    if (pos == null) {\n        return {};\n    }\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    return {\n        offset: internal_1.util.toNumber(pos.offset),\n        line: internal_1.util.toNumber(pos.line),\n        column: internal_1.util.toNumber(pos.column)\n    };\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n}\nfunction _asEnumerableSeverity(severity) {\n    return severityLevels.includes(severity)\n        ? severity\n        : notificationSeverityLevel.UNKNOWN;\n}\nfunction _asEnumerableClassification(classification) {\n    return categories.includes(classification)\n        ? classification\n        : notificationClassification.UNKNOWN;\n}\nexports[\"default\"] = Notification;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL25vdGlmaWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyx3Q0FBd0MsR0FBRyw0QkFBNEIsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxrQ0FBa0MsR0FBRyw0QkFBNEIsR0FBRyxpQ0FBaUM7QUFDM1M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxrRUFBUTtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBWTtBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw2QkFBNkI7QUFDdEY7QUFDQTtBQUNBLGlGQUFpRixtQkFBbUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL25vdGlmaWNhdGlvbi5qcz9kNDgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZE5vdGlmaWNhdGlvbnNGcm9tTWV0YWRhdGEgPSBleHBvcnRzLmJ1aWxkR3FsU3RhdHVzT2JqZWN0RnJvbU1ldGFkYXRhID0gZXhwb3J0cy5wb2x5ZmlsbE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMucG9seWZpbGxHcWxTdGF0dXNPYmplY3QgPSBleHBvcnRzLkdxbFN0YXR1c09iamVjdCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uID0gZXhwb3J0cy5ub3RpZmljYXRpb25DbGFzc2lmaWNhdGlvbiA9IGV4cG9ydHMubm90aWZpY2F0aW9uQ2F0ZWdvcnkgPSBleHBvcnRzLm5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWwgPSB2b2lkIDA7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGpzb24gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vanNvblwiKSk7XG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xudmFyIGdxbF9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2dxbC1jb25zdGFudHNcIik7XG52YXIgdW5rbm93bkdxbFN0YXR1cyA9IHtcbiAgICBXQVJOSU5HOiB7XG4gICAgICAgIGdxbF9zdGF0dXM6ICcwMU40MicsXG4gICAgICAgIHN0YXR1c19kZXNjcmlwdGlvbjogJ3dhcm46IHVua25vd24gd2FybmluZydcbiAgICB9LFxuICAgIE5PX0RBVEE6IHtcbiAgICAgICAgZ3FsX3N0YXR1czogJzAyTjQyJyxcbiAgICAgICAgc3RhdHVzX2Rlc2NyaXB0aW9uOiAnbm90ZTogbm8gZGF0YSAtIHVua25vd24gc3ViY29uZGl0aW9uJ1xuICAgIH0sXG4gICAgSU5GT1JNQVRJT046IHtcbiAgICAgICAgZ3FsX3N0YXR1czogJzAzTjQyJyxcbiAgICAgICAgc3RhdHVzX2Rlc2NyaXB0aW9uOiAnaW5mbzogdW5rbm93biBub3RpZmljYXRpb24nXG4gICAgfSxcbiAgICBFUlJPUjoge1xuICAgICAgICBncWxfc3RhdHVzOiAnNTBONDInLFxuICAgICAgICBzdGF0dXNfZGVzY3JpcHRpb246ICdlcnJvcjogZ2VuZXJhbCBwcm9jZXNzaW5nIGV4Y2VwdGlvbiAtIHVuZXhwZWN0ZWQgZXJyb3InXG4gICAgfVxufTtcbi8qKlxuICogQHR5cGVkZWYgeydXQVJOSU5HJyB8ICdJTkZPUk1BVElPTicgfCAnVU5LTk9XTid9IE5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWxcbiAqL1xuLyoqXG4gKiBDb25zdGFudHMgdGhhdCByZXByZXNlbnRzIHRoZSBTZXZlcml0eSBsZXZlbCBpbiB0aGUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqL1xudmFyIG5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWwgPSB7XG4gICAgV0FSTklORzogJ1dBUk5JTkcnLFxuICAgIElORk9STUFUSU9OOiAnSU5GT1JNQVRJT04nLFxuICAgIFVOS05PV046ICdVTktOT1dOJ1xufTtcbmV4cG9ydHMubm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbCA9IG5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWw7XG5PYmplY3QuZnJlZXplKG5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWwpO1xudmFyIHNldmVyaXR5TGV2ZWxzID0gT2JqZWN0LnZhbHVlcyhub3RpZmljYXRpb25TZXZlcml0eUxldmVsKTtcbi8qKlxuICogQHR5cGVkZWYgeydISU5UJyB8ICdVTlJFQ09HTklaRUQnIHwgJ1VOU1VQUE9SVEVEJyB8J1BFUkZPUk1BTkNFJyB8ICdUT1BPTE9HWScgfCAnU0VDVVJJVFknIHwgJ0RFUFJFQ0FUSU9OJyB8ICdHRU5FUklDJyB8ICdTQ0hFTUEnIHwgJ1VOS05PV04nIH0gTm90aWZpY2F0aW9uQ2F0ZWdvcnlcbiAqL1xuLyoqXG4gKiBDb25zdGFudHMgdGhhdCByZXByZXNlbnRzIHRoZSBDYXRlZ29yeSBpbiB0aGUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqL1xudmFyIG5vdGlmaWNhdGlvbkNhdGVnb3J5ID0ge1xuICAgIEhJTlQ6ICdISU5UJyxcbiAgICBVTlJFQ09HTklaRUQ6ICdVTlJFQ09HTklaRUQnLFxuICAgIFVOU1VQUE9SVEVEOiAnVU5TVVBQT1JURUQnLFxuICAgIFBFUkZPUk1BTkNFOiAnUEVSRk9STUFOQ0UnLFxuICAgIERFUFJFQ0FUSU9OOiAnREVQUkVDQVRJT04nLFxuICAgIFRPUE9MT0dZOiAnVE9QT0xPR1knLFxuICAgIFNFQ1VSSVRZOiAnU0VDVVJJVFknLFxuICAgIEdFTkVSSUM6ICdHRU5FUklDJyxcbiAgICBTQ0hFTUE6ICdTQ0hFTUEnLFxuICAgIFVOS05PV046ICdVTktOT1dOJ1xufTtcbmV4cG9ydHMubm90aWZpY2F0aW9uQ2F0ZWdvcnkgPSBub3RpZmljYXRpb25DYXRlZ29yeTtcbk9iamVjdC5mcmVlemUobm90aWZpY2F0aW9uQ2F0ZWdvcnkpO1xudmFyIGNhdGVnb3JpZXMgPSBPYmplY3QudmFsdWVzKG5vdGlmaWNhdGlvbkNhdGVnb3J5KTtcbi8qKlxuICogQHR5cGVkZWYge05vdGlmaWNhdGlvbkNhdGVnb3J5fSBOb3RpZmljYXRpb25DbGFzc2lmaWNhdGlvblxuICogQGV4cGVyaW1lbnRhbFxuICovXG4vKipcbiAqIENvbnN0YW50cyB0aGF0IHJlcHJlc2VudHMgdGhlIENsYXNzaWZpY2F0aW9uIGluIHRoZSB7QGxpbmsgR3FsU3RhdHVzT2JqZWN0fVxuICogQHR5cGUge25vdGlmaWNhdGlvbkNhdGVnb3J5fVxuICogQGV4cGVyaW1lbnRhbFxuICovXG52YXIgbm90aWZpY2F0aW9uQ2xhc3NpZmljYXRpb24gPSBub3RpZmljYXRpb25DYXRlZ29yeTtcbmV4cG9ydHMubm90aWZpY2F0aW9uQ2xhc3NpZmljYXRpb24gPSBub3RpZmljYXRpb25DbGFzc2lmaWNhdGlvbjtcbi8qKlxuICogQ2xhc3MgZm9yIEN5cGhlciBub3RpZmljYXRpb25zXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG52YXIgTm90aWZpY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gLSBPYmplY3Qgd2l0aCBub3RpZmljYXRpb24gZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2RlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29kZSA9IG5vdGlmaWNhdGlvbi5jb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpdGxlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGl0bGUgPSBub3RpZmljYXRpb24udGl0bGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVzY3JpcHRpb25cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IG5vdGlmaWNhdGlvbi5kZXNjcmlwdGlvbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByYXcgc2V2ZXJpdHlcbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIHtAbGluayBOb3RpZmljYXRpb24jcmF3U2V2ZXJpdHlMZXZlbH0gZm9yIHRoZSByYXcgdmFsdWUgb3Ige0BsaW5rIE5vdGlmaWNhdGlvbiNzZXZlcml0eUxldmVsfSBmb3IgYW4gZW51bWVyYXRlZCB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiA2LjAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldmVyaXR5ID0gbm90aWZpY2F0aW9uLnNldmVyaXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvc2l0aW9uIHdoaWNoIHRoZSBub3RpZmljYXRpb24gaGFkIG9jY3VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Tm90aWZpY2F0aW9uUG9zaXRpb259XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBfY29uc3RydWN0UG9zaXRpb24obm90aWZpY2F0aW9uLnBvc2l0aW9uKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXZlcml0eSBsZXZlbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Tm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbH1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCB7IHN1bW1hcnkgfSA9IGF3YWl0IHNlc3Npb24ucnVuKFwiUkVUVVJOIDFcIilcbiAgICAgICAgICpcbiAgICAgICAgICogZm9yIChjb25zdCBub3RpZmljYXRpb24gb2Ygc3VtbWFyeS5ub3RpZmljYXRpb25zKSB7XG4gICAgICAgICAqICAgICBzd2l0Y2gobm90aWZpY2F0aW9uLnNldmVyaXR5TGV2ZWwpIHtcbiAgICAgICAgICogICAgICAgICBjYXNlIG5lbzRqLm5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWwuSU5GT1JNQVRJT046IC8vIG9yIHNpbXBseSAnSU5GT1JNQVRJT04nXG4gICAgICAgICAqICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgJHtub3RpZmljYXRpb24udGl0bGV9IC0gJHtub3RpZmljYXRpb24uZGVzY3JpcHRpb259YClcbiAgICAgICAgICogICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICogICAgICAgICBjYXNlIG5lbzRqLm5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWwuV0FSTklORzogLy8gb3Igc2ltcGx5ICdXQVJOSU5HJ1xuICAgICAgICAgKiAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bm90aWZpY2F0aW9uLnRpdGxlfSAtICR7bm90aWZpY2F0aW9uLmRlc2NyaXB0aW9ufWApXG4gICAgICAgICAqICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAqICAgICAgICAgY2FzZSBuZW80ai5ub3RpZmljYXRpb25TZXZlcml0eUxldmVsLlVOS05PV046IC8vIG9yIHNpbXBseSAnVU5LTk9XTidcbiAgICAgICAgICogICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgKiAgICAgICAgICAgICAvLyB0aGUgcmF3IGluZm8gY2FtZSBmcm9tIHRoZSBzZXJ2ZXIgY291bGQgYmUgZm91bmQgYXQgbm90aWZpY2F0aW9uLnJhd1NldmVyaXR5TGV2ZWxcbiAgICAgICAgICogICAgICAgICAgICAgY29uc29sZS5sb2coYCR7bm90aWZpY2F0aW9uLnRpdGxlfSAtICR7bm90aWZpY2F0aW9uLmRlc2NyaXB0aW9ufWApXG4gICAgICAgICAqICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V2ZXJpdHlMZXZlbCA9IF9hc0VudW1lcmFibGVTZXZlcml0eShub3RpZmljYXRpb24uc2V2ZXJpdHkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNldmVyaXR5IGxldmVsIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aG91dCBhbnkgdmFsaWRhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXdTZXZlcml0eUxldmVsID0gbm90aWZpY2F0aW9uLnNldmVyaXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhdGVnb3J5XG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtOb3RpZmljYXRpb25DYXRlZ29yeX1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCB7IHN1bW1hcnkgfSA9IGF3YWl0IHNlc3Npb24ucnVuKFwiUkVUVVJOIDFcIilcbiAgICAgICAgICpcbiAgICAgICAgICogZm9yIChjb25zdCBub3RpZmljYXRpb24gb2Ygc3VtbWFyeS5ub3RpZmljYXRpb25zKSB7XG4gICAgICAgICAqICAgICBzd2l0Y2gobm90aWZpY2F0aW9uLmNhdGVnb3J5KSB7XG4gICAgICAgICAqICAgICAgICAgY2FzZSBuZW80ai5ub3RpZmljYXRpb25DYXRlZ29yeS5RVUVSWTogLy8gb3Igc2ltcGx5ICdRVUVSWSdcbiAgICAgICAgICogICAgICAgICAgICAgY29uc29sZS5pbmZvKGAke25vdGlmaWNhdGlvbi50aXRsZX0gLSAke25vdGlmaWNhdGlvbi5kZXNjcmlwdGlvbn1gKVxuICAgICAgICAgKiAgICAgICAgICAgICBicmVha1xuICAgICAgICAgKiAgICAgICAgIGNhc2UgbmVvNGoubm90aWZpY2F0aW9uQ2F0ZWdvcnkuUEVSRk9STUFOQ0U6IC8vIG9yIHNpbXBseSAnUEVSRk9STUFOQ0UnXG4gICAgICAgICAqICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtub3RpZmljYXRpb24udGl0bGV9IC0gJHtub3RpZmljYXRpb24uZGVzY3JpcHRpb259YClcbiAgICAgICAgICogICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICogICAgICAgICBjYXNlIG5lbzRqLm5vdGlmaWNhdGlvbkNhdGVnb3J5LlVOS05PV046IC8vIG9yIHNpbXBseSAnVU5LTk9XTidcbiAgICAgICAgICogICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgKiAgICAgICAgICAgICAvLyB0aGUgcmF3IGluZm8gY2FtZSBmcm9tIHRoZSBzZXJ2ZXIgY291bGQgYmUgZm91bmQgYXQgbm90aWZpY2F0aW9uLnJhd0NhdGVnb3J5XG4gICAgICAgICAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke25vdGlmaWNhdGlvbi50aXRsZX0gLSAke25vdGlmaWNhdGlvbi5kZXNjcmlwdGlvbn1gKVxuICAgICAgICAgKiAgICAgICAgICAgICBicmVha1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gX2FzRW51bWVyYWJsZUNsYXNzaWZpY2F0aW9uKG5vdGlmaWNhdGlvbi5jYXRlZ29yeSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2F0ZWdvcnkgcmV0dXJuZWQgYnkgdGhlIHNlcnZlciB3aXRob3V0IGFueSB2YWxpZGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXdDYXRlZ29yeSA9IG5vdGlmaWNhdGlvbi5jYXRlZ29yeTtcbiAgICB9XG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbjtcbn0oKSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbjtcbi8qKlxuICogUmVwcmVzZW50YXRpb24gZm9yIEdxbFN0YXR1c09iamVjdCBmb3VuZCB3aGVuIGV4ZWN1dGluZyBhIHF1ZXJ5LlxuICogPHA+XG4gKiBUaGlzIG9iamVjdCByZXByZXNlbnRzIGEgc3RhdHVzIG9mIHF1ZXJ5IGV4ZWN1dGlvbi5cbiAqIFRoaXMgc3RhdHVzIGlzIGEgc3VwZXJzZXQgb2Yge0BsaW5rIE5vdGlmaWNhdGlvbn0uXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICogQHB1YmxpY1xuICovXG52YXIgR3FsU3RhdHVzT2JqZWN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHJhd0dxbFN0YXR1c09iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3FsU3RhdHVzT2JqZWN0KHJhd0dxbFN0YXR1c09iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgR1FMU1RBVFVTXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3FsU3RhdHVzID0gcmF3R3FsU3RhdHVzT2JqZWN0LmdxbF9zdGF0dXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgR1FMU1RBVFVTIGRlc2NyaXB0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdHVzRGVzY3JpcHRpb24gPSByYXdHcWxTdGF0dXNPYmplY3Quc3RhdHVzX2Rlc2NyaXB0aW9uO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpYWdub3N0aWMgcmVjb3JkIGFzIGl0IGlzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNSZWNvcmQgPSAoX2EgPSByYXdHcWxTdGF0dXNPYmplY3QuZGlhZ25vc3RpY19yZWNvcmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBub3RpZmljYXRpb24gaGFkIG9jY3VycmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Tm90aWZpY2F0aW9uUG9zaXRpb24gfCB1bmRlZmluZWR9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmRpYWdub3N0aWNSZWNvcmQuX3Bvc2l0aW9uICE9IG51bGwgPyBfY29uc3RydWN0UG9zaXRpb24odGhpcy5kaWFnbm9zdGljUmVjb3JkLl9wb3NpdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2V2ZXJpdHlcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge05vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWx9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgeyBzdW1tYXJ5IH0gPSBhd2FpdCBzZXNzaW9uLnJ1bihcIlJFVFVSTiAxXCIpXG4gICAgICAgICAqXG4gICAgICAgICAqIGZvciAoY29uc3QgZ3FsU3RhdHVzT2JqZWN0IG9mIHN1bW1hcnkuZ3FsU3RhdHVzT2JqZWN0cykge1xuICAgICAgICAgKiAgICAgc3dpdGNoKGdxbFN0YXR1c09iamVjdC5zZXZlcml0eSkge1xuICAgICAgICAgKiAgICAgICAgIGNhc2UgbmVvNGoubm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbC5JTkZPUk1BVElPTjogLy8gb3Igc2ltcGx5ICdJTkZPUk1BVElPTidcbiAgICAgICAgICogICAgICAgICAgICAgY29uc29sZS5pbmZvKGdxbFN0YXR1c09iamVjdC5zdGF0dXNEZXNjcmlwdGlvbilcbiAgICAgICAgICogICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICogICAgICAgICBjYXNlIG5lbzRqLm5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWwuV0FSTklORzogLy8gb3Igc2ltcGx5ICdXQVJOSU5HJ1xuICAgICAgICAgKiAgICAgICAgICAgICBjb25zb2xlLndhcm4oZ3FsU3RhdHVzT2JqZWN0LnN0YXR1c0Rlc2NyaXB0aW9uKVxuICAgICAgICAgKiAgICAgICAgICAgICBicmVha1xuICAgICAgICAgKiAgICAgICAgIGNhc2UgbmVvNGoubm90aWZpY2F0aW9uU2V2ZXJpdHlMZXZlbC5VTktOT1dOOiAvLyBvciBzaW1wbHkgJ1VOS05PV04nXG4gICAgICAgICAqICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICogICAgICAgICAgICAgLy8gdGhlIHJhdyBpbmZvIGNhbWUgZnJvbSB0aGUgc2VydmVyIGNvdWxkIGJlIGZvdW5kIGF0IGdxbFN0YXR1c09iamVjdC5yYXdTZXZlcml0eVxuICAgICAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhncWxTdGF0dXNPYmplY3Quc3RhdHVzRGVzY3JpcHRpb24pXG4gICAgICAgICAqICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBfYXNFbnVtZXJhYmxlU2V2ZXJpdHkodGhpcy5kaWFnbm9zdGljUmVjb3JkLl9zZXZlcml0eSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2V2ZXJpdHkgcmV0dXJuZWQgaW4gdGhlIGRpYWdub3N0aWMgcmVjb3JkIGZyb20gdGhlIHNlcnZlciB3aXRob3V0IGFueSB2YWxpZGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nIHwgdW5kZWZpbmVkfVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhd1NldmVyaXR5ID0gdGhpcy5kaWFnbm9zdGljUmVjb3JkLl9zZXZlcml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbGFzc2lmaWNhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Tm90aWZpY2F0aW9uQ2xhc3NpZmljYXRpb259XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgeyBzdW1tYXJ5IH0gPSBhd2FpdCBzZXNzaW9uLnJ1bihcIlJFVFVSTiAxXCIpXG4gICAgICAgICAqXG4gICAgICAgICAqIGZvciAoY29uc3QgZ3FsU3RhdHVzT2JqZWN0IG9mIHN1bW1hcnkuZ3FsU3RhdHVzT2JqZWN0cykge1xuICAgICAgICAgKiAgICAgc3dpdGNoKGdxbFN0YXR1c09iamVjdC5jbGFzc2lmaWNhdGlvbikge1xuICAgICAgICAgKiAgICAgICAgIGNhc2UgbmVvNGoubm90aWZpY2F0aW9uQ2xhc3NpZmljYXRpb24uUVVFUlk6IC8vIG9yIHNpbXBseSAnUVVFUlknXG4gICAgICAgICAqICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhncWxTdGF0dXNPYmplY3Quc3RhdHVzRGVzY3JpcHRpb24pXG4gICAgICAgICAqICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAqICAgICAgICAgY2FzZSBuZW80ai5ub3RpZmljYXRpb25DbGFzc2lmaWNhdGlvbi5QRVJGT1JNQU5DRTogLy8gb3Igc2ltcGx5ICdQRVJGT1JNQU5DRSdcbiAgICAgICAgICogICAgICAgICAgICAgY29uc29sZS53YXJuKGdxbFN0YXR1c09iamVjdC5zdGF0dXNEZXNjcmlwdGlvbilcbiAgICAgICAgICogICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICogICAgICAgICBjYXNlIG5lbzRqLm5vdGlmaWNhdGlvbkNsYXNzaWZpY2F0aW9uLlVOS05PV046IC8vIG9yIHNpbXBseSAnVU5LTk9XTidcbiAgICAgICAgICogICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgKiAgICAgICAgICAgICAvLyB0aGUgcmF3IGluZm8gY2FtZSBmcm9tIHRoZSBzZXJ2ZXIgY2FuIGJlIGZvdW5kIGF0IG5vdGlmaWNhdGlvbi5yYXdDYXRlZ29yeVxuICAgICAgICAgKiAgICAgICAgICAgICBjb25zb2xlLmxvZyhncWxTdGF0dXNPYmplY3Quc3RhdHVzRGVzY3JpcHRpb24pXG4gICAgICAgICAqICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NpZmljYXRpb24gPSBfYXNFbnVtZXJhYmxlQ2xhc3NpZmljYXRpb24odGhpcy5kaWFnbm9zdGljUmVjb3JkLl9jbGFzc2lmaWNhdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2F0ZWdvcnkgcmV0dXJuZWQgYnkgdGhlIHNlcnZlciB3aXRob3V0IGFueSB2YWxpZGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXdDbGFzc2lmaWNhdGlvbiA9IHRoaXMuZGlhZ25vc3RpY1JlY29yZC5fY2xhc3NpZmljYXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgdGhpcyBvYmplY3QgcmVwcmVzZW50cyBhIG5vdGlmaWNhdGlvbiBhbmQgaXQgY2FuIGJlIGZpbHRlcmVkIHVzaW5nXG4gICAgICAgICAqIE5vdGlmaWNhdGlvbkZpbHRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogT25seSBHcWxTdGF0dXNPYmplY3Qgd2hpY2ggaXMgTm90aWZpY2F0aW9uIGhhcyBtZWFuaW5nZnVsIHBvc2l0aW9uLCBzZXZlcml0eSBhbmRcbiAgICAgICAgICogY2xhc3NpZmljYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzTm90aWZpY2F0aW9uID0gcmF3R3FsU3RhdHVzT2JqZWN0Lm5lbzRqX2NvZGUgIT0gbnVsbDtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdxbFN0YXR1c09iamVjdC5wcm90b3R5cGUsIFwiZGlhZ25vc3RpY1JlY29yZEFzSnNvblN0cmluZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUganNvbiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRpYWdub3N0aWMgcmVjb3JkLlxuICAgICAgICAgKiBUaGUgZ29hbCBvZiB0aGlzIG1ldGhvZCBpcyBwcm92aWRlIGEgc2VyaWFsaXplZCBvYmplY3QgZm9yIGh1bWFuIGluc3BlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uc3RyaW5naWZ5KHRoaXMuZGlhZ25vc3RpY1JlY29yZCwgeyB1c2VDdXN0b21Ub1N0cmluZzogdHJ1ZSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBHcWxTdGF0dXNPYmplY3Q7XG59KCkpO1xuZXhwb3J0cy5HcWxTdGF0dXNPYmplY3QgPSBHcWxTdGF0dXNPYmplY3Q7XG4vKipcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHN0YXR1c1xuICogQHJldHVybnMge05vdGlmaWNhdGlvbnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHBvbHlmaWxsTm90aWZpY2F0aW9uKHN0YXR1cykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8vIE5vbiBub3RpZmljYXRpb24gc3RhdHVzIHNob3VsZCBoYXZlIG5lbzRqX2NvZGVcbiAgICBpZiAoc3RhdHVzLm5lbzRqX2NvZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbih7XG4gICAgICAgIGNvZGU6IHN0YXR1cy5uZW80al9jb2RlLFxuICAgICAgICB0aXRsZTogc3RhdHVzLnRpdGxlLFxuICAgICAgICBkZXNjcmlwdGlvbjogc3RhdHVzLmRlc2NyaXB0aW9uLFxuICAgICAgICBzZXZlcml0eTogKF9hID0gc3RhdHVzLmRpYWdub3N0aWNfcmVjb3JkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3NldmVyaXR5LFxuICAgICAgICBjYXRlZ29yeTogKF9iID0gc3RhdHVzLmRpYWdub3N0aWNfcmVjb3JkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuX2NsYXNzaWZpY2F0aW9uLFxuICAgICAgICBwb3NpdGlvbjogKF9jID0gc3RhdHVzLmRpYWdub3N0aWNfcmVjb3JkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuX3Bvc2l0aW9uXG4gICAgfSk7XG59XG5leHBvcnRzLnBvbHlmaWxsTm90aWZpY2F0aW9uID0gcG9seWZpbGxOb3RpZmljYXRpb247XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gbm90aWZpY2F0aW9uXG4gKiBAcmV0dXJucyB7R3FsU3RhdHVzT2JqZWN0fVxuICovXG5mdW5jdGlvbiBwb2x5ZmlsbEdxbFN0YXR1c09iamVjdChub3RpZmljYXRpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGRlZmF1bHRTdGF0dXMgPSBub3RpZmljYXRpb24uc2V2ZXJpdHkgPT09IG5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWwuV0FSTklORyA/IHVua25vd25HcWxTdGF0dXMuV0FSTklORyA6IHVua25vd25HcWxTdGF0dXMuSU5GT1JNQVRJT047XG4gICAgdmFyIHBvbHlmaWxsZWRSYXdPYmogPSB7XG4gICAgICAgIGdxbF9zdGF0dXM6IGRlZmF1bHRTdGF0dXMuZ3FsX3N0YXR1cyxcbiAgICAgICAgc3RhdHVzX2Rlc2NyaXB0aW9uOiAoX2EgPSBub3RpZmljYXRpb24uZGVzY3JpcHRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRTdGF0dXMuc3RhdHVzX2Rlc2NyaXB0aW9uLFxuICAgICAgICBuZW80al9jb2RlOiBub3RpZmljYXRpb24uY29kZSxcbiAgICAgICAgdGl0bGU6IG5vdGlmaWNhdGlvbi50aXRsZSxcbiAgICAgICAgZGlhZ25vc3RpY19yZWNvcmQ6IF9fYXNzaWduKHt9LCBncWxfY29uc3RhbnRzXzEucmF3UG9seWZpbGxlZERpYWdub3N0aWNSZWNvcmQpXG4gICAgfTtcbiAgICBpZiAobm90aWZpY2F0aW9uLnNldmVyaXR5ICE9IG51bGwpIHtcbiAgICAgICAgcG9seWZpbGxlZFJhd09iai5kaWFnbm9zdGljX3JlY29yZC5fc2V2ZXJpdHkgPSBub3RpZmljYXRpb24uc2V2ZXJpdHk7XG4gICAgfVxuICAgIGlmIChub3RpZmljYXRpb24uY2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBwb2x5ZmlsbGVkUmF3T2JqLmRpYWdub3N0aWNfcmVjb3JkLl9jbGFzc2lmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbi5jYXRlZ29yeTtcbiAgICB9XG4gICAgaWYgKG5vdGlmaWNhdGlvbi5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHBvbHlmaWxsZWRSYXdPYmouZGlhZ25vc3RpY19yZWNvcmQuX3Bvc2l0aW9uID0gbm90aWZpY2F0aW9uLnBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEdxbFN0YXR1c09iamVjdChwb2x5ZmlsbGVkUmF3T2JqKTtcbn1cbmV4cG9ydHMucG9seWZpbGxHcWxTdGF0dXNPYmplY3QgPSBwb2x5ZmlsbEdxbFN0YXR1c09iamVjdDtcbi8qKlxuICogVGhpcyBvYmplY3RzIGFyZSB1c2VkIGZvciBwb2x5ZmlsbGluZyB0aGUgZmlyc3Qgc3RhdHVzIG9uIHRoZSBzdGF0dXMgbGlzdFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBzdGF0aWNHcWxTdGF0dXNPYmplY3RzID0ge1xuICAgIFNVQ0NFU1M6IG5ldyBHcWxTdGF0dXNPYmplY3Qoe1xuICAgICAgICBncWxfc3RhdHVzOiAnMDAwMDAnLFxuICAgICAgICBzdGF0dXNfZGVzY3JpcHRpb246ICdub3RlOiBzdWNjZXNzZnVsIGNvbXBsZXRpb24nLFxuICAgICAgICBkaWFnbm9zdGljX3JlY29yZDogZ3FsX2NvbnN0YW50c18xLnJhd1BvbHlmaWxsZWREaWFnbm9zdGljUmVjb3JkXG4gICAgfSksXG4gICAgTk9fREFUQTogbmV3IEdxbFN0YXR1c09iamVjdCh7XG4gICAgICAgIGdxbF9zdGF0dXM6ICcwMjAwMCcsXG4gICAgICAgIHN0YXR1c19kZXNjcmlwdGlvbjogJ25vdGU6IG5vIGRhdGEnLFxuICAgICAgICBkaWFnbm9zdGljX3JlY29yZDogZ3FsX2NvbnN0YW50c18xLnJhd1BvbHlmaWxsZWREaWFnbm9zdGljUmVjb3JkXG4gICAgfSksXG4gICAgTk9fREFUQV9VTktOT1dOX1NVQkNPTkRJVElPTjogbmV3IEdxbFN0YXR1c09iamVjdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdW5rbm93bkdxbFN0YXR1cy5OT19EQVRBKSwgeyBkaWFnbm9zdGljX3JlY29yZDogZ3FsX2NvbnN0YW50c18xLnJhd1BvbHlmaWxsZWREaWFnbm9zdGljUmVjb3JkIH0pKSxcbiAgICBPTUlUVEVEX1JFU1VMVDogbmV3IEdxbFN0YXR1c09iamVjdCh7XG4gICAgICAgIGdxbF9zdGF0dXM6ICcwMDAwMScsXG4gICAgICAgIHN0YXR1c19kZXNjcmlwdGlvbjogJ25vdGU6IHN1Y2Nlc3NmdWwgY29tcGxldGlvbiAtIG9taXR0ZWQgcmVzdWx0JyxcbiAgICAgICAgZGlhZ25vc3RpY19yZWNvcmQ6IGdxbF9jb25zdGFudHNfMS5yYXdQb2x5ZmlsbGVkRGlhZ25vc3RpY1JlY29yZFxuICAgIH0pXG59O1xuT2JqZWN0LmZyZWV6ZShzdGF0aWNHcWxTdGF0dXNPYmplY3RzKTtcbi8qKlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gbWV0YWRhdGFcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkR3FsU3RhdHVzT2JqZWN0RnJvbU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBmdW5jdGlvbiBnZXRHcWxTdGF0dXNPYmplY3RGcm9tU3RyZWFtU3VtbWFyeShzdW1tYXJ5KSB7XG4gICAgICAgIGlmICgoc3VtbWFyeSA9PT0gbnVsbCB8fCBzdW1tYXJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdW1tYXJ5LmhhdmVfcmVjb3Jkc19zdHJlYW1lZCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0aWNHcWxTdGF0dXNPYmplY3RzLlNVQ0NFU1M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdW1tYXJ5ID09PSBudWxsIHx8IHN1bW1hcnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1bW1hcnkuaGFzX2tleXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRpY0dxbFN0YXR1c09iamVjdHMuT01JVFRFRF9SRVNVTFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdW1tYXJ5ID09PSBudWxsIHx8IHN1bW1hcnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1bW1hcnkucHVsbGVkKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRpY0dxbFN0YXR1c09iamVjdHMuTk9fREFUQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGljR3FsU3RhdHVzT2JqZWN0cy5OT19EQVRBX1VOS05PV05fU1VCQ09ORElUSU9OO1xuICAgIH1cbiAgICBpZiAobWV0YWRhdGEuc3RhdHVzZXMgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEuc3RhdHVzZXMubWFwKGZ1bmN0aW9uIChzdGF0dXMpIHsgcmV0dXJuIG5ldyBHcWxTdGF0dXNPYmplY3Qoc3RhdHVzKTsgfSk7XG4gICAgfVxuICAgIHZhciBjbGllbnRHZW5lcmF0ZWQgPSBnZXRHcWxTdGF0dXNPYmplY3RGcm9tU3RyZWFtU3VtbWFyeShtZXRhZGF0YS5zdHJlYW1fc3VtbWFyeSk7XG4gICAgdmFyIHBvbHlmaWxsZWRPYmplY3RzID0gX19zcHJlYWRBcnJheShbY2xpZW50R2VuZXJhdGVkXSwgX19yZWFkKCgoX2IgPSAoX2EgPSBtZXRhZGF0YS5ub3RpZmljYXRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKHBvbHlmaWxsR3FsU3RhdHVzT2JqZWN0KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pKSwgZmFsc2UpO1xuICAgIHJldHVybiBwb2x5ZmlsbGVkT2JqZWN0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjYWxjdWxhdGVXZWlnaHQoYSkgLSBjYWxjdWxhdGVXZWlnaHQoYik7IH0pO1xufVxuZXhwb3J0cy5idWlsZEdxbFN0YXR1c09iamVjdEZyb21NZXRhZGF0YSA9IGJ1aWxkR3FsU3RhdHVzT2JqZWN0RnJvbU1ldGFkYXRhO1xudmFyIGdxbFN0YXR1c1dlaWdodEJ5Q2xhc3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICAnMDInOiAwLFxuICAgICcwMSc6IDEsXG4gICAgJzAwJzogMlxufSk7XG4vKipcbiAqIEdxbFN0YXR1cyB3ZWlnaHRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVXZWlnaHQoZ3FsU3RhdHVzT2JqZWN0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgZ3FsQ2xhc3MgPSAoX2EgPSBncWxTdGF0dXNPYmplY3QuZ3FsU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2xpY2UoMCwgMik7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHJldHVybiAoX2IgPSBncWxTdGF0dXNXZWlnaHRCeUNsYXNzW2dxbENsYXNzXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogOTk5OTtcbn1cbi8qKlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gbWV0YWRhdGFcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTm90aWZpY2F0aW9uc0Zyb21NZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIGlmIChtZXRhZGF0YS5ub3RpZmljYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLm5vdGlmaWNhdGlvbnMubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuZXcgTm90aWZpY2F0aW9uKG4pOyB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGFkYXRhLnN0YXR1c2VzICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLnN0YXR1c2VzLm1hcChwb2x5ZmlsbE5vdGlmaWNhdGlvbikuZmlsdGVyKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuICE9IG51bGw7IH0pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5leHBvcnRzLmJ1aWxkTm90aWZpY2F0aW9uc0Zyb21NZXRhZGF0YSA9IGJ1aWxkTm90aWZpY2F0aW9uc0Zyb21NZXRhZGF0YTtcbi8qKlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gcG9zXG4gKiBAcmV0dXJucyB7Tm90aWZpY2F0aW9uUG9zaXRpb259XG4gKi9cbmZ1bmN0aW9uIF9jb25zdHJ1Y3RQb3NpdGlvbihwb3MpIHtcbiAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG4gICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBpbnRlcm5hbF8xLnV0aWwudG9OdW1iZXIocG9zLm9mZnNldCksXG4gICAgICAgIGxpbmU6IGludGVybmFsXzEudXRpbC50b051bWJlcihwb3MubGluZSksXG4gICAgICAgIGNvbHVtbjogaW50ZXJuYWxfMS51dGlsLnRvTnVtYmVyKHBvcy5jb2x1bW4pXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gKi9cbn1cbmZ1bmN0aW9uIF9hc0VudW1lcmFibGVTZXZlcml0eShzZXZlcml0eSkge1xuICAgIHJldHVybiBzZXZlcml0eUxldmVscy5pbmNsdWRlcyhzZXZlcml0eSlcbiAgICAgICAgPyBzZXZlcml0eVxuICAgICAgICA6IG5vdGlmaWNhdGlvblNldmVyaXR5TGV2ZWwuVU5LTk9XTjtcbn1cbmZ1bmN0aW9uIF9hc0VudW1lcmFibGVDbGFzc2lmaWNhdGlvbihjbGFzc2lmaWNhdGlvbikge1xuICAgIHJldHVybiBjYXRlZ29yaWVzLmluY2x1ZGVzKGNsYXNzaWZpY2F0aW9uKVxuICAgICAgICA/IGNsYXNzaWZpY2F0aW9uXG4gICAgICAgIDogbm90aWZpY2F0aW9uQ2xhc3NpZmljYXRpb24uVU5LTk9XTjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE5vdGlmaWNhdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/notification.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/record.js":
/*!******************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/record.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nfunction generateFieldLookup(keys) {\n    var lookup = {};\n    keys.forEach(function (name, idx) {\n        lookup[name] = idx;\n    });\n    return lookup;\n}\n/**\n * Records make up the contents of the {@link Result}, and is how you access\n * the output of a query. A simple query might yield a result stream\n * with a single record, for instance:\n *\n *     MATCH (u:User) RETURN u.name, u.age\n *\n * This returns a stream of records with two fields, named `u.name` and `u.age`,\n * each record represents one user found by the query above. You can access\n * the values of each field either by name:\n *\n *     record.get(\"u.name\")\n *\n * Or by it's position:\n *\n *     record.get(0)\n *\n * @access public\n */\nvar Record = /** @class */ (function () {\n    /**\n     * Create a new record object.\n     * @constructor\n     * @protected\n     * @param {string[]} keys An array of field keys, in the order the fields appear in the record\n     * @param {Array} fields An array of field values\n     * @param {Object} fieldLookup An object of fieldName -> value index, used to map\n     *                            field names to values. If this is null, one will be\n     *                            generated.\n     */\n    function Record(keys, fields, fieldLookup) {\n        /**\n         * Field keys, in the order the fields appear in the record.\n         * @type {string[]}\n         */\n        this.keys = keys;\n        /**\n         * Number of fields\n         * @type {Number}\n         */\n        this.length = keys.length;\n        this._fields = fields;\n        this._fieldLookup = fieldLookup !== null && fieldLookup !== void 0 ? fieldLookup : generateFieldLookup(keys);\n    }\n    /**\n     * Run the given function for each field in this record. The function\n     * will get three arguments - the value, the key and this record, in that\n     * order.\n     *\n     * @param {function(value: Object, key: string, record: Record)} visitor the function to apply to each field.\n     * @returns {void} Nothing\n     */\n    Record.prototype.forEach = function (visitor) {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];\n                visitor(value, key, this);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * Run the given function for each field in this record. The function\n     * will get three arguments - the value, the key and this record, in that\n     * order.\n     *\n     * @param {function(value: Object, key: string, record: Record)} visitor the function to apply on each field\n     * and return a value that is saved to the returned Array.\n     *\n     * @returns {Array}\n     */\n    Record.prototype.map = function (visitor) {\n        var e_2, _a;\n        var resultArray = [];\n        try {\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];\n                resultArray.push(visitor(value, key, this));\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return resultArray;\n    };\n    /**\n     * Iterate over results. Each iteration will yield an array\n     * of exactly two items - the key, and the value (in order).\n     *\n     * @generator\n     * @returns {IterableIterator<Array>}\n     */\n    Record.prototype.entries = function () {\n        var i;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    i = 0;\n                    _a.label = 1;\n                case 1:\n                    if (!(i < this.keys.length)) return [3 /*break*/, 4];\n                    return [4 /*yield*/, [this.keys[i], this._fields[i]]];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Iterate over values.\n     *\n     * @generator\n     * @returns {IterableIterator<Object>}\n     */\n    Record.prototype.values = function () {\n        var i;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    i = 0;\n                    _a.label = 1;\n                case 1:\n                    if (!(i < this.keys.length)) return [3 /*break*/, 4];\n                    return [4 /*yield*/, this._fields[i]];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Iterate over values. Delegates to {@link Record#values}\n     *\n     * @generator\n     * @returns {IterableIterator<Object>}\n     */\n    Record.prototype[Symbol.iterator] = function () {\n        var i;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    i = 0;\n                    _a.label = 1;\n                case 1:\n                    if (!(i < this.keys.length)) return [3 /*break*/, 4];\n                    return [4 /*yield*/, this._fields[i]];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Generates an object out of the current Record\n     *\n     * @returns {Object}\n     */\n    Record.prototype.toObject = function () {\n        var e_3, _a;\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        var obj = {};\n        try {\n            for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];\n                obj[key] = value;\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return obj;\n    };\n    /**\n     * Get a value from this record, either by index or by field key.\n     *\n     * @param {string|Number} key Field key, or the index of the field.\n     * @returns {*}\n     */\n    Record.prototype.get = function (key) {\n        var index;\n        if (!(typeof key === 'number')) {\n            index = this._fieldLookup[key];\n            if (index === undefined) {\n                throw (0, error_1.newError)(\"This record has no field with key '\".concat(key.toString(), \"', available keys are: [\") +\n                    this.keys.toString() +\n                    '].');\n            }\n        }\n        else {\n            index = key;\n        }\n        if (index > this._fields.length - 1 || index < 0) {\n            throw (0, error_1.newError)(\"This record has no field with index '\" +\n                index.toString() +\n                \"'. Remember that indexes start at `0`, \" +\n                'and make sure your query returns records in the shape you meant it to.');\n        }\n        return this._fields[index];\n    };\n    /**\n     * Check if a value from this record, either by index or by field key, exists.\n     *\n     * @param {string|Number} key Field key, or the index of the field.\n     * @returns {boolean}\n     */\n    Record.prototype.has = function (key) {\n        // if key is a number, we check if it is in the _fields array\n        if (typeof key === 'number') {\n            return key >= 0 && key < this._fields.length;\n        }\n        // if it's not a number, we check _fieldLookup dictionary directly\n        return this._fieldLookup[key] !== undefined;\n    };\n    return Record;\n}());\nexports[\"default\"] = Record;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3JlY29yZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLG9FQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBc0Q7QUFDckUsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBc0Q7QUFDckU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9yZWNvcmQuanM/MWJiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmZ1bmN0aW9uIGdlbmVyYXRlRmllbGRMb29rdXAoa2V5cykge1xuICAgIHZhciBsb29rdXAgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIGlkeCkge1xuICAgICAgICBsb29rdXBbbmFtZV0gPSBpZHg7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvb2t1cDtcbn1cbi8qKlxuICogUmVjb3JkcyBtYWtlIHVwIHRoZSBjb250ZW50cyBvZiB0aGUge0BsaW5rIFJlc3VsdH0sIGFuZCBpcyBob3cgeW91IGFjY2Vzc1xuICogdGhlIG91dHB1dCBvZiBhIHF1ZXJ5LiBBIHNpbXBsZSBxdWVyeSBtaWdodCB5aWVsZCBhIHJlc3VsdCBzdHJlYW1cbiAqIHdpdGggYSBzaW5nbGUgcmVjb3JkLCBmb3IgaW5zdGFuY2U6XG4gKlxuICogICAgIE1BVENIICh1OlVzZXIpIFJFVFVSTiB1Lm5hbWUsIHUuYWdlXG4gKlxuICogVGhpcyByZXR1cm5zIGEgc3RyZWFtIG9mIHJlY29yZHMgd2l0aCB0d28gZmllbGRzLCBuYW1lZCBgdS5uYW1lYCBhbmQgYHUuYWdlYCxcbiAqIGVhY2ggcmVjb3JkIHJlcHJlc2VudHMgb25lIHVzZXIgZm91bmQgYnkgdGhlIHF1ZXJ5IGFib3ZlLiBZb3UgY2FuIGFjY2Vzc1xuICogdGhlIHZhbHVlcyBvZiBlYWNoIGZpZWxkIGVpdGhlciBieSBuYW1lOlxuICpcbiAqICAgICByZWNvcmQuZ2V0KFwidS5uYW1lXCIpXG4gKlxuICogT3IgYnkgaXQncyBwb3NpdGlvbjpcbiAqXG4gKiAgICAgcmVjb3JkLmdldCgwKVxuICpcbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cbnZhciBSZWNvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJlY29yZCBvYmplY3QuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGtleXMgQW4gYXJyYXkgb2YgZmllbGQga2V5cywgaW4gdGhlIG9yZGVyIHRoZSBmaWVsZHMgYXBwZWFyIGluIHRoZSByZWNvcmRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgQW4gYXJyYXkgb2YgZmllbGQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpZWxkTG9va3VwIEFuIG9iamVjdCBvZiBmaWVsZE5hbWUgLT4gdmFsdWUgaW5kZXgsIHVzZWQgdG8gbWFwXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgbmFtZXMgdG8gdmFsdWVzLiBJZiB0aGlzIGlzIG51bGwsIG9uZSB3aWxsIGJlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlY29yZChrZXlzLCBmaWVsZHMsIGZpZWxkTG9va3VwKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWVsZCBrZXlzLCBpbiB0aGUgb3JkZXIgdGhlIGZpZWxkcyBhcHBlYXIgaW4gdGhlIHJlY29yZC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiBmaWVsZHNcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5fZmllbGRMb29rdXAgPSBmaWVsZExvb2t1cCAhPT0gbnVsbCAmJiBmaWVsZExvb2t1cCAhPT0gdm9pZCAwID8gZmllbGRMb29rdXAgOiBnZW5lcmF0ZUZpZWxkTG9va3VwKGtleXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGZpZWxkIGluIHRoaXMgcmVjb3JkLiBUaGUgZnVuY3Rpb25cbiAgICAgKiB3aWxsIGdldCB0aHJlZSBhcmd1bWVudHMgLSB0aGUgdmFsdWUsIHRoZSBrZXkgYW5kIHRoaXMgcmVjb3JkLCBpbiB0aGF0XG4gICAgICogb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPYmplY3QsIGtleTogc3RyaW5nLCByZWNvcmQ6IFJlY29yZCl9IHZpc2l0b3IgdGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZmllbGQuXG4gICAgICogQHJldHVybnMge3ZvaWR9IE5vdGhpbmdcbiAgICAgKi9cbiAgICBSZWNvcmQucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5lbnRyaWVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kID0gX19yZWFkKF9jLnZhbHVlLCAyKSwga2V5ID0gX2RbMF0sIHZhbHVlID0gX2RbMV07XG4gICAgICAgICAgICAgICAgdmlzaXRvcih2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGZpZWxkIGluIHRoaXMgcmVjb3JkLiBUaGUgZnVuY3Rpb25cbiAgICAgKiB3aWxsIGdldCB0aHJlZSBhcmd1bWVudHMgLSB0aGUgdmFsdWUsIHRoZSBrZXkgYW5kIHRoaXMgcmVjb3JkLCBpbiB0aGF0XG4gICAgICogb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBPYmplY3QsIGtleTogc3RyaW5nLCByZWNvcmQ6IFJlY29yZCl9IHZpc2l0b3IgdGhlIGZ1bmN0aW9uIHRvIGFwcGx5IG9uIGVhY2ggZmllbGRcbiAgICAgKiBhbmQgcmV0dXJuIGEgdmFsdWUgdGhhdCBpcyBzYXZlZCB0byB0aGUgcmV0dXJuZWQgQXJyYXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgUmVjb3JkLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgdmFyIHJlc3VsdEFycmF5ID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuZW50cmllcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IF9fcmVhZChfYy52YWx1ZSwgMiksIGtleSA9IF9kWzBdLCB2YWx1ZSA9IF9kWzFdO1xuICAgICAgICAgICAgICAgIHJlc3VsdEFycmF5LnB1c2godmlzaXRvcih2YWx1ZSwga2V5LCB0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0QXJyYXk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG92ZXIgcmVzdWx0cy4gRWFjaCBpdGVyYXRpb24gd2lsbCB5aWVsZCBhbiBhcnJheVxuICAgICAqIG9mIGV4YWN0bHkgdHdvIGl0ZW1zIC0gdGhlIGtleSwgYW5kIHRoZSB2YWx1ZSAoaW4gb3JkZXIpLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRvclxuICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPEFycmF5Pn1cbiAgICAgKi9cbiAgICBSZWNvcmQucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IHRoaXMua2V5cy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgW3RoaXMua2V5c1tpXSwgdGhpcy5fZmllbGRzW2ldXV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0b3JcbiAgICAgKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcjxPYmplY3Q+fVxuICAgICAqL1xuICAgIFJlY29yZC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCB0aGlzLmtleXMubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2ZpZWxkc1tpXV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIHZhbHVlcy4gRGVsZWdhdGVzIHRvIHtAbGluayBSZWNvcmQjdmFsdWVzfVxuICAgICAqXG4gICAgICogQGdlbmVyYXRvclxuICAgICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPE9iamVjdD59XG4gICAgICovXG4gICAgUmVjb3JkLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCB0aGlzLmtleXMubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2ZpZWxkc1tpXV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIG9iamVjdCBvdXQgb2YgdGhlIGN1cnJlbnQgUmVjb3JkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIFJlY29yZC5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5lbnRyaWVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kID0gX19yZWFkKF9jLnZhbHVlLCAyKSwga2V5ID0gX2RbMF0sIHZhbHVlID0gX2RbMV07XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWx1ZSBmcm9tIHRoaXMgcmVjb3JkLCBlaXRoZXIgYnkgaW5kZXggb3IgYnkgZmllbGQga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8TnVtYmVyfSBrZXkgRmllbGQga2V5LCBvciB0aGUgaW5kZXggb2YgdGhlIGZpZWxkLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIFJlY29yZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGlmICghKHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9maWVsZExvb2t1cFtrZXldO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JfMS5uZXdFcnJvcikoXCJUaGlzIHJlY29yZCBoYXMgbm8gZmllbGQgd2l0aCBrZXkgJ1wiLmNvbmNhdChrZXkudG9TdHJpbmcoKSwgXCInLCBhdmFpbGFibGUga2V5cyBhcmU6IFtcIikgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtleXMudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICddLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID4gdGhpcy5fZmllbGRzLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JfMS5uZXdFcnJvcikoXCJUaGlzIHJlY29yZCBoYXMgbm8gZmllbGQgd2l0aCBpbmRleCAnXCIgK1xuICAgICAgICAgICAgICAgIGluZGV4LnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgIFwiJy4gUmVtZW1iZXIgdGhhdCBpbmRleGVzIHN0YXJ0IGF0IGAwYCwgXCIgK1xuICAgICAgICAgICAgICAgICdhbmQgbWFrZSBzdXJlIHlvdXIgcXVlcnkgcmV0dXJucyByZWNvcmRzIGluIHRoZSBzaGFwZSB5b3UgbWVhbnQgaXQgdG8uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc1tpbmRleF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHZhbHVlIGZyb20gdGhpcyByZWNvcmQsIGVpdGhlciBieSBpbmRleCBvciBieSBmaWVsZCBrZXksIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE51bWJlcn0ga2V5IEZpZWxkIGtleSwgb3IgdGhlIGluZGV4IG9mIHRoZSBmaWVsZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBSZWNvcmQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gaWYga2V5IGlzIGEgbnVtYmVyLCB3ZSBjaGVjayBpZiBpdCBpcyBpbiB0aGUgX2ZpZWxkcyBhcnJheVxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkgPj0gMCAmJiBrZXkgPCB0aGlzLl9maWVsZHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGl0J3Mgbm90IGEgbnVtYmVyLCB3ZSBjaGVjayBfZmllbGRMb29rdXAgZGljdGlvbmFyeSBkaXJlY3RseVxuICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRMb29rdXBba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY29yZDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZWNvcmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/record.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/result-eager.js":
/*!************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/result-eager.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Represents the fully streamed result\n */\nvar EagerResult = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     * @param {string[]} keys The records keys\n     * @param {Record[]} records The resulted records\n     * @param {ResultSummary[]} summary The result Summary\n     */\n    function EagerResult(keys, records, summary) {\n        /**\n         * Field keys, in the order the fields appear in the records.\n         * @type {string[]}\n         */\n        this.keys = keys;\n        /**\n         * Field records, in the order the records arrived from the server.\n         * @type {Record[]}\n         */\n        this.records = records;\n        /**\n         * Field summary\n         * @type {ResultSummary}\n         */\n        this.summary = summary;\n    }\n    return EagerResult;\n}());\nexports[\"default\"] = EagerResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3Jlc3VsdC1lYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3Jlc3VsdC1lYWdlci5qcz9kMjE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZnVsbHkgc3RyZWFtZWQgcmVzdWx0XG4gKi9cbnZhciBFYWdlclJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGtleXMgVGhlIHJlY29yZHMga2V5c1xuICAgICAqIEBwYXJhbSB7UmVjb3JkW119IHJlY29yZHMgVGhlIHJlc3VsdGVkIHJlY29yZHNcbiAgICAgKiBAcGFyYW0ge1Jlc3VsdFN1bW1hcnlbXX0gc3VtbWFyeSBUaGUgcmVzdWx0IFN1bW1hcnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFYWdlclJlc3VsdChrZXlzLCByZWNvcmRzLCBzdW1tYXJ5KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWVsZCBrZXlzLCBpbiB0aGUgb3JkZXIgdGhlIGZpZWxkcyBhcHBlYXIgaW4gdGhlIHJlY29yZHMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWVsZCByZWNvcmRzLCBpbiB0aGUgb3JkZXIgdGhlIHJlY29yZHMgYXJyaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqIEB0eXBlIHtSZWNvcmRbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjb3JkcyA9IHJlY29yZHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWVsZCBzdW1tYXJ5XG4gICAgICAgICAqIEB0eXBlIHtSZXN1bHRTdW1tYXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdW1tYXJ5ID0gc3VtbWFyeTtcbiAgICB9XG4gICAgcmV0dXJuIEVhZ2VyUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVhZ2VyUmVzdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/result-eager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/result-summary.js":
/*!**************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/result-summary.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Stats = exports.QueryStatistics = exports.ProfiledPlan = exports.Plan = exports.ServerInfo = exports.queryType = void 0;\nvar internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/index.js\");\nvar notification_1 = __webpack_require__(/*! ./notification */ \"(rsc)/./node_modules/neo4j-driver-core/lib/notification.js\");\n/**\n * A ResultSummary instance contains structured metadata for a {@link Result}.\n * @access public\n */\nvar ResultSummary = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {string} query - The query this summary is for\n     * @param {Object} parameters - Parameters for the query\n     * @param {Object} metadata - Query metadata\n     * @param {number|undefined} protocolVersion - Bolt Protocol Version\n     */\n    function ResultSummary(query, parameters, metadata, protocolVersion) {\n        var _a, _b, _c;\n        /**\n         * The query and parameters this summary is for.\n         * @type {{text: string, parameters: Object}}\n         * @public\n         */\n        this.query = { text: query, parameters: parameters };\n        /**\n         * The type of query executed. Can be \"r\" for read-only query, \"rw\" for read-write query,\n         * \"w\" for write-only query and \"s\" for schema-write query.\n         * String constants are available in {@link queryType} object.\n         * @type {string}\n         * @public\n         */\n        this.queryType = metadata.type;\n        /**\n         * Counters for operations the query triggered.\n         * @type {QueryStatistics}\n         * @public\n         */\n        this.counters = new QueryStatistics((_a = metadata.stats) !== null && _a !== void 0 ? _a : {});\n        // for backwards compatibility, remove in future version\n        /**\n         * Use {@link ResultSummary.counters} instead.\n         * @type {QueryStatistics}\n         * @deprecated\n         */\n        this.updateStatistics = this.counters;\n        /**\n         * This describes how the database will execute the query.\n         * Query plan for the executed query if available, otherwise undefined.\n         * Will only be populated for queries that start with \"EXPLAIN\".\n         * @type {Plan|false}\n         * @public\n         */\n        this.plan =\n            metadata.plan != null || metadata.profile != null\n                ? new Plan((_b = metadata.plan) !== null && _b !== void 0 ? _b : metadata.profile)\n                : false;\n        /**\n         * This describes how the database did execute your query. This will contain detailed information about what\n         * each step of the plan did. Profiled query plan for the executed query if available, otherwise undefined.\n         * Will only be populated for queries that start with \"PROFILE\".\n         * @type {ProfiledPlan}\n         * @public\n         */\n        this.profile = metadata.profile != null ? new ProfiledPlan(metadata.profile) : false;\n        /**\n         * An array of notifications that might arise when executing the query. Notifications can be warnings about\n         * problematic queries or other valuable information that can be presented in a client. Unlike failures\n         * or errors, notifications do not affect the execution of a query.\n         * @type {Array<Notification>}\n         * @public\n         */\n        this.notifications = (0, notification_1.buildNotificationsFromMetadata)(metadata);\n        /**\n         * A list of GqlStatusObjects that arise when executing the query.\n         *\n         * The list always contains at least 1 status representing the Success, No Data or Omitted Result.\n         *\n         * When discarding records while connected to a non-gql aware server and using a RxSession,\n         * the driver might not be able to tell apart Success and No Data.\n         *\n         * All other status are notifications like warnings about problematic queries or other valuable\n         * information that can be presented in a client.\n         *\n         * The GqlStatusObjects will be presented in the following order:\n         *\n         * - A no data (02xxx) has precedence over a warning;\n         * - A warning (01xxx) has precedence over a success.\n         * - A success (00xxx) has precedence over anything informational (03xxx)\n         *\n         * @type {Array<GqlStatusObject>}\n         * @public\n         * @experimental\n         */\n        this.gqlStatusObjects = (0, notification_1.buildGqlStatusObjectFromMetadata)(metadata);\n        /**\n         * The basic information of the server where the result is obtained from.\n         * @type {ServerInfo}\n         * @public\n         */\n        this.server = new ServerInfo(metadata.server, protocolVersion);\n        /**\n         * The time it took the server to consume the result.\n         * @type {number}\n         * @public\n         */\n        this.resultConsumedAfter = metadata.result_consumed_after;\n        /**\n         * The time it took the server to make the result available for consumption in milliseconds.\n         * @type {number}\n         * @public\n         */\n        this.resultAvailableAfter = metadata.result_available_after;\n        /**\n         * The database name where this summary is obtained from.\n         * @type {{name: string}}\n         * @public\n         */\n        this.database = { name: (_c = metadata.db) !== null && _c !== void 0 ? _c : null };\n    }\n    /**\n     * Check if the result summary has a plan\n     * @return {boolean}\n     */\n    ResultSummary.prototype.hasPlan = function () {\n        return this.plan instanceof Plan;\n    };\n    /**\n     * Check if the result summary has a profile\n     * @return {boolean}\n     */\n    ResultSummary.prototype.hasProfile = function () {\n        return this.profile instanceof ProfiledPlan;\n    };\n    return ResultSummary;\n}());\n/**\n * Class for execution plan received by prepending Cypher with EXPLAIN.\n * @access public\n */\nvar Plan = /** @class */ (function () {\n    /**\n     * Create a Plan instance\n     * @constructor\n     * @param {Object} plan - Object with plan data\n     */\n    function Plan(plan) {\n        this.operatorType = plan.operatorType;\n        this.identifiers = plan.identifiers;\n        this.arguments = plan.args;\n        this.children = plan.children != null\n            ? plan.children.map(function (child) { return new Plan(child); })\n            : [];\n    }\n    return Plan;\n}());\nexports.Plan = Plan;\n/**\n * Class for execution plan received by prepending Cypher with PROFILE.\n * @access public\n */\nvar ProfiledPlan = /** @class */ (function () {\n    /**\n     * Create a ProfiledPlan instance\n     * @constructor\n     * @param {Object} profile - Object with profile data\n     */\n    function ProfiledPlan(profile) {\n        this.operatorType = profile.operatorType;\n        this.identifiers = profile.identifiers;\n        this.arguments = profile.args;\n        this.dbHits = valueOrDefault('dbHits', profile);\n        this.rows = valueOrDefault('rows', profile);\n        this.pageCacheMisses = valueOrDefault('pageCacheMisses', profile);\n        this.pageCacheHits = valueOrDefault('pageCacheHits', profile);\n        this.pageCacheHitRatio = valueOrDefault('pageCacheHitRatio', profile);\n        this.time = valueOrDefault('time', profile);\n        this.children = profile.children != null\n            ? profile.children.map(function (child) { return new ProfiledPlan(child); })\n            : [];\n    }\n    ProfiledPlan.prototype.hasPageCacheStats = function () {\n        return (this.pageCacheMisses > 0 ||\n            this.pageCacheHits > 0 ||\n            this.pageCacheHitRatio > 0);\n    };\n    return ProfiledPlan;\n}());\nexports.ProfiledPlan = ProfiledPlan;\n/**\n * Stats Query statistics dictionary for a {@link QueryStatistics}\n * @public\n */\nvar Stats = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     */\n    function Stats() {\n        /**\n         * nodes created\n         * @type {number}\n         * @public\n         */\n        this.nodesCreated = 0;\n        /**\n         * nodes deleted\n         * @type {number}\n         * @public\n         */\n        this.nodesDeleted = 0;\n        /**\n         * relationships created\n         * @type {number}\n         * @public\n         */\n        this.relationshipsCreated = 0;\n        /**\n         * relationships deleted\n         * @type {number}\n         * @public\n         */\n        this.relationshipsDeleted = 0;\n        /**\n         * properties set\n         * @type {number}\n         * @public\n         */\n        this.propertiesSet = 0;\n        /**\n         * labels added\n         * @type {number}\n         * @public\n         */\n        this.labelsAdded = 0;\n        /**\n         * labels removed\n         * @type {number}\n         * @public\n         */\n        this.labelsRemoved = 0;\n        /**\n         * indexes added\n         * @type {number}\n         * @public\n         */\n        this.indexesAdded = 0;\n        /**\n         * indexes removed\n         * @type {number}\n         * @public\n         */\n        this.indexesRemoved = 0;\n        /**\n         * constraints added\n         * @type {number}\n         * @public\n         */\n        this.constraintsAdded = 0;\n        /**\n         * constraints removed\n         * @type {number}\n         * @public\n         */\n        this.constraintsRemoved = 0;\n    }\n    return Stats;\n}());\nexports.Stats = Stats;\n/**\n * Get statistical information for a {@link Result}.\n * @access public\n */\nvar QueryStatistics = /** @class */ (function () {\n    /**\n     * Structurize the statistics\n     * @constructor\n     * @param {Object} statistics - Result statistics\n     */\n    function QueryStatistics(statistics) {\n        var _this = this;\n        this._stats = {\n            nodesCreated: 0,\n            nodesDeleted: 0,\n            relationshipsCreated: 0,\n            relationshipsDeleted: 0,\n            propertiesSet: 0,\n            labelsAdded: 0,\n            labelsRemoved: 0,\n            indexesAdded: 0,\n            indexesRemoved: 0,\n            constraintsAdded: 0,\n            constraintsRemoved: 0\n        };\n        this._systemUpdates = 0;\n        Object.keys(statistics).forEach(function (index) {\n            // To camelCase\n            var camelCaseIndex = index.replace(/(-\\w)/g, function (m) { return m[1].toUpperCase(); });\n            if (camelCaseIndex in _this._stats) {\n                _this._stats[camelCaseIndex] = internal_1.util.toNumber(statistics[index]);\n            }\n            else if (camelCaseIndex === 'systemUpdates') {\n                _this._systemUpdates = internal_1.util.toNumber(statistics[index]);\n            }\n            else if (camelCaseIndex === 'containsSystemUpdates') {\n                _this._containsSystemUpdates = statistics[index];\n            }\n            else if (camelCaseIndex === 'containsUpdates') {\n                _this._containsUpdates = statistics[index];\n            }\n        });\n        this._stats = Object.freeze(this._stats);\n    }\n    /**\n     * Did the database get updated?\n     * @return {boolean}\n     */\n    QueryStatistics.prototype.containsUpdates = function () {\n        var _this = this;\n        return this._containsUpdates !== undefined\n            ? this._containsUpdates\n            : (Object.keys(this._stats).reduce(function (last, current) {\n                return last + _this._stats[current];\n            }, 0) > 0);\n    };\n    /**\n     * Returns the query statistics updates in a dictionary.\n     * @returns {Stats}\n     */\n    QueryStatistics.prototype.updates = function () {\n        return this._stats;\n    };\n    /**\n     * Return true if the system database get updated, otherwise false\n     * @returns {boolean} - If the system database get updated or not.\n     */\n    QueryStatistics.prototype.containsSystemUpdates = function () {\n        return this._containsSystemUpdates !== undefined\n            ? this._containsSystemUpdates\n            : this._systemUpdates > 0;\n    };\n    /**\n     * @returns {number} - Number of system updates\n     */\n    QueryStatistics.prototype.systemUpdates = function () {\n        return this._systemUpdates;\n    };\n    return QueryStatistics;\n}());\nexports.QueryStatistics = QueryStatistics;\n/**\n * Class for exposing server info from a result.\n * @access public\n */\nvar ServerInfo = /** @class */ (function () {\n    /**\n     * Create a ServerInfo instance\n     * @constructor\n     * @param {Object} serverMeta - Object with serverMeta data\n     * @param {Object} connectionInfo - Bolt connection info\n     * @param {number} protocolVersion - Bolt Protocol Version\n     */\n    function ServerInfo(serverMeta, protocolVersion) {\n        if (serverMeta != null) {\n            /**\n             * The server adress\n             * @type {string}\n             * @public\n             */\n            this.address = serverMeta.address;\n            /**\n             * The server user agent string\n             * @type {string}\n             * @public\n             */\n            this.agent = serverMeta.version;\n        }\n        /**\n         * The protocol version used by the connection\n         * @type {number}\n         * @public\n         */\n        this.protocolVersion = protocolVersion;\n    }\n    return ServerInfo;\n}());\nexports.ServerInfo = ServerInfo;\nfunction valueOrDefault(key, values, defaultValue) {\n    if (defaultValue === void 0) { defaultValue = 0; }\n    if (values !== false && key in values) {\n        var value = values[key];\n        return internal_1.util.toNumber(value);\n    }\n    else {\n        return defaultValue;\n    }\n}\n/**\n * The constants for query types\n * @type {{SCHEMA_WRITE: string, WRITE_ONLY: string, READ_ONLY: string, READ_WRITE: string}}\n */\nvar queryType = {\n    READ_ONLY: 'r',\n    READ_WRITE: 'rw',\n    WRITE_ONLY: 'w',\n    SCHEMA_WRITE: 's'\n};\nexports.queryType = queryType;\nexports[\"default\"] = ResultSummary;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3Jlc3VsdC1zdW1tYXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLFlBQVksR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUI7QUFDdEgsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzdDO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9ELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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c0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9yZXN1bHQtc3VtbWFyeS5qcz9lODA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdHMgPSBleHBvcnRzLlF1ZXJ5U3RhdGlzdGljcyA9IGV4cG9ydHMuUHJvZmlsZWRQbGFuID0gZXhwb3J0cy5QbGFuID0gZXhwb3J0cy5TZXJ2ZXJJbmZvID0gZXhwb3J0cy5xdWVyeVR5cGUgPSB2b2lkIDA7XG52YXIgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xudmFyIG5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZShcIi4vbm90aWZpY2F0aW9uXCIpO1xuLyoqXG4gKiBBIFJlc3VsdFN1bW1hcnkgaW5zdGFuY2UgY29udGFpbnMgc3RydWN0dXJlZCBtZXRhZGF0YSBmb3IgYSB7QGxpbmsgUmVzdWx0fS5cbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cbnZhciBSZXN1bHRTdW1tYXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSAtIFRoZSBxdWVyeSB0aGlzIHN1bW1hcnkgaXMgZm9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgcXVlcnlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGEgLSBRdWVyeSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcHJvdG9jb2xWZXJzaW9uIC0gQm9sdCBQcm90b2NvbCBWZXJzaW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVzdWx0U3VtbWFyeShxdWVyeSwgcGFyYW1ldGVycywgbWV0YWRhdGEsIHByb3RvY29sVmVyc2lvbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBxdWVyeSBhbmQgcGFyYW1ldGVycyB0aGlzIHN1bW1hcnkgaXMgZm9yLlxuICAgICAgICAgKiBAdHlwZSB7e3RleHQ6IHN0cmluZywgcGFyYW1ldGVyczogT2JqZWN0fX1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeSA9IHsgdGV4dDogcXVlcnksIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHF1ZXJ5IGV4ZWN1dGVkLiBDYW4gYmUgXCJyXCIgZm9yIHJlYWQtb25seSBxdWVyeSwgXCJyd1wiIGZvciByZWFkLXdyaXRlIHF1ZXJ5LFxuICAgICAgICAgKiBcIndcIiBmb3Igd3JpdGUtb25seSBxdWVyeSBhbmQgXCJzXCIgZm9yIHNjaGVtYS13cml0ZSBxdWVyeS5cbiAgICAgICAgICogU3RyaW5nIGNvbnN0YW50cyBhcmUgYXZhaWxhYmxlIGluIHtAbGluayBxdWVyeVR5cGV9IG9iamVjdC5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSBtZXRhZGF0YS50eXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnRlcnMgZm9yIG9wZXJhdGlvbnMgdGhlIHF1ZXJ5IHRyaWdnZXJlZC5cbiAgICAgICAgICogQHR5cGUge1F1ZXJ5U3RhdGlzdGljc31cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb3VudGVycyA9IG5ldyBRdWVyeVN0YXRpc3RpY3MoKF9hID0gbWV0YWRhdGEuc3RhdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9KTtcbiAgICAgICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCByZW1vdmUgaW4gZnV0dXJlIHZlcnNpb25cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB7QGxpbmsgUmVzdWx0U3VtbWFyeS5jb3VudGVyc30gaW5zdGVhZC5cbiAgICAgICAgICogQHR5cGUge1F1ZXJ5U3RhdGlzdGljc31cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGlzdGljcyA9IHRoaXMuY291bnRlcnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGRlc2NyaWJlcyBob3cgdGhlIGRhdGFiYXNlIHdpbGwgZXhlY3V0ZSB0aGUgcXVlcnkuXG4gICAgICAgICAqIFF1ZXJ5IHBsYW4gZm9yIHRoZSBleGVjdXRlZCBxdWVyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICAgICAqIFdpbGwgb25seSBiZSBwb3B1bGF0ZWQgZm9yIHF1ZXJpZXMgdGhhdCBzdGFydCB3aXRoIFwiRVhQTEFJTlwiLlxuICAgICAgICAgKiBAdHlwZSB7UGxhbnxmYWxzZX1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbGFuID1cbiAgICAgICAgICAgIG1ldGFkYXRhLnBsYW4gIT0gbnVsbCB8fCBtZXRhZGF0YS5wcm9maWxlICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IG5ldyBQbGFuKChfYiA9IG1ldGFkYXRhLnBsYW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG1ldGFkYXRhLnByb2ZpbGUpXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZGVzY3JpYmVzIGhvdyB0aGUgZGF0YWJhc2UgZGlkIGV4ZWN1dGUgeW91ciBxdWVyeS4gVGhpcyB3aWxsIGNvbnRhaW4gZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgd2hhdFxuICAgICAgICAgKiBlYWNoIHN0ZXAgb2YgdGhlIHBsYW4gZGlkLiBQcm9maWxlZCBxdWVyeSBwbGFuIGZvciB0aGUgZXhlY3V0ZWQgcXVlcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgICAgICAgKiBXaWxsIG9ubHkgYmUgcG9wdWxhdGVkIGZvciBxdWVyaWVzIHRoYXQgc3RhcnQgd2l0aCBcIlBST0ZJTEVcIi5cbiAgICAgICAgICogQHR5cGUge1Byb2ZpbGVkUGxhbn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9maWxlID0gbWV0YWRhdGEucHJvZmlsZSAhPSBudWxsID8gbmV3IFByb2ZpbGVkUGxhbihtZXRhZGF0YS5wcm9maWxlKSA6IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2Ygbm90aWZpY2F0aW9ucyB0aGF0IG1pZ2h0IGFyaXNlIHdoZW4gZXhlY3V0aW5nIHRoZSBxdWVyeS4gTm90aWZpY2F0aW9ucyBjYW4gYmUgd2FybmluZ3MgYWJvdXRcbiAgICAgICAgICogcHJvYmxlbWF0aWMgcXVlcmllcyBvciBvdGhlciB2YWx1YWJsZSBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBwcmVzZW50ZWQgaW4gYSBjbGllbnQuIFVubGlrZSBmYWlsdXJlc1xuICAgICAgICAgKiBvciBlcnJvcnMsIG5vdGlmaWNhdGlvbnMgZG8gbm90IGFmZmVjdCB0aGUgZXhlY3V0aW9uIG9mIGEgcXVlcnkuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxOb3RpZmljYXRpb24+fVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSAoMCwgbm90aWZpY2F0aW9uXzEuYnVpbGROb3RpZmljYXRpb25zRnJvbU1ldGFkYXRhKShtZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgR3FsU3RhdHVzT2JqZWN0cyB0aGF0IGFyaXNlIHdoZW4gZXhlY3V0aW5nIHRoZSBxdWVyeS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGxpc3QgYWx3YXlzIGNvbnRhaW5zIGF0IGxlYXN0IDEgc3RhdHVzIHJlcHJlc2VudGluZyB0aGUgU3VjY2VzcywgTm8gRGF0YSBvciBPbWl0dGVkIFJlc3VsdC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBkaXNjYXJkaW5nIHJlY29yZHMgd2hpbGUgY29ubmVjdGVkIHRvIGEgbm9uLWdxbCBhd2FyZSBzZXJ2ZXIgYW5kIHVzaW5nIGEgUnhTZXNzaW9uLFxuICAgICAgICAgKiB0aGUgZHJpdmVyIG1pZ2h0IG5vdCBiZSBhYmxlIHRvIHRlbGwgYXBhcnQgU3VjY2VzcyBhbmQgTm8gRGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQWxsIG90aGVyIHN0YXR1cyBhcmUgbm90aWZpY2F0aW9ucyBsaWtlIHdhcm5pbmdzIGFib3V0IHByb2JsZW1hdGljIHF1ZXJpZXMgb3Igb3RoZXIgdmFsdWFibGVcbiAgICAgICAgICogaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgcHJlc2VudGVkIGluIGEgY2xpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgR3FsU3RhdHVzT2JqZWN0cyB3aWxsIGJlIHByZXNlbnRlZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIEEg4oCcbm8gZGF0YeKAnSAoMDJ4eHgpIGhhcyBwcmVjZWRlbmNlIG92ZXIgYSB3YXJuaW5nO1xuICAgICAgICAgKiAtIEEgd2FybmluZyAoMDF4eHgpIGhhcyBwcmVjZWRlbmNlIG92ZXIgYSBzdWNjZXNzLlxuICAgICAgICAgKiAtIEEgc3VjY2VzcyAoMDB4eHgpIGhhcyBwcmVjZWRlbmNlIG92ZXIgYW55dGhpbmcgaW5mb3JtYXRpb25hbCAoMDN4eHgpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxHcWxTdGF0dXNPYmplY3Q+fVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3FsU3RhdHVzT2JqZWN0cyA9ICgwLCBub3RpZmljYXRpb25fMS5idWlsZEdxbFN0YXR1c09iamVjdEZyb21NZXRhZGF0YSkobWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhc2ljIGluZm9ybWF0aW9uIG9mIHRoZSBzZXJ2ZXIgd2hlcmUgdGhlIHJlc3VsdCBpcyBvYnRhaW5lZCBmcm9tLlxuICAgICAgICAgKiBAdHlwZSB7U2VydmVySW5mb31cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBuZXcgU2VydmVySW5mbyhtZXRhZGF0YS5zZXJ2ZXIsIHByb3RvY29sVmVyc2lvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBpdCB0b29rIHRoZSBzZXJ2ZXIgdG8gY29uc3VtZSB0aGUgcmVzdWx0LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3VsdENvbnN1bWVkQWZ0ZXIgPSBtZXRhZGF0YS5yZXN1bHRfY29uc3VtZWRfYWZ0ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBpdCB0b29rIHRoZSBzZXJ2ZXIgdG8gbWFrZSB0aGUgcmVzdWx0IGF2YWlsYWJsZSBmb3IgY29uc3VtcHRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3VsdEF2YWlsYWJsZUFmdGVyID0gbWV0YWRhdGEucmVzdWx0X2F2YWlsYWJsZV9hZnRlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhYmFzZSBuYW1lIHdoZXJlIHRoaXMgc3VtbWFyeSBpcyBvYnRhaW5lZCBmcm9tLlxuICAgICAgICAgKiBAdHlwZSB7e25hbWU6IHN0cmluZ319XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YWJhc2UgPSB7IG5hbWU6IChfYyA9IG1ldGFkYXRhLmRiKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSByZXN1bHQgc3VtbWFyeSBoYXMgYSBwbGFuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBSZXN1bHRTdW1tYXJ5LnByb3RvdHlwZS5oYXNQbGFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbGFuIGluc3RhbmNlb2YgUGxhbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSByZXN1bHQgc3VtbWFyeSBoYXMgYSBwcm9maWxlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBSZXN1bHRTdW1tYXJ5LnByb3RvdHlwZS5oYXNQcm9maWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9maWxlIGluc3RhbmNlb2YgUHJvZmlsZWRQbGFuO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc3VsdFN1bW1hcnk7XG59KCkpO1xuLyoqXG4gKiBDbGFzcyBmb3IgZXhlY3V0aW9uIHBsYW4gcmVjZWl2ZWQgYnkgcHJlcGVuZGluZyBDeXBoZXIgd2l0aCBFWFBMQUlOLlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xudmFyIFBsYW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgUGxhbiBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbGFuIC0gT2JqZWN0IHdpdGggcGxhbiBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGxhbihwbGFuKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3JUeXBlID0gcGxhbi5vcGVyYXRvclR5cGU7XG4gICAgICAgIHRoaXMuaWRlbnRpZmllcnMgPSBwbGFuLmlkZW50aWZpZXJzO1xuICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IHBsYW4uYXJncztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHBsYW4uY2hpbGRyZW4gIT0gbnVsbFxuICAgICAgICAgICAgPyBwbGFuLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIG5ldyBQbGFuKGNoaWxkKTsgfSlcbiAgICAgICAgICAgIDogW107XG4gICAgfVxuICAgIHJldHVybiBQbGFuO1xufSgpKTtcbmV4cG9ydHMuUGxhbiA9IFBsYW47XG4vKipcbiAqIENsYXNzIGZvciBleGVjdXRpb24gcGxhbiByZWNlaXZlZCBieSBwcmVwZW5kaW5nIEN5cGhlciB3aXRoIFBST0ZJTEUuXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG52YXIgUHJvZmlsZWRQbGFuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFByb2ZpbGVkUGxhbiBpbnN0YW5jZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlIC0gT2JqZWN0IHdpdGggcHJvZmlsZSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvZmlsZWRQbGFuKHByb2ZpbGUpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvclR5cGUgPSBwcm9maWxlLm9wZXJhdG9yVHlwZTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVycyA9IHByb2ZpbGUuaWRlbnRpZmllcnM7XG4gICAgICAgIHRoaXMuYXJndW1lbnRzID0gcHJvZmlsZS5hcmdzO1xuICAgICAgICB0aGlzLmRiSGl0cyA9IHZhbHVlT3JEZWZhdWx0KCdkYkhpdHMnLCBwcm9maWxlKTtcbiAgICAgICAgdGhpcy5yb3dzID0gdmFsdWVPckRlZmF1bHQoJ3Jvd3MnLCBwcm9maWxlKTtcbiAgICAgICAgdGhpcy5wYWdlQ2FjaGVNaXNzZXMgPSB2YWx1ZU9yRGVmYXVsdCgncGFnZUNhY2hlTWlzc2VzJywgcHJvZmlsZSk7XG4gICAgICAgIHRoaXMucGFnZUNhY2hlSGl0cyA9IHZhbHVlT3JEZWZhdWx0KCdwYWdlQ2FjaGVIaXRzJywgcHJvZmlsZSk7XG4gICAgICAgIHRoaXMucGFnZUNhY2hlSGl0UmF0aW8gPSB2YWx1ZU9yRGVmYXVsdCgncGFnZUNhY2hlSGl0UmF0aW8nLCBwcm9maWxlKTtcbiAgICAgICAgdGhpcy50aW1lID0gdmFsdWVPckRlZmF1bHQoJ3RpbWUnLCBwcm9maWxlKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHByb2ZpbGUuY2hpbGRyZW4gIT0gbnVsbFxuICAgICAgICAgICAgPyBwcm9maWxlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIG5ldyBQcm9maWxlZFBsYW4oY2hpbGQpOyB9KVxuICAgICAgICAgICAgOiBbXTtcbiAgICB9XG4gICAgUHJvZmlsZWRQbGFuLnByb3RvdHlwZS5oYXNQYWdlQ2FjaGVTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnBhZ2VDYWNoZU1pc3NlcyA+IDAgfHxcbiAgICAgICAgICAgIHRoaXMucGFnZUNhY2hlSGl0cyA+IDAgfHxcbiAgICAgICAgICAgIHRoaXMucGFnZUNhY2hlSGl0UmF0aW8gPiAwKTtcbiAgICB9O1xuICAgIHJldHVybiBQcm9maWxlZFBsYW47XG59KCkpO1xuZXhwb3J0cy5Qcm9maWxlZFBsYW4gPSBQcm9maWxlZFBsYW47XG4vKipcbiAqIFN0YXRzIFF1ZXJ5IHN0YXRpc3RpY3MgZGljdGlvbmFyeSBmb3IgYSB7QGxpbmsgUXVlcnlTdGF0aXN0aWNzfVxuICogQHB1YmxpY1xuICovXG52YXIgU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0cygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5vZGVzIGNyZWF0ZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2Rlc0NyZWF0ZWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogbm9kZXMgZGVsZXRlZFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVzRGVsZXRlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZWxhdGlvbnNoaXBzIGNyZWF0ZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWxhdGlvbnNoaXBzQ3JlYXRlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZWxhdGlvbnNoaXBzIGRlbGV0ZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWxhdGlvbnNoaXBzRGVsZXRlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9wZXJ0aWVzIHNldFxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNTZXQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogbGFiZWxzIGFkZGVkXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxzQWRkZWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogbGFiZWxzIHJlbW92ZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYWJlbHNSZW1vdmVkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluZGV4ZXMgYWRkZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleGVzQWRkZWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogaW5kZXhlcyByZW1vdmVkXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXhlc1JlbW92ZWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogY29uc3RyYWludHMgYWRkZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25zdHJhaW50c0FkZGVkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbnN0cmFpbnRzIHJlbW92ZWRcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25zdHJhaW50c1JlbW92ZWQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gU3RhdHM7XG59KCkpO1xuZXhwb3J0cy5TdGF0cyA9IFN0YXRzO1xuLyoqXG4gKiBHZXQgc3RhdGlzdGljYWwgaW5mb3JtYXRpb24gZm9yIGEge0BsaW5rIFJlc3VsdH0uXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG52YXIgUXVlcnlTdGF0aXN0aWNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIFN0cnVjdHVyaXplIHRoZSBzdGF0aXN0aWNzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRpc3RpY3MgLSBSZXN1bHQgc3RhdGlzdGljc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFF1ZXJ5U3RhdGlzdGljcyhzdGF0aXN0aWNzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3N0YXRzID0ge1xuICAgICAgICAgICAgbm9kZXNDcmVhdGVkOiAwLFxuICAgICAgICAgICAgbm9kZXNEZWxldGVkOiAwLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwc0NyZWF0ZWQ6IDAsXG4gICAgICAgICAgICByZWxhdGlvbnNoaXBzRGVsZXRlZDogMCxcbiAgICAgICAgICAgIHByb3BlcnRpZXNTZXQ6IDAsXG4gICAgICAgICAgICBsYWJlbHNBZGRlZDogMCxcbiAgICAgICAgICAgIGxhYmVsc1JlbW92ZWQ6IDAsXG4gICAgICAgICAgICBpbmRleGVzQWRkZWQ6IDAsXG4gICAgICAgICAgICBpbmRleGVzUmVtb3ZlZDogMCxcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzQWRkZWQ6IDAsXG4gICAgICAgICAgICBjb25zdHJhaW50c1JlbW92ZWQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3lzdGVtVXBkYXRlcyA9IDA7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0YXRpc3RpY3MpLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAvLyBUbyBjYW1lbENhc2VcbiAgICAgICAgICAgIHZhciBjYW1lbENhc2VJbmRleCA9IGluZGV4LnJlcGxhY2UoLygtXFx3KS9nLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbVsxXS50b1VwcGVyQ2FzZSgpOyB9KTtcbiAgICAgICAgICAgIGlmIChjYW1lbENhc2VJbmRleCBpbiBfdGhpcy5fc3RhdHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RhdHNbY2FtZWxDYXNlSW5kZXhdID0gaW50ZXJuYWxfMS51dGlsLnRvTnVtYmVyKHN0YXRpc3RpY3NbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhbWVsQ2FzZUluZGV4ID09PSAnc3lzdGVtVXBkYXRlcycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3lzdGVtVXBkYXRlcyA9IGludGVybmFsXzEudXRpbC50b051bWJlcihzdGF0aXN0aWNzW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYW1lbENhc2VJbmRleCA9PT0gJ2NvbnRhaW5zU3lzdGVtVXBkYXRlcycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29udGFpbnNTeXN0ZW1VcGRhdGVzID0gc3RhdGlzdGljc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYW1lbENhc2VJbmRleCA9PT0gJ2NvbnRhaW5zVXBkYXRlcycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29udGFpbnNVcGRhdGVzID0gc3RhdGlzdGljc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdGF0cyA9IE9iamVjdC5mcmVlemUodGhpcy5fc3RhdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaWQgdGhlIGRhdGFiYXNlIGdldCB1cGRhdGVkP1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnlTdGF0aXN0aWNzLnByb3RvdHlwZS5jb250YWluc1VwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluc1VwZGF0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB0aGlzLl9jb250YWluc1VwZGF0ZXNcbiAgICAgICAgICAgIDogKE9iamVjdC5rZXlzKHRoaXMuX3N0YXRzKS5yZWR1Y2UoZnVuY3Rpb24gKGxhc3QsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdCArIF90aGlzLl9zdGF0c1tjdXJyZW50XTtcbiAgICAgICAgICAgIH0sIDApID4gMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBxdWVyeSBzdGF0aXN0aWNzIHVwZGF0ZXMgaW4gYSBkaWN0aW9uYXJ5LlxuICAgICAqIEByZXR1cm5zIHtTdGF0c31cbiAgICAgKi9cbiAgICBRdWVyeVN0YXRpc3RpY3MucHJvdG90eXBlLnVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBzeXN0ZW0gZGF0YWJhc2UgZ2V0IHVwZGF0ZWQsIG90aGVyd2lzZSBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIElmIHRoZSBzeXN0ZW0gZGF0YWJhc2UgZ2V0IHVwZGF0ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIFF1ZXJ5U3RhdGlzdGljcy5wcm90b3R5cGUuY29udGFpbnNTeXN0ZW1VcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbnNTeXN0ZW1VcGRhdGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdGhpcy5fY29udGFpbnNTeXN0ZW1VcGRhdGVzXG4gICAgICAgICAgICA6IHRoaXMuX3N5c3RlbVVwZGF0ZXMgPiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn0gLSBOdW1iZXIgb2Ygc3lzdGVtIHVwZGF0ZXNcbiAgICAgKi9cbiAgICBRdWVyeVN0YXRpc3RpY3MucHJvdG90eXBlLnN5c3RlbVVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zeXN0ZW1VcGRhdGVzO1xuICAgIH07XG4gICAgcmV0dXJuIFF1ZXJ5U3RhdGlzdGljcztcbn0oKSk7XG5leHBvcnRzLlF1ZXJ5U3RhdGlzdGljcyA9IFF1ZXJ5U3RhdGlzdGljcztcbi8qKlxuICogQ2xhc3MgZm9yIGV4cG9zaW5nIHNlcnZlciBpbmZvIGZyb20gYSByZXN1bHQuXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG52YXIgU2VydmVySW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBTZXJ2ZXJJbmZvIGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlcnZlck1ldGEgLSBPYmplY3Qgd2l0aCBzZXJ2ZXJNZXRhIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkluZm8gLSBCb2x0IGNvbm5lY3Rpb24gaW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcm90b2NvbFZlcnNpb24gLSBCb2x0IFByb3RvY29sIFZlcnNpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXJ2ZXJJbmZvKHNlcnZlck1ldGEsIHByb3RvY29sVmVyc2lvbikge1xuICAgICAgICBpZiAoc2VydmVyTWV0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBzZXJ2ZXIgYWRyZXNzXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmFkZHJlc3MgPSBzZXJ2ZXJNZXRhLmFkZHJlc3M7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBzZXJ2ZXIgdXNlciBhZ2VudCBzdHJpbmdcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAgICAgKiBAcHVibGljXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuYWdlbnQgPSBzZXJ2ZXJNZXRhLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm90b2NvbCB2ZXJzaW9uIHVzZWQgYnkgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm90b2NvbFZlcnNpb24gPSBwcm90b2NvbFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiBTZXJ2ZXJJbmZvO1xufSgpKTtcbmV4cG9ydHMuU2VydmVySW5mbyA9IFNlcnZlckluZm87XG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdChrZXksIHZhbHVlcywgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRWYWx1ZSA9IDA7IH1cbiAgICBpZiAodmFsdWVzICE9PSBmYWxzZSAmJiBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxfMS51dGlsLnRvTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgY29uc3RhbnRzIGZvciBxdWVyeSB0eXBlc1xuICogQHR5cGUge3tTQ0hFTUFfV1JJVEU6IHN0cmluZywgV1JJVEVfT05MWTogc3RyaW5nLCBSRUFEX09OTFk6IHN0cmluZywgUkVBRF9XUklURTogc3RyaW5nfX1cbiAqL1xudmFyIHF1ZXJ5VHlwZSA9IHtcbiAgICBSRUFEX09OTFk6ICdyJyxcbiAgICBSRUFEX1dSSVRFOiAncncnLFxuICAgIFdSSVRFX09OTFk6ICd3JyxcbiAgICBTQ0hFTUFfV1JJVEU6ICdzJ1xufTtcbmV4cG9ydHMucXVlcnlUeXBlID0gcXVlcnlUeXBlO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVzdWx0U3VtbWFyeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/result-summary.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/result-transformers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/result-transformers.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar result_eager_1 = __importDefault(__webpack_require__(/*! ./result-eager */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result-eager.js\"));\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\n/**\n * Protocol for transforming {@link Result}.\n *\n * @typedef {function<T>(result:Result):Promise<T>} ResultTransformer\n * @interface\n *\n * @see {@link resultTransformers} for provided implementations.\n * @see {@link Driver#executeQuery} for usage.\n */\n/**\n * Defines the object which holds the common {@link ResultTransformer} used with {@link Driver#executeQuery}.\n */\nvar ResultTransformers = /** @class */ (function () {\n    function ResultTransformers() {\n    }\n    /**\n     * Creates a {@link ResultTransformer} which transforms {@link Result} to {@link EagerResult}\n     * by consuming the whole stream.\n     *\n     * This is the default implementation used in {@link Driver#executeQuery}\n     *\n     * @example\n     * // This:\n     * const { keys, records, summary } = await driver.executeQuery('CREATE (p:Person{ name: $name }) RETURN p', { name: 'Person1'}, {\n     *   resultTransformer: neo4j.resultTransformers.eagerResultTransformer()\n     * })\n     * // is equivalent to:\n     * const { keys, records, summary } = await driver.executeQuery('CREATE (p:Person{ name: $name }) RETURN p', { name: 'Person1'})\n     *\n     * @returns {ResultTransformer<EagerResult<Entries>>} The result transformer\n     * @alias {@link ResultTransformers#eager}\n     */\n    ResultTransformers.prototype.eagerResultTransformer = function () {\n        return createEagerResultFromResult;\n    };\n    /**\n     * Creates a {@link ResultTransformer} which transforms {@link Result} to {@link EagerResult}\n     * by consuming the whole stream.\n     *\n     * This is the default implementation used in {@link Driver#executeQuery} and a alias to\n     * {@link resultTransformers.eagerResultTransformer}\n     *\n     * @example\n     * // This:\n     * const { keys, records, summary } = await driver.executeQuery('CREATE (p:Person{ name: $name }) RETURN p', { name: 'Person1'}, {\n     *   resultTransformer: neo4j.resultTransformers.eager()\n     * })\n     * // is equivalent to:\n     * const { keys, records, summary } = await driver.executeQuery('CREATE (p:Person{ name: $name }) RETURN p', { name: 'Person1'})\n     *\n     * @returns {ResultTransformer<EagerResult<Entries>>} The result transformer\n     * @experimental this is a preview\n     * @since 5.22.0\n     * @alias {@link ResultTransformers#eagerResultTransformer}\n     */\n    ResultTransformers.prototype.eager = function () {\n        return createEagerResultFromResult;\n    };\n    /**\n     * Creates a {@link ResultTransformer} which maps the {@link Record} in the result and collects it\n     * along with the {@link ResultSummary} and {@link Result#keys}.\n     *\n     * NOTE: The config object requires map or/and collect to be valid.\n     *\n     * @example\n     * // Mapping the records\n     * const { keys, records, summary } = await driver.executeQuery('MATCH (p:Person{ age: $age }) RETURN p.name as name', { age: 25 }, {\n     *   resultTransformer: neo4j.resultTransformers.mappedResultTransformer({\n     *     map(record) {\n     *        return record.get('name')\n     *     }\n     *   })\n     * })\n     *\n     * records.forEach(name => console.log(`${name} has 25`))\n     *\n     * @example\n     * // Mapping records and collect result\n     * const names = await driver.executeQuery('MATCH (p:Person{ age: $age }) RETURN p.name as name', { age: 25 }, {\n     *   resultTransformer: neo4j.resultTransformers.mappedResultTransformer({\n     *     map(record) {\n     *        return record.get('name')\n     *     },\n     *     collect(records, summary, keys) {\n     *        return records\n     *     }\n     *   })\n     * })\n     *\n     * names.forEach(name => console.log(`${name} has 25`))\n     *\n     * @example\n     * // The transformer can be defined one and used everywhere\n     * const getRecordsAsObjects = neo4j.resultTransformers.mappedResultTransformer({\n     *   map(record) {\n     *      return record.toObject()\n     *   },\n     *   collect(objects) {\n     *      return objects\n     *   }\n     * })\n     *\n     * // The usage in a driver.executeQuery\n     * const objects = await driver.executeQuery('MATCH (p:Person{ age: $age }) RETURN p.name as name', { age: 25 }, {\n     *   resultTransformer: getRecordsAsObjects\n     * })\n     * objects.forEach(object => console.log(`${object.name} has 25`))\n     *\n     *\n     * // The usage in session.executeRead\n     * const objects = await session.executeRead(tx => getRecordsAsObjects(tx.run('MATCH (p:Person{ age: $age }) RETURN p.name as name')))\n     * objects.forEach(object => console.log(`${object.name} has 25`))\n     *\n     * @param {object} config The result transformer configuration\n     * @param {function(record:Record):R} [config.map=function(record) {  return record }] Method called for mapping each record\n     * @param {function(records:R[], summary:ResultSummary, keys:string[]):T} [config.collect=function(records, summary, keys) { return { records, summary, keys }}] Method called for mapping\n     * the result data to the transformer output.\n     * @returns {ResultTransformer<T>} The result transformer\n     * @see {@link Driver#executeQuery}\n     */\n    ResultTransformers.prototype.mappedResultTransformer = function (config) {\n        return createMappedResultTransformer(config);\n    };\n    /**\n     * Creates a {@link ResultTransformer} which maps the {@link Record} in the result and collects it\n     * along with the {@link ResultSummary} and {@link Result#keys}.\n     *\n     * NOTE: The config object requires map or/and collect to be valid.\n     *\n     * This method is a alias to {@link ResultTransformers#mappedResultTransformer}\n     *\n     *\n     * @example\n     * // Mapping the records\n     * const { keys, records, summary } = await driver.executeQuery('MATCH (p:Person{ age: $age }) RETURN p.name as name', { age: 25 }, {\n     *   resultTransformer: neo4j.resultTransformers.mapped({\n     *     map(record) {\n     *        return record.get('name')\n     *     }\n     *   })\n     * })\n     *\n     * records.forEach(name => console.log(`${name} has 25`))\n     *\n     * @example\n     * // Mapping records and collect result\n     * const names = await driver.executeQuery('MATCH (p:Person{ age: $age }) RETURN p.name as name', { age: 25 }, {\n     *   resultTransformer: neo4j.resultTransformers.mapped({\n     *     map(record) {\n     *        return record.get('name')\n     *     },\n     *     collect(records, summary, keys) {\n     *        return records\n     *     }\n     *   })\n     * })\n     *\n     * names.forEach(name => console.log(`${name} has 25`))\n     *\n     * @example\n     * // The transformer can be defined one and used everywhere\n     * const getRecordsAsObjects = neo4j.resultTransformers.mapped({\n     *   map(record) {\n     *      return record.toObject()\n     *   },\n     *   collect(objects) {\n     *      return objects\n     *   }\n     * })\n     *\n     * // The usage in a driver.executeQuery\n     * const objects = await driver.executeQuery('MATCH (p:Person{ age: $age }) RETURN p.name as name', { age: 25 }, {\n     *   resultTransformer: getRecordsAsObjects\n     * })\n     * objects.forEach(object => console.log(`${object.name} has 25`))\n     *\n     *\n     * // The usage in session.executeRead\n     * const objects = await session.executeRead(tx => getRecordsAsObjects(tx.run('MATCH (p:Person{ age: $age }) RETURN p.name as name')))\n     * objects.forEach(object => console.log(`${object.name} has 25`))\n     *\n     * @param {object} config The result transformer configuration\n     * @param {function(record:Record):R} [config.map=function(record) {  return record }] Method called for mapping each record\n     * @param {function(records:R[], summary:ResultSummary, keys:string[]):T} [config.collect=function(records, summary, keys) { return { records, summary, keys }}] Method called for mapping\n     * the result data to the transformer output.\n     * @returns {ResultTransformer<T>} The result transformer\n     * @experimental This is a preview feature\n     * @alias {@link ResultTransformers#mappedResultTransformer}\n     * @since 5.22.0\n     * @see {@link Driver#executeQuery}\n     */\n    ResultTransformers.prototype.mapped = function (config) {\n        return createMappedResultTransformer(config);\n    };\n    /**\n     * Creates a {@link ResultTransformer} which collects the first record {@link Record} of {@link Result}\n     * and discard the rest of the records, if existent.\n     *\n     * @example\n     * // Using in executeQuery\n     * const maybeFirstRecord = await driver.executeQuery('MATCH (p:Person{ age: $age }) RETURN p.name as name', { age: 25 }, {\n     *   resultTransformer: neo4j.resultTransformers.first()\n     * })\n     *\n     * @example\n     * // Using in other results\n     * const record = await neo4j.resultTransformers.first()(result)\n     *\n     *\n     * @template Entries The shape of the record.\n     * @returns {ResultTransformer<Record<Entries>|undefined>} The result transformer\n     * @see {@link Driver#executeQuery}\n     * @experimental This is a preview feature.\n     * @since 5.22.0\n     */\n    ResultTransformers.prototype.first = function () {\n        return first;\n    };\n    /**\n     * Creates a {@link ResultTransformer} which consumes the result and returns the {@link ResultSummary}.\n     *\n     * This result transformer is a shortcut to `(result) => result.summary()`.\n     *\n     * @example\n     * const summary = await driver.executeQuery('CREATE (p:Person{ name: $name }) RETURN p', { name: 'Person1'}, {\n     *   resultTransformer: neo4j.resultTransformers.summary()\n     * })\n     *\n     * @returns {ResultTransformer<ResultSummary<T>>} The result transformer\n     * @see {@link Driver#executeQuery}\n     * @experimental This is a preview feature\n     */\n    ResultTransformers.prototype.summary = function () {\n        return summary;\n    };\n    return ResultTransformers;\n}());\n/**\n * Holds the common {@link ResultTransformer} used with {@link Driver#executeQuery}.\n */\nvar resultTransformers = new ResultTransformers();\nObject.freeze(resultTransformers);\nexports[\"default\"] = resultTransformers;\nfunction createEagerResultFromResult(result) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, summary, records, keys;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, result];\n                case 1:\n                    _a = _b.sent(), summary = _a.summary, records = _a.records;\n                    return [4 /*yield*/, result.keys()];\n                case 2:\n                    keys = _b.sent();\n                    return [2 /*return*/, new result_eager_1.default(keys, records, summary)];\n            }\n        });\n    });\n}\nfunction createMappedResultTransformer(config) {\n    var _this = this;\n    if (config == null || (config.collect == null && config.map == null)) {\n        throw (0, error_1.newError)('Requires a map or/and a collect functions.');\n    }\n    return function (result) { return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {\n                        var state = { records: [], keys: [] };\n                        result.subscribe({\n                            onKeys: function (keys) {\n                                state.keys = keys;\n                            },\n                            onNext: function (record) {\n                                if (config.map != null) {\n                                    var mappedRecord = config.map(record);\n                                    if (mappedRecord !== undefined) {\n                                        state.records.push(mappedRecord);\n                                    }\n                                }\n                                else {\n                                    state.records.push(record);\n                                }\n                            },\n                            onCompleted: function (summary) {\n                                if (config.collect != null) {\n                                    resolve(config.collect(state.records, summary, state.keys));\n                                }\n                                else {\n                                    var obj = { records: state.records, summary: summary, keys: state.keys };\n                                    resolve(obj);\n                                }\n                            },\n                            onError: function (error) {\n                                reject(error);\n                            }\n                        });\n                    })];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    }); };\n}\nfunction first(result) {\n    return __awaiter(this, void 0, void 0, function () {\n        var it, _a, value, done;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    it = result[Symbol.asyncIterator]();\n                    return [4 /*yield*/, it.next()];\n                case 1:\n                    _a = _b.sent(), value = _a.value, done = _a.done;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, , 3, 6]);\n                    if (done === true) {\n                        return [2 /*return*/, undefined];\n                    }\n                    return [2 /*return*/, value];\n                case 3:\n                    if (!(it.return != null)) return [3 /*break*/, 5];\n                    return [4 /*yield*/, it.return()];\n                case 4:\n                    _b.sent();\n                    _b.label = 5;\n                case 5: return [7 /*endfinally*/];\n                case 6: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction summary(result) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, result.summary()];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3Jlc3VsdC10cmFuc2Zvcm1lcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQ0FBcUMsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLG9FQUFTO0FBQy9CO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0EsU0FBUywwQkFBMEI7QUFDbkMsU0FBUywyQkFBMkI7QUFDcEM7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QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3Jlc3VsdC10cmFuc2Zvcm1lcnMuanM/ZDg3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVzdWx0X2VhZ2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVzdWx0LWVhZ2VyXCIpKTtcbnZhciBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG4vKipcbiAqIFByb3RvY29sIGZvciB0cmFuc2Zvcm1pbmcge0BsaW5rIFJlc3VsdH0uXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uPFQ+KHJlc3VsdDpSZXN1bHQpOlByb21pc2U8VD59IFJlc3VsdFRyYW5zZm9ybWVyXG4gKiBAaW50ZXJmYWNlXG4gKlxuICogQHNlZSB7QGxpbmsgcmVzdWx0VHJhbnNmb3JtZXJzfSBmb3IgcHJvdmlkZWQgaW1wbGVtZW50YXRpb25zLlxuICogQHNlZSB7QGxpbmsgRHJpdmVyI2V4ZWN1dGVRdWVyeX0gZm9yIHVzYWdlLlxuICovXG4vKipcbiAqIERlZmluZXMgdGhlIG9iamVjdCB3aGljaCBob2xkcyB0aGUgY29tbW9uIHtAbGluayBSZXN1bHRUcmFuc2Zvcm1lcn0gdXNlZCB3aXRoIHtAbGluayBEcml2ZXIjZXhlY3V0ZVF1ZXJ5fS5cbiAqL1xudmFyIFJlc3VsdFRyYW5zZm9ybWVycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXN1bHRUcmFuc2Zvcm1lcnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgUmVzdWx0VHJhbnNmb3JtZXJ9IHdoaWNoIHRyYW5zZm9ybXMge0BsaW5rIFJlc3VsdH0gdG8ge0BsaW5rIEVhZ2VyUmVzdWx0fVxuICAgICAqIGJ5IGNvbnN1bWluZyB0aGUgd2hvbGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHtAbGluayBEcml2ZXIjZXhlY3V0ZVF1ZXJ5fVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBUaGlzOlxuICAgICAqIGNvbnN0IHsga2V5cywgcmVjb3Jkcywgc3VtbWFyeSB9ID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVRdWVyeSgnQ1JFQVRFIChwOlBlcnNvbnsgbmFtZTogJG5hbWUgfSkgUkVUVVJOIHAnLCB7IG5hbWU6ICdQZXJzb24xJ30sIHtcbiAgICAgKiAgIHJlc3VsdFRyYW5zZm9ybWVyOiBuZW80ai5yZXN1bHRUcmFuc2Zvcm1lcnMuZWFnZXJSZXN1bHRUcmFuc2Zvcm1lcigpXG4gICAgICogfSlcbiAgICAgKiAvLyBpcyBlcXVpdmFsZW50IHRvOlxuICAgICAqIGNvbnN0IHsga2V5cywgcmVjb3Jkcywgc3VtbWFyeSB9ID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVRdWVyeSgnQ1JFQVRFIChwOlBlcnNvbnsgbmFtZTogJG5hbWUgfSkgUkVUVVJOIHAnLCB7IG5hbWU6ICdQZXJzb24xJ30pXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0VHJhbnNmb3JtZXI8RWFnZXJSZXN1bHQ8RW50cmllcz4+fSBUaGUgcmVzdWx0IHRyYW5zZm9ybWVyXG4gICAgICogQGFsaWFzIHtAbGluayBSZXN1bHRUcmFuc2Zvcm1lcnMjZWFnZXJ9XG4gICAgICovXG4gICAgUmVzdWx0VHJhbnNmb3JtZXJzLnByb3RvdHlwZS5lYWdlclJlc3VsdFRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWFnZXJSZXN1bHRGcm9tUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBSZXN1bHRUcmFuc2Zvcm1lcn0gd2hpY2ggdHJhbnNmb3JtcyB7QGxpbmsgUmVzdWx0fSB0byB7QGxpbmsgRWFnZXJSZXN1bHR9XG4gICAgICogYnkgY29uc3VtaW5nIHRoZSB3aG9sZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHVzZWQgaW4ge0BsaW5rIERyaXZlciNleGVjdXRlUXVlcnl9IGFuZCBhIGFsaWFzIHRvXG4gICAgICoge0BsaW5rIHJlc3VsdFRyYW5zZm9ybWVycy5lYWdlclJlc3VsdFRyYW5zZm9ybWVyfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBUaGlzOlxuICAgICAqIGNvbnN0IHsga2V5cywgcmVjb3Jkcywgc3VtbWFyeSB9ID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVRdWVyeSgnQ1JFQVRFIChwOlBlcnNvbnsgbmFtZTogJG5hbWUgfSkgUkVUVVJOIHAnLCB7IG5hbWU6ICdQZXJzb24xJ30sIHtcbiAgICAgKiAgIHJlc3VsdFRyYW5zZm9ybWVyOiBuZW80ai5yZXN1bHRUcmFuc2Zvcm1lcnMuZWFnZXIoKVxuICAgICAqIH0pXG4gICAgICogLy8gaXMgZXF1aXZhbGVudCB0bzpcbiAgICAgKiBjb25zdCB7IGtleXMsIHJlY29yZHMsIHN1bW1hcnkgfSA9IGF3YWl0IGRyaXZlci5leGVjdXRlUXVlcnkoJ0NSRUFURSAocDpQZXJzb257IG5hbWU6ICRuYW1lIH0pIFJFVFVSTiBwJywgeyBuYW1lOiAnUGVyc29uMSd9KVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Jlc3VsdFRyYW5zZm9ybWVyPEVhZ2VyUmVzdWx0PEVudHJpZXM+Pn0gVGhlIHJlc3VsdCB0cmFuc2Zvcm1lclxuICAgICAqIEBleHBlcmltZW50YWwgdGhpcyBpcyBhIHByZXZpZXdcbiAgICAgKiBAc2luY2UgNS4yMi4wXG4gICAgICogQGFsaWFzIHtAbGluayBSZXN1bHRUcmFuc2Zvcm1lcnMjZWFnZXJSZXN1bHRUcmFuc2Zvcm1lcn1cbiAgICAgKi9cbiAgICBSZXN1bHRUcmFuc2Zvcm1lcnMucHJvdG90eXBlLmVhZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWFnZXJSZXN1bHRGcm9tUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBSZXN1bHRUcmFuc2Zvcm1lcn0gd2hpY2ggbWFwcyB0aGUge0BsaW5rIFJlY29yZH0gaW4gdGhlIHJlc3VsdCBhbmQgY29sbGVjdHMgaXRcbiAgICAgKiBhbG9uZyB3aXRoIHRoZSB7QGxpbmsgUmVzdWx0U3VtbWFyeX0gYW5kIHtAbGluayBSZXN1bHQja2V5c30uXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGUgY29uZmlnIG9iamVjdCByZXF1aXJlcyBtYXAgb3IvYW5kIGNvbGxlY3QgdG8gYmUgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIE1hcHBpbmcgdGhlIHJlY29yZHNcbiAgICAgKiBjb25zdCB7IGtleXMsIHJlY29yZHMsIHN1bW1hcnkgfSA9IGF3YWl0IGRyaXZlci5leGVjdXRlUXVlcnkoJ01BVENIIChwOlBlcnNvbnsgYWdlOiAkYWdlIH0pIFJFVFVSTiBwLm5hbWUgYXMgbmFtZScsIHsgYWdlOiAyNSB9LCB7XG4gICAgICogICByZXN1bHRUcmFuc2Zvcm1lcjogbmVvNGoucmVzdWx0VHJhbnNmb3JtZXJzLm1hcHBlZFJlc3VsdFRyYW5zZm9ybWVyKHtcbiAgICAgKiAgICAgbWFwKHJlY29yZCkge1xuICAgICAqICAgICAgICByZXR1cm4gcmVjb3JkLmdldCgnbmFtZScpXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIHJlY29yZHMuZm9yRWFjaChuYW1lID0+IGNvbnNvbGUubG9nKGAke25hbWV9IGhhcyAyNWApKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBNYXBwaW5nIHJlY29yZHMgYW5kIGNvbGxlY3QgcmVzdWx0XG4gICAgICogY29uc3QgbmFtZXMgPSBhd2FpdCBkcml2ZXIuZXhlY3V0ZVF1ZXJ5KCdNQVRDSCAocDpQZXJzb257IGFnZTogJGFnZSB9KSBSRVRVUk4gcC5uYW1lIGFzIG5hbWUnLCB7IGFnZTogMjUgfSwge1xuICAgICAqICAgcmVzdWx0VHJhbnNmb3JtZXI6IG5lbzRqLnJlc3VsdFRyYW5zZm9ybWVycy5tYXBwZWRSZXN1bHRUcmFuc2Zvcm1lcih7XG4gICAgICogICAgIG1hcChyZWNvcmQpIHtcbiAgICAgKiAgICAgICAgcmV0dXJuIHJlY29yZC5nZXQoJ25hbWUnKVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBjb2xsZWN0KHJlY29yZHMsIHN1bW1hcnksIGtleXMpIHtcbiAgICAgKiAgICAgICAgcmV0dXJuIHJlY29yZHNcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSlcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogbmFtZXMuZm9yRWFjaChuYW1lID0+IGNvbnNvbGUubG9nKGAke25hbWV9IGhhcyAyNWApKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBUaGUgdHJhbnNmb3JtZXIgY2FuIGJlIGRlZmluZWQgb25lIGFuZCB1c2VkIGV2ZXJ5d2hlcmVcbiAgICAgKiBjb25zdCBnZXRSZWNvcmRzQXNPYmplY3RzID0gbmVvNGoucmVzdWx0VHJhbnNmb3JtZXJzLm1hcHBlZFJlc3VsdFRyYW5zZm9ybWVyKHtcbiAgICAgKiAgIG1hcChyZWNvcmQpIHtcbiAgICAgKiAgICAgIHJldHVybiByZWNvcmQudG9PYmplY3QoKVxuICAgICAqICAgfSxcbiAgICAgKiAgIGNvbGxlY3Qob2JqZWN0cykge1xuICAgICAqICAgICAgcmV0dXJuIG9iamVjdHNcbiAgICAgKiAgIH1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogLy8gVGhlIHVzYWdlIGluIGEgZHJpdmVyLmV4ZWN1dGVRdWVyeVxuICAgICAqIGNvbnN0IG9iamVjdHMgPSBhd2FpdCBkcml2ZXIuZXhlY3V0ZVF1ZXJ5KCdNQVRDSCAocDpQZXJzb257IGFnZTogJGFnZSB9KSBSRVRVUk4gcC5uYW1lIGFzIG5hbWUnLCB7IGFnZTogMjUgfSwge1xuICAgICAqICAgcmVzdWx0VHJhbnNmb3JtZXI6IGdldFJlY29yZHNBc09iamVjdHNcbiAgICAgKiB9KVxuICAgICAqIG9iamVjdHMuZm9yRWFjaChvYmplY3QgPT4gY29uc29sZS5sb2coYCR7b2JqZWN0Lm5hbWV9IGhhcyAyNWApKVxuICAgICAqXG4gICAgICpcbiAgICAgKiAvLyBUaGUgdXNhZ2UgaW4gc2Vzc2lvbi5leGVjdXRlUmVhZFxuICAgICAqIGNvbnN0IG9iamVjdHMgPSBhd2FpdCBzZXNzaW9uLmV4ZWN1dGVSZWFkKHR4ID0+IGdldFJlY29yZHNBc09iamVjdHModHgucnVuKCdNQVRDSCAocDpQZXJzb257IGFnZTogJGFnZSB9KSBSRVRVUk4gcC5uYW1lIGFzIG5hbWUnKSkpXG4gICAgICogb2JqZWN0cy5mb3JFYWNoKG9iamVjdCA9PiBjb25zb2xlLmxvZyhgJHtvYmplY3QubmFtZX0gaGFzIDI1YCkpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSByZXN1bHQgdHJhbnNmb3JtZXIgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVjb3JkOlJlY29yZCk6Un0gW2NvbmZpZy5tYXA9ZnVuY3Rpb24ocmVjb3JkKSB7ICByZXR1cm4gcmVjb3JkIH1dIE1ldGhvZCBjYWxsZWQgZm9yIG1hcHBpbmcgZWFjaCByZWNvcmRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlY29yZHM6UltdLCBzdW1tYXJ5OlJlc3VsdFN1bW1hcnksIGtleXM6c3RyaW5nW10pOlR9IFtjb25maWcuY29sbGVjdD1mdW5jdGlvbihyZWNvcmRzLCBzdW1tYXJ5LCBrZXlzKSB7IHJldHVybiB7IHJlY29yZHMsIHN1bW1hcnksIGtleXMgfX1dIE1ldGhvZCBjYWxsZWQgZm9yIG1hcHBpbmdcbiAgICAgKiB0aGUgcmVzdWx0IGRhdGEgdG8gdGhlIHRyYW5zZm9ybWVyIG91dHB1dC5cbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0VHJhbnNmb3JtZXI8VD59IFRoZSByZXN1bHQgdHJhbnNmb3JtZXJcbiAgICAgKiBAc2VlIHtAbGluayBEcml2ZXIjZXhlY3V0ZVF1ZXJ5fVxuICAgICAqL1xuICAgIFJlc3VsdFRyYW5zZm9ybWVycy5wcm90b3R5cGUubWFwcGVkUmVzdWx0VHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVNYXBwZWRSZXN1bHRUcmFuc2Zvcm1lcihjb25maWcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBSZXN1bHRUcmFuc2Zvcm1lcn0gd2hpY2ggbWFwcyB0aGUge0BsaW5rIFJlY29yZH0gaW4gdGhlIHJlc3VsdCBhbmQgY29sbGVjdHMgaXRcbiAgICAgKiBhbG9uZyB3aXRoIHRoZSB7QGxpbmsgUmVzdWx0U3VtbWFyeX0gYW5kIHtAbGluayBSZXN1bHQja2V5c30uXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGUgY29uZmlnIG9iamVjdCByZXF1aXJlcyBtYXAgb3IvYW5kIGNvbGxlY3QgdG8gYmUgdmFsaWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhIGFsaWFzIHRvIHtAbGluayBSZXN1bHRUcmFuc2Zvcm1lcnMjbWFwcGVkUmVzdWx0VHJhbnNmb3JtZXJ9XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTWFwcGluZyB0aGUgcmVjb3Jkc1xuICAgICAqIGNvbnN0IHsga2V5cywgcmVjb3Jkcywgc3VtbWFyeSB9ID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVRdWVyeSgnTUFUQ0ggKHA6UGVyc29ueyBhZ2U6ICRhZ2UgfSkgUkVUVVJOIHAubmFtZSBhcyBuYW1lJywgeyBhZ2U6IDI1IH0sIHtcbiAgICAgKiAgIHJlc3VsdFRyYW5zZm9ybWVyOiBuZW80ai5yZXN1bHRUcmFuc2Zvcm1lcnMubWFwcGVkKHtcbiAgICAgKiAgICAgbWFwKHJlY29yZCkge1xuICAgICAqICAgICAgICByZXR1cm4gcmVjb3JkLmdldCgnbmFtZScpXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIHJlY29yZHMuZm9yRWFjaChuYW1lID0+IGNvbnNvbGUubG9nKGAke25hbWV9IGhhcyAyNWApKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBNYXBwaW5nIHJlY29yZHMgYW5kIGNvbGxlY3QgcmVzdWx0XG4gICAgICogY29uc3QgbmFtZXMgPSBhd2FpdCBkcml2ZXIuZXhlY3V0ZVF1ZXJ5KCdNQVRDSCAocDpQZXJzb257IGFnZTogJGFnZSB9KSBSRVRVUk4gcC5uYW1lIGFzIG5hbWUnLCB7IGFnZTogMjUgfSwge1xuICAgICAqICAgcmVzdWx0VHJhbnNmb3JtZXI6IG5lbzRqLnJlc3VsdFRyYW5zZm9ybWVycy5tYXBwZWQoe1xuICAgICAqICAgICBtYXAocmVjb3JkKSB7XG4gICAgICogICAgICAgIHJldHVybiByZWNvcmQuZ2V0KCduYW1lJylcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgY29sbGVjdChyZWNvcmRzLCBzdW1tYXJ5LCBrZXlzKSB7XG4gICAgICogICAgICAgIHJldHVybiByZWNvcmRzXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIG5hbWVzLmZvckVhY2gobmFtZSA9PiBjb25zb2xlLmxvZyhgJHtuYW1lfSBoYXMgMjVgKSlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVGhlIHRyYW5zZm9ybWVyIGNhbiBiZSBkZWZpbmVkIG9uZSBhbmQgdXNlZCBldmVyeXdoZXJlXG4gICAgICogY29uc3QgZ2V0UmVjb3Jkc0FzT2JqZWN0cyA9IG5lbzRqLnJlc3VsdFRyYW5zZm9ybWVycy5tYXBwZWQoe1xuICAgICAqICAgbWFwKHJlY29yZCkge1xuICAgICAqICAgICAgcmV0dXJuIHJlY29yZC50b09iamVjdCgpXG4gICAgICogICB9LFxuICAgICAqICAgY29sbGVjdChvYmplY3RzKSB7XG4gICAgICogICAgICByZXR1cm4gb2JqZWN0c1xuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiAvLyBUaGUgdXNhZ2UgaW4gYSBkcml2ZXIuZXhlY3V0ZVF1ZXJ5XG4gICAgICogY29uc3Qgb2JqZWN0cyA9IGF3YWl0IGRyaXZlci5leGVjdXRlUXVlcnkoJ01BVENIIChwOlBlcnNvbnsgYWdlOiAkYWdlIH0pIFJFVFVSTiBwLm5hbWUgYXMgbmFtZScsIHsgYWdlOiAyNSB9LCB7XG4gICAgICogICByZXN1bHRUcmFuc2Zvcm1lcjogZ2V0UmVjb3Jkc0FzT2JqZWN0c1xuICAgICAqIH0pXG4gICAgICogb2JqZWN0cy5mb3JFYWNoKG9iamVjdCA9PiBjb25zb2xlLmxvZyhgJHtvYmplY3QubmFtZX0gaGFzIDI1YCkpXG4gICAgICpcbiAgICAgKlxuICAgICAqIC8vIFRoZSB1c2FnZSBpbiBzZXNzaW9uLmV4ZWN1dGVSZWFkXG4gICAgICogY29uc3Qgb2JqZWN0cyA9IGF3YWl0IHNlc3Npb24uZXhlY3V0ZVJlYWQodHggPT4gZ2V0UmVjb3Jkc0FzT2JqZWN0cyh0eC5ydW4oJ01BVENIIChwOlBlcnNvbnsgYWdlOiAkYWdlIH0pIFJFVFVSTiBwLm5hbWUgYXMgbmFtZScpKSlcbiAgICAgKiBvYmplY3RzLmZvckVhY2gob2JqZWN0ID0+IGNvbnNvbGUubG9nKGAke29iamVjdC5uYW1lfSBoYXMgMjVgKSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIHJlc3VsdCB0cmFuc2Zvcm1lciBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihyZWNvcmQ6UmVjb3JkKTpSfSBbY29uZmlnLm1hcD1mdW5jdGlvbihyZWNvcmQpIHsgIHJldHVybiByZWNvcmQgfV0gTWV0aG9kIGNhbGxlZCBmb3IgbWFwcGluZyBlYWNoIHJlY29yZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24ocmVjb3JkczpSW10sIHN1bW1hcnk6UmVzdWx0U3VtbWFyeSwga2V5czpzdHJpbmdbXSk6VH0gW2NvbmZpZy5jb2xsZWN0PWZ1bmN0aW9uKHJlY29yZHMsIHN1bW1hcnksIGtleXMpIHsgcmV0dXJuIHsgcmVjb3Jkcywgc3VtbWFyeSwga2V5cyB9fV0gTWV0aG9kIGNhbGxlZCBmb3IgbWFwcGluZ1xuICAgICAqIHRoZSByZXN1bHQgZGF0YSB0byB0aGUgdHJhbnNmb3JtZXIgb3V0cHV0LlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRUcmFuc2Zvcm1lcjxUPn0gVGhlIHJlc3VsdCB0cmFuc2Zvcm1lclxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBpcyBhIHByZXZpZXcgZmVhdHVyZVxuICAgICAqIEBhbGlhcyB7QGxpbmsgUmVzdWx0VHJhbnNmb3JtZXJzI21hcHBlZFJlc3VsdFRyYW5zZm9ybWVyfVxuICAgICAqIEBzaW5jZSA1LjIyLjBcbiAgICAgKiBAc2VlIHtAbGluayBEcml2ZXIjZXhlY3V0ZVF1ZXJ5fVxuICAgICAqL1xuICAgIFJlc3VsdFRyYW5zZm9ybWVycy5wcm90b3R5cGUubWFwcGVkID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWFwcGVkUmVzdWx0VHJhbnNmb3JtZXIoY29uZmlnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgUmVzdWx0VHJhbnNmb3JtZXJ9IHdoaWNoIGNvbGxlY3RzIHRoZSBmaXJzdCByZWNvcmQge0BsaW5rIFJlY29yZH0gb2Yge0BsaW5rIFJlc3VsdH1cbiAgICAgKiBhbmQgZGlzY2FyZCB0aGUgcmVzdCBvZiB0aGUgcmVjb3JkcywgaWYgZXhpc3RlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIFVzaW5nIGluIGV4ZWN1dGVRdWVyeVxuICAgICAqIGNvbnN0IG1heWJlRmlyc3RSZWNvcmQgPSBhd2FpdCBkcml2ZXIuZXhlY3V0ZVF1ZXJ5KCdNQVRDSCAocDpQZXJzb257IGFnZTogJGFnZSB9KSBSRVRVUk4gcC5uYW1lIGFzIG5hbWUnLCB7IGFnZTogMjUgfSwge1xuICAgICAqICAgcmVzdWx0VHJhbnNmb3JtZXI6IG5lbzRqLnJlc3VsdFRyYW5zZm9ybWVycy5maXJzdCgpXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gVXNpbmcgaW4gb3RoZXIgcmVzdWx0c1xuICAgICAqIGNvbnN0IHJlY29yZCA9IGF3YWl0IG5lbzRqLnJlc3VsdFRyYW5zZm9ybWVycy5maXJzdCgpKHJlc3VsdClcbiAgICAgKlxuICAgICAqXG4gICAgICogQHRlbXBsYXRlIEVudHJpZXMgVGhlIHNoYXBlIG9mIHRoZSByZWNvcmQuXG4gICAgICogQHJldHVybnMge1Jlc3VsdFRyYW5zZm9ybWVyPFJlY29yZDxFbnRyaWVzPnx1bmRlZmluZWQ+fSBUaGUgcmVzdWx0IHRyYW5zZm9ybWVyXG4gICAgICogQHNlZSB7QGxpbmsgRHJpdmVyI2V4ZWN1dGVRdWVyeX1cbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgaXMgYSBwcmV2aWV3IGZlYXR1cmUuXG4gICAgICogQHNpbmNlIDUuMjIuMFxuICAgICAqL1xuICAgIFJlc3VsdFRyYW5zZm9ybWVycy5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgUmVzdWx0VHJhbnNmb3JtZXJ9IHdoaWNoIGNvbnN1bWVzIHRoZSByZXN1bHQgYW5kIHJldHVybnMgdGhlIHtAbGluayBSZXN1bHRTdW1tYXJ5fS5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVzdWx0IHRyYW5zZm9ybWVyIGlzIGEgc2hvcnRjdXQgdG8gYChyZXN1bHQpID0+IHJlc3VsdC5zdW1tYXJ5KClgLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgZHJpdmVyLmV4ZWN1dGVRdWVyeSgnQ1JFQVRFIChwOlBlcnNvbnsgbmFtZTogJG5hbWUgfSkgUkVUVVJOIHAnLCB7IG5hbWU6ICdQZXJzb24xJ30sIHtcbiAgICAgKiAgIHJlc3VsdFRyYW5zZm9ybWVyOiBuZW80ai5yZXN1bHRUcmFuc2Zvcm1lcnMuc3VtbWFyeSgpXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRUcmFuc2Zvcm1lcjxSZXN1bHRTdW1tYXJ5PFQ+Pn0gVGhlIHJlc3VsdCB0cmFuc2Zvcm1lclxuICAgICAqIEBzZWUge0BsaW5rIERyaXZlciNleGVjdXRlUXVlcnl9XG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIGlzIGEgcHJldmlldyBmZWF0dXJlXG4gICAgICovXG4gICAgUmVzdWx0VHJhbnNmb3JtZXJzLnByb3RvdHlwZS5zdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3VtbWFyeTtcbiAgICB9O1xuICAgIHJldHVybiBSZXN1bHRUcmFuc2Zvcm1lcnM7XG59KCkpO1xuLyoqXG4gKiBIb2xkcyB0aGUgY29tbW9uIHtAbGluayBSZXN1bHRUcmFuc2Zvcm1lcn0gdXNlZCB3aXRoIHtAbGluayBEcml2ZXIjZXhlY3V0ZVF1ZXJ5fS5cbiAqL1xudmFyIHJlc3VsdFRyYW5zZm9ybWVycyA9IG5ldyBSZXN1bHRUcmFuc2Zvcm1lcnMoKTtcbk9iamVjdC5mcmVlemUocmVzdWx0VHJhbnNmb3JtZXJzKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlc3VsdFRyYW5zZm9ybWVycztcbmZ1bmN0aW9uIGNyZWF0ZUVhZ2VyUmVzdWx0RnJvbVJlc3VsdChyZXN1bHQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgc3VtbWFyeSwgcmVjb3Jkcywga2V5cztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpLCBzdW1tYXJ5ID0gX2Euc3VtbWFyeSwgcmVjb3JkcyA9IF9hLnJlY29yZHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3VsdC5rZXlzKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyByZXN1bHRfZWFnZXJfMS5kZWZhdWx0KGtleXMsIHJlY29yZHMsIHN1bW1hcnkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXBwZWRSZXN1bHRUcmFuc2Zvcm1lcihjb25maWcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChjb25maWcgPT0gbnVsbCB8fCAoY29uZmlnLmNvbGxlY3QgPT0gbnVsbCAmJiBjb25maWcubWFwID09IG51bGwpKSB7XG4gICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnUmVxdWlyZXMgYSBtYXAgb3IvYW5kIGEgY29sbGVjdCBmdW5jdGlvbnMuJyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHsgcmVjb3JkczogW10sIGtleXM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbktleXM6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBrZXlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25OZXh0OiBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubWFwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWRSZWNvcmQgPSBjb25maWcubWFwKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVkUmVjb3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5yZWNvcmRzLnB1c2gobWFwcGVkUmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jb2xsZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29uZmlnLmNvbGxlY3Qoc3RhdGUucmVjb3Jkcywgc3VtbWFyeSwgc3RhdGUua2V5cykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHsgcmVjb3Jkczogc3RhdGUucmVjb3Jkcywgc3VtbWFyeTogc3VtbWFyeSwga2V5czogc3RhdGUua2V5cyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pOyB9O1xufVxuZnVuY3Rpb24gZmlyc3QocmVzdWx0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXQsIF9hLCB2YWx1ZSwgZG9uZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaXQgPSByZXN1bHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGl0Lm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKSwgdmFsdWUgPSBfYS52YWx1ZSwgZG9uZSA9IF9hLmRvbmU7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMiwgLCAzLCA2XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdW5kZWZpbmVkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXQucmV0dXJuICE9IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaXQucmV0dXJuKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHN1bW1hcnkocmVzdWx0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCByZXN1bHQuc3VtbWFyeSgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/result-transformers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/result.js":
/*!******************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/result.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar result_summary_1 = __importDefault(__webpack_require__(/*! ./result-summary */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result-summary.js\"));\nvar internal_1 = __webpack_require__(/*! ./internal */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/index.js\");\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar EMPTY_CONNECTION_HOLDER = internal_1.connectionHolder.EMPTY_CONNECTION_HOLDER;\n/**\n * @private\n * @param {Error} error The error\n * @returns {void}\n */\nvar DEFAULT_ON_ERROR = function (error) {\n    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands, @typescript-eslint/no-base-to-string\n    console.log('Uncaught error when processing result: ' + error);\n};\n/**\n * @private\n * @param {ResultSummary} summary\n * @returns {void}\n */\nvar DEFAULT_ON_COMPLETED = function (summary) { };\n/**\n * @private\n * @param {string[]} keys List of keys of the record in the result\n * @return {void}\n */\nvar DEFAULT_ON_KEYS = function (keys) { };\n/**\n * A stream of {@link Record} representing the result of a query.\n * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}\n * summary, or rejected with error that contains {@link string} code and {@link string} message.\n * Alternatively can be consumed lazily using {@link Result#subscribe} function.\n * @access public\n */\nvar Result = /** @class */ (function () {\n    /**\n     * Inject the observer to be used.\n     * @constructor\n     * @access private\n     * @param {Promise<observer.ResultStreamObserver>} streamObserverPromise\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.\n     */\n    function Result(streamObserverPromise, query, parameters, connectionHolder, watermarks) {\n        if (watermarks === void 0) { watermarks = { high: Number.MAX_VALUE, low: Number.MAX_VALUE }; }\n        /**\n         * Called when finally the result is done\n         *\n         * *Should not be combined with {@link Result#subscribe} function.*\n         * @param {function()|null} onfinally - function when the promise finished\n         * @return {Promise} promise.\n         */\n        this[_a] = 'Result';\n        this._stack = captureStacktrace();\n        this._streamObserverPromise = streamObserverPromise;\n        this._p = null;\n        this._query = query;\n        this._parameters = parameters !== null && parameters !== void 0 ? parameters : {};\n        this._connectionHolder = connectionHolder !== null && connectionHolder !== void 0 ? connectionHolder : EMPTY_CONNECTION_HOLDER;\n        this._keys = null;\n        this._summary = null;\n        this._error = null;\n        this._watermarks = watermarks;\n    }\n    /**\n     * Returns a promise for the field keys.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @public\n     * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.\n     }\n     */\n    Result.prototype.keys = function () {\n        var _this = this;\n        if (this._keys !== null) {\n            return Promise.resolve(this._keys);\n        }\n        else if (this._error !== null) {\n            return Promise.reject(this._error);\n        }\n        return new Promise(function (resolve, reject) {\n            _this._streamObserverPromise\n                .then(function (observer) {\n                return observer.subscribe(_this._decorateObserver({\n                    onKeys: function (keys) { return resolve(keys); },\n                    onError: function (err) { return reject(err); }\n                }));\n            })\n                .catch(reject);\n        });\n    };\n    /**\n     * Returns a promise for the result summary.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @public\n     * @returns {Promise<ResultSummary<T>>} - Result summary.\n     *\n     */\n    Result.prototype.summary = function () {\n        var _this = this;\n        if (this._summary !== null) {\n            // This type casting is needed since we are defining the number type of\n            // summary in Result template\n            return Promise.resolve(this._summary);\n        }\n        else if (this._error !== null) {\n            return Promise.reject(this._error);\n        }\n        return new Promise(function (resolve, reject) {\n            _this._streamObserverPromise\n                .then(function (o) {\n                o.cancel();\n                o.subscribe(_this._decorateObserver({\n                    // This type casting is needed since we are defining the number type of\n                    // summary in Result template\n                    onCompleted: function (summary) { return resolve(summary); },\n                    onError: function (err) { return reject(err); }\n                }));\n            })\n                .catch(reject);\n        });\n    };\n    /**\n     * Create and return new Promise\n     *\n     * @private\n     * @return {Promise} new Promise.\n     */\n    Result.prototype._getOrCreatePromise = function () {\n        var _this = this;\n        if (this._p == null) {\n            this._p = new Promise(function (resolve, reject) {\n                var records = [];\n                var observer = {\n                    onNext: function (record) {\n                        records.push(record);\n                    },\n                    onCompleted: function (summary) {\n                        resolve({ records: records, summary: summary });\n                    },\n                    onError: function (error) {\n                        reject(error);\n                    }\n                };\n                _this.subscribe(observer);\n            });\n        }\n        return this._p;\n    };\n    /**\n     * Provides a async iterator over the records in the result.\n     *\n     * *Should not be combined with {@link Result#subscribe} or {@link Result#then} functions.*\n     *\n     * @public\n     * @returns {PeekableAsyncIterator<Record<R>, ResultSummary>} The async iterator for the Results\n     */\n    Result.prototype[Symbol.asyncIterator] = function () {\n        var _this = this;\n        if (!this.isOpen()) {\n            var error_2 = (0, error_1.newError)('Result is already consumed');\n            return {\n                next: function () { return Promise.reject(error_2); },\n                peek: function () { return Promise.reject(error_2); }\n            };\n        }\n        var state = { paused: true, firstRun: true, finished: false };\n        var controlFlow = function () {\n            var _b, _c;\n            if (state.streaming == null) {\n                return;\n            }\n            var size = (_c = (_b = state.queuedObserver) === null || _b === void 0 ? void 0 : _b.size) !== null && _c !== void 0 ? _c : 0;\n            var queueSizeIsOverHighOrEqualWatermark = size >= _this._watermarks.high;\n            var queueSizeIsBellowOrEqualLowWatermark = size <= _this._watermarks.low;\n            if (queueSizeIsOverHighOrEqualWatermark && !state.paused) {\n                state.paused = true;\n                state.streaming.pause();\n            }\n            else if ((queueSizeIsBellowOrEqualLowWatermark && state.paused) || (state.firstRun && !queueSizeIsOverHighOrEqualWatermark)) {\n                state.firstRun = false;\n                state.paused = false;\n                state.streaming.resume();\n            }\n        };\n        var initializeObserver = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(state.queuedObserver === undefined)) return [3 /*break*/, 2];\n                        state.queuedObserver = this._createQueuedResultObserver(controlFlow);\n                        _b = state;\n                        return [4 /*yield*/, this._subscribe(state.queuedObserver, true).catch(function () { return undefined; })];\n                    case 1:\n                        _b.streaming = _c.sent();\n                        controlFlow();\n                        _c.label = 2;\n                    case 2: return [2 /*return*/, state.queuedObserver];\n                }\n            });\n        }); };\n        var assertSummary = function (summary) {\n            if (summary === undefined) {\n                throw (0, error_1.newError)('InvalidState: Result stream finished without Summary', error_1.PROTOCOL_ERROR);\n            }\n            return true;\n        };\n        return {\n            next: function () { return __awaiter(_this, void 0, void 0, function () {\n                var queuedObserver, next;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            if (state.finished) {\n                                if (assertSummary(state.summary)) {\n                                    return [2 /*return*/, { done: true, value: state.summary }];\n                                }\n                            }\n                            return [4 /*yield*/, initializeObserver()];\n                        case 1:\n                            queuedObserver = _b.sent();\n                            return [4 /*yield*/, queuedObserver.dequeue()];\n                        case 2:\n                            next = _b.sent();\n                            if (next.done === true) {\n                                state.finished = next.done;\n                                state.summary = next.value;\n                            }\n                            return [2 /*return*/, next];\n                    }\n                });\n            }); },\n            return: function (value) { return __awaiter(_this, void 0, void 0, function () {\n                var queuedObserver, last;\n                var _b;\n                return __generator(this, function (_c) {\n                    switch (_c.label) {\n                        case 0:\n                            if (state.finished) {\n                                if (assertSummary(state.summary)) {\n                                    return [2 /*return*/, { done: true, value: value !== null && value !== void 0 ? value : state.summary }];\n                                }\n                            }\n                            (_b = state.streaming) === null || _b === void 0 ? void 0 : _b.cancel();\n                            return [4 /*yield*/, initializeObserver()];\n                        case 1:\n                            queuedObserver = _c.sent();\n                            return [4 /*yield*/, queuedObserver.dequeueUntilDone()];\n                        case 2:\n                            last = _c.sent();\n                            state.finished = true;\n                            last.value = value !== null && value !== void 0 ? value : last.value;\n                            state.summary = last.value;\n                            return [2 /*return*/, last];\n                    }\n                });\n            }); },\n            peek: function () { return __awaiter(_this, void 0, void 0, function () {\n                var queuedObserver;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            if (state.finished) {\n                                if (assertSummary(state.summary)) {\n                                    return [2 /*return*/, { done: true, value: state.summary }];\n                                }\n                            }\n                            return [4 /*yield*/, initializeObserver()];\n                        case 1:\n                            queuedObserver = _b.sent();\n                            return [4 /*yield*/, queuedObserver.head()];\n                        case 2: return [2 /*return*/, _b.sent()];\n                    }\n                });\n            }); }\n        };\n    };\n    /**\n     * Waits for all results and calls the passed in function with the results.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called\n     * when finished.\n     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\n     * @return {Promise} promise.\n     */\n    Result.prototype.then = function (onFulfilled, onRejected) {\n        return this._getOrCreatePromise().then(onFulfilled, onRejected);\n    };\n    /**\n     * Catch errors when using promises.\n     *\n     * *Should not be combined with {@link Result#subscribe} function.*\n     *\n     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\n     * @return {Promise} promise.\n     */\n    Result.prototype.catch = function (onRejected) {\n        return this._getOrCreatePromise().catch(onRejected);\n    };\n    Result.prototype.finally = function (onfinally) {\n        return this._getOrCreatePromise().finally(onfinally);\n    };\n    /**\n     * Stream records to observer as they come in, this is a more efficient method\n     * of handling the results, and allows you to handle arbitrarily large results.\n     *\n     * @param {Object} observer - Observer object\n     * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.\n     * @param {function(record: Record)} observer.onNext - handle records, one by one.\n     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.\n     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.\n     * @return {void}\n     */\n    Result.prototype.subscribe = function (observer) {\n        this._subscribe(observer)\n            .catch(function () { });\n    };\n    /**\n     * Check if this result is active, i.e., neither a summary nor an error has been received by the result.\n     * @return {boolean} `true` when neither a summary or nor an error has been received by the result.\n     */\n    Result.prototype.isOpen = function () {\n        return this._summary === null && this._error === null;\n    };\n    /**\n     * Stream records to observer as they come in, this is a more efficient method\n     * of handling the results, and allows you to handle arbitrarily large results.\n     *\n     * @access private\n     * @param {ResultObserver} observer The observer to send records to.\n     * @param {boolean} paused The flag to indicate if the stream should be started paused\n     * @returns {Promise<observer.ResultStreamObserver>} The result stream observer.\n     */\n    Result.prototype._subscribe = function (observer, paused) {\n        if (paused === void 0) { paused = false; }\n        var _observer = this._decorateObserver(observer);\n        return this._streamObserverPromise\n            .then(function (o) {\n            if (paused) {\n                o.pause();\n            }\n            o.subscribe(_observer);\n            return o;\n        })\n            .catch(function (error) {\n            if (_observer.onError != null) {\n                _observer.onError(error);\n            }\n            return Promise.reject(error);\n        });\n    };\n    /**\n     * Decorates the ResultObserver with the necessary methods.\n     *\n     * @access private\n     * @param {ResultObserver} observer The ResultObserver to decorate.\n     * @returns The decorated result observer\n     */\n    Result.prototype._decorateObserver = function (observer) {\n        var _this = this;\n        var _b, _c, _d;\n        var onCompletedOriginal = (_b = observer.onCompleted) !== null && _b !== void 0 ? _b : DEFAULT_ON_COMPLETED;\n        var onErrorOriginal = (_c = observer.onError) !== null && _c !== void 0 ? _c : DEFAULT_ON_ERROR;\n        var onKeysOriginal = (_d = observer.onKeys) !== null && _d !== void 0 ? _d : DEFAULT_ON_KEYS;\n        var onCompletedWrapper = function (metadata) {\n            _this._releaseConnectionAndGetSummary(metadata).then(function (summary) {\n                if (_this._summary !== null) {\n                    return onCompletedOriginal.call(observer, _this._summary);\n                }\n                _this._summary = summary;\n                return onCompletedOriginal.call(observer, summary);\n            }).catch(onErrorOriginal);\n        };\n        var onErrorWrapper = function (error) {\n            // notify connection holder that the used connection is not needed any more because error happened\n            // and result can't bee consumed any further; call the original onError callback after that\n            _this._connectionHolder.releaseConnection().then(function () {\n                replaceStacktrace(error, _this._stack);\n                _this._error = error;\n                onErrorOriginal.call(observer, error);\n            }).catch(onErrorOriginal);\n        };\n        var onKeysWrapper = function (keys) {\n            _this._keys = keys;\n            return onKeysOriginal.call(observer, keys);\n        };\n        return {\n            onNext: (observer.onNext != null) ? observer.onNext.bind(observer) : undefined,\n            onKeys: onKeysWrapper,\n            onCompleted: onCompletedWrapper,\n            onError: onErrorWrapper\n        };\n    };\n    /**\n     * Signals the stream observer that the future records should be discarded on the server.\n     *\n     * @protected\n     * @since 4.0.0\n     * @returns {void}\n     */\n    Result.prototype._cancel = function () {\n        if (this._summary === null && this._error === null) {\n            this._streamObserverPromise.then(function (o) { return o.cancel(); })\n                .catch(function () { });\n        }\n    };\n    /**\n     * @access private\n     * @param metadata\n     * @returns\n     */\n    Result.prototype._releaseConnectionAndGetSummary = function (metadata) {\n        var _b = internal_1.util.validateQueryAndParameters(this._query, this._parameters, {\n            skipAsserts: true\n        }), query = _b.validatedQuery, parameters = _b.params;\n        var connectionHolder = this._connectionHolder;\n        return connectionHolder\n            .getConnection()\n            .then(\n        // onFulfilled:\n        function (connection) {\n            return connectionHolder\n                .releaseConnection()\n                .then(function () {\n                return connection === null || connection === void 0 ? void 0 : connection.getProtocolVersion();\n            });\n        }, \n        // onRejected:\n        function (_) { return undefined; })\n            .then(function (protocolVersion) {\n            return new result_summary_1.default(query, parameters, metadata, protocolVersion);\n        });\n    };\n    /**\n     * @access private\n     */\n    Result.prototype._createQueuedResultObserver = function (onQueueSizeChanged) {\n        var _this = this;\n        function createResolvablePromise() {\n            var resolvablePromise = {};\n            resolvablePromise.promise = new Promise(function (resolve, reject) {\n                resolvablePromise.resolve = resolve;\n                resolvablePromise.reject = reject;\n            });\n            return resolvablePromise;\n        }\n        function isError(elementOrError) {\n            return elementOrError instanceof Error;\n        }\n        function dequeue() {\n            var _b;\n            return __awaiter(this, void 0, void 0, function () {\n                var element;\n                return __generator(this, function (_c) {\n                    switch (_c.label) {\n                        case 0:\n                            if (buffer.length > 0) {\n                                element = (_b = buffer.shift()) !== null && _b !== void 0 ? _b : (0, error_1.newError)('Unexpected empty buffer', error_1.PROTOCOL_ERROR);\n                                onQueueSizeChanged();\n                                if (isError(element)) {\n                                    throw element;\n                                }\n                                return [2 /*return*/, element];\n                            }\n                            promiseHolder.resolvable = createResolvablePromise();\n                            return [4 /*yield*/, promiseHolder.resolvable.promise];\n                        case 1: return [2 /*return*/, _c.sent()];\n                    }\n                });\n            });\n        }\n        var buffer = [];\n        var promiseHolder = { resolvable: null };\n        var observer = {\n            onNext: function (record) {\n                observer._push({ done: false, value: record });\n            },\n            onCompleted: function (summary) {\n                observer._push({ done: true, value: summary });\n            },\n            onError: function (error) {\n                observer._push(error);\n            },\n            _push: function (element) {\n                if (promiseHolder.resolvable !== null) {\n                    var resolvable = promiseHolder.resolvable;\n                    promiseHolder.resolvable = null;\n                    if (isError(element)) {\n                        resolvable.reject(element);\n                    }\n                    else {\n                        resolvable.resolve(element);\n                    }\n                }\n                else {\n                    buffer.push(element);\n                    onQueueSizeChanged();\n                }\n            },\n            dequeue: dequeue,\n            dequeueUntilDone: function () { return __awaiter(_this, void 0, void 0, function () {\n                var element;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            if (false) {}\n                            return [4 /*yield*/, dequeue()];\n                        case 1:\n                            element = _b.sent();\n                            if (element.done === true) {\n                                return [2 /*return*/, element];\n                            }\n                            return [3 /*break*/, 0];\n                        case 2: return [2 /*return*/];\n                    }\n                });\n            }); },\n            head: function () { return __awaiter(_this, void 0, void 0, function () {\n                var element, element, error_3;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            if (buffer.length > 0) {\n                                element = buffer[0];\n                                if (isError(element)) {\n                                    throw element;\n                                }\n                                return [2 /*return*/, element];\n                            }\n                            promiseHolder.resolvable = createResolvablePromise();\n                            _b.label = 1;\n                        case 1:\n                            _b.trys.push([1, 3, 4, 5]);\n                            return [4 /*yield*/, promiseHolder.resolvable.promise];\n                        case 2:\n                            element = _b.sent();\n                            buffer.unshift(element);\n                            return [2 /*return*/, element];\n                        case 3:\n                            error_3 = _b.sent();\n                            buffer.unshift(error_3);\n                            throw error_3;\n                        case 4:\n                            onQueueSizeChanged();\n                            return [7 /*endfinally*/];\n                        case 5: return [2 /*return*/];\n                    }\n                });\n            }); },\n            get size() {\n                return buffer.length;\n            }\n        };\n        return observer;\n    };\n    return Result;\n}());\n_a = Symbol.toStringTag;\nfunction captureStacktrace() {\n    var error = new Error('');\n    if (error.stack != null) {\n        return error.stack.replace(/^Error(\\n\\r)*/, ''); // we don't need the 'Error\\n' part, if only it exists\n    }\n    return null;\n}\n/**\n * @private\n * @param {Error} error The error\n * @param {string| null} newStack The newStack\n * @returns {void}\n */\nfunction replaceStacktrace(error, newStack) {\n    if (newStack != null) {\n        // Error.prototype.toString() concatenates error.name and error.message nicely\n        // then we add the rest of the stack trace\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string\n        error.stack = error.toString() + '\\n' + newStack;\n    }\n}\nexports[\"default\"] = Result;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3Jlc3VsdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQSx1Q0FBdUMsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDakUsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVk7QUFDckMsY0FBYyxtQkFBTyxDQUFDLG9FQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEsSUFBSTtBQUNqQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvcmVzdWx0LmpzP2Y2YzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbnZhciByZXN1bHRfc3VtbWFyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc3VsdC1zdW1tYXJ5XCIpKTtcbnZhciBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG52YXIgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xudmFyIEVNUFRZX0NPTk5FQ1RJT05fSE9MREVSID0gaW50ZXJuYWxfMS5jb25uZWN0aW9uSG9sZGVyLkVNUFRZX0NPTk5FQ1RJT05fSE9MREVSO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xudmFyIERFRkFVTFRfT05fRVJST1IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1iYXNlLXRvLXN0cmluZ1xuICAgIGNvbnNvbGUubG9nKCdVbmNhdWdodCBlcnJvciB3aGVuIHByb2Nlc3NpbmcgcmVzdWx0OiAnICsgZXJyb3IpO1xufTtcbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVzdWx0U3VtbWFyeX0gc3VtbWFyeVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnZhciBERUZBVUxUX09OX0NPTVBMRVRFRCA9IGZ1bmN0aW9uIChzdW1tYXJ5KSB7IH07XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzIExpc3Qgb2Yga2V5cyBvZiB0aGUgcmVjb3JkIGluIHRoZSByZXN1bHRcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbnZhciBERUZBVUxUX09OX0tFWVMgPSBmdW5jdGlvbiAoa2V5cykgeyB9O1xuLyoqXG4gKiBBIHN0cmVhbSBvZiB7QGxpbmsgUmVjb3JkfSByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCBvZiBhIHF1ZXJ5LlxuICogQ2FuIGJlIGNvbnN1bWVkIGVhZ2VybHkgYXMge0BsaW5rIFByb21pc2V9IHJlc29sdmVkIHdpdGggYXJyYXkgb2YgcmVjb3JkcyBhbmQge0BsaW5rIFJlc3VsdFN1bW1hcnl9XG4gKiBzdW1tYXJ5LCBvciByZWplY3RlZCB3aXRoIGVycm9yIHRoYXQgY29udGFpbnMge0BsaW5rIHN0cmluZ30gY29kZSBhbmQge0BsaW5rIHN0cmluZ30gbWVzc2FnZS5cbiAqIEFsdGVybmF0aXZlbHkgY2FuIGJlIGNvbnN1bWVkIGxhemlseSB1c2luZyB7QGxpbmsgUmVzdWx0I3N1YnNjcmliZX0gZnVuY3Rpb24uXG4gKiBAYWNjZXNzIHB1YmxpY1xuICovXG52YXIgUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEluamVjdCB0aGUgb2JzZXJ2ZXIgdG8gYmUgdXNlZC5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1Byb21pc2U8b2JzZXJ2ZXIuUmVzdWx0U3RyZWFtT2JzZXJ2ZXI+fSBzdHJlYW1PYnNlcnZlclByb21pc2VcbiAgICAgKiBAcGFyYW0ge21peGVkfSBxdWVyeSAtIEN5cGhlciBxdWVyeSB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgLSBNYXAgd2l0aCBwYXJhbWV0ZXJzIHRvIHVzZSBpbiBxdWVyeVxuICAgICAqIEBwYXJhbSB7Q29ubmVjdGlvbkhvbGRlcn0gY29ubmVjdGlvbkhvbGRlciAtIHRvIGJlIG5vdGlmaWVkIHdoZW4gcmVzdWx0IGlzIGVpdGhlciBmdWxseSBjb25zdW1lZCBvciBlcnJvciBoYXBwZW5lZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXN1bHQoc3RyZWFtT2JzZXJ2ZXJQcm9taXNlLCBxdWVyeSwgcGFyYW1ldGVycywgY29ubmVjdGlvbkhvbGRlciwgd2F0ZXJtYXJrcykge1xuICAgICAgICBpZiAod2F0ZXJtYXJrcyA9PT0gdm9pZCAwKSB7IHdhdGVybWFya3MgPSB7IGhpZ2g6IE51bWJlci5NQVhfVkFMVUUsIGxvdzogTnVtYmVyLk1BWF9WQUxVRSB9OyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBmaW5hbGx5IHRoZSByZXN1bHQgaXMgZG9uZVxuICAgICAgICAgKlxuICAgICAgICAgKiAqU2hvdWxkIG5vdCBiZSBjb21iaW5lZCB3aXRoIHtAbGluayBSZXN1bHQjc3Vic2NyaWJlfSBmdW5jdGlvbi4qXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKXxudWxsfSBvbmZpbmFsbHkgLSBmdW5jdGlvbiB3aGVuIHRoZSBwcm9taXNlIGZpbmlzaGVkXG4gICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzW19hXSA9ICdSZXN1bHQnO1xuICAgICAgICB0aGlzLl9zdGFjayA9IGNhcHR1cmVTdGFja3RyYWNlKCk7XG4gICAgICAgIHRoaXMuX3N0cmVhbU9ic2VydmVyUHJvbWlzZSA9IHN0cmVhbU9ic2VydmVyUHJvbWlzZTtcbiAgICAgICAgdGhpcy5fcCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzICE9PSBudWxsICYmIHBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IHBhcmFtZXRlcnMgOiB7fTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbkhvbGRlciA9IGNvbm5lY3Rpb25Ib2xkZXIgIT09IG51bGwgJiYgY29ubmVjdGlvbkhvbGRlciAhPT0gdm9pZCAwID8gY29ubmVjdGlvbkhvbGRlciA6IEVNUFRZX0NPTk5FQ1RJT05fSE9MREVSO1xuICAgICAgICB0aGlzLl9rZXlzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3VtbWFyeSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2F0ZXJtYXJrcyA9IHdhdGVybWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmllbGQga2V5cy5cbiAgICAgKlxuICAgICAqICpTaG91bGQgbm90IGJlIGNvbWJpbmVkIHdpdGgge0BsaW5rIFJlc3VsdCNzdWJzY3JpYmV9IGZ1bmN0aW9uLipcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IC0gRmllbGQga2V5cywgaW4gdGhlIG9yZGVyIHRoZXkgd2lsbCBhcHBlYXIgaW4gcmVjb3Jkcy5cbiAgICAgfVxuICAgICAqL1xuICAgIFJlc3VsdC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2tleXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fa2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLl9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdHJlYW1PYnNlcnZlclByb21pc2VcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuc3Vic2NyaWJlKF90aGlzLl9kZWNvcmF0ZU9ic2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgb25LZXlzOiBmdW5jdGlvbiAoa2V5cykgeyByZXR1cm4gcmVzb2x2ZShrZXlzKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycikgeyByZXR1cm4gcmVqZWN0KGVycik7IH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IHN1bW1hcnkuXG4gICAgICpcbiAgICAgKiAqU2hvdWxkIG5vdCBiZSBjb21iaW5lZCB3aXRoIHtAbGluayBSZXN1bHQjc3Vic2NyaWJlfSBmdW5jdGlvbi4qXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0U3VtbWFyeTxUPj59IC0gUmVzdWx0IHN1bW1hcnkuXG4gICAgICpcbiAgICAgKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLnN1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9zdW1tYXJ5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHR5cGUgY2FzdGluZyBpcyBuZWVkZWQgc2luY2Ugd2UgYXJlIGRlZmluaW5nIHRoZSBudW1iZXIgdHlwZSBvZlxuICAgICAgICAgICAgLy8gc3VtbWFyeSBpbiBSZXN1bHQgdGVtcGxhdGVcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fc3VtbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLl9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdHJlYW1PYnNlcnZlclByb21pc2VcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIG8uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgby5zdWJzY3JpYmUoX3RoaXMuX2RlY29yYXRlT2JzZXJ2ZXIoe1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHR5cGUgY2FzdGluZyBpcyBuZWVkZWQgc2luY2Ugd2UgYXJlIGRlZmluaW5nIHRoZSBudW1iZXIgdHlwZSBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBzdW1tYXJ5IGluIFJlc3VsdCB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKHN1bW1hcnkpIHsgcmV0dXJuIHJlc29sdmUoc3VtbWFyeSk7IH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBuZXcgUHJvbWlzZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBuZXcgUHJvbWlzZS5cbiAgICAgKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLl9nZXRPckNyZWF0ZVByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9wID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3AgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGVkOiBmdW5jdGlvbiAoc3VtbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHJlY29yZHM6IHJlY29yZHMsIHN1bW1hcnk6IHN1bW1hcnkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBhc3luYyBpdGVyYXRvciBvdmVyIHRoZSByZWNvcmRzIGluIHRoZSByZXN1bHQuXG4gICAgICpcbiAgICAgKiAqU2hvdWxkIG5vdCBiZSBjb21iaW5lZCB3aXRoIHtAbGluayBSZXN1bHQjc3Vic2NyaWJlfSBvciB7QGxpbmsgUmVzdWx0I3RoZW59IGZ1bmN0aW9ucy4qXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICogQHJldHVybnMge1BlZWthYmxlQXN5bmNJdGVyYXRvcjxSZWNvcmQ8Uj4sIFJlc3VsdFN1bW1hcnk+fSBUaGUgYXN5bmMgaXRlcmF0b3IgZm9yIHRoZSBSZXN1bHRzXG4gICAgICovXG4gICAgUmVzdWx0LnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pc09wZW4oKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yXzIgPSAoMCwgZXJyb3JfMS5uZXdFcnJvcikoJ1Jlc3VsdCBpcyBhbHJlYWR5IGNvbnN1bWVkJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yXzIpOyB9LFxuICAgICAgICAgICAgICAgIHBlZWs6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yXzIpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHsgcGF1c2VkOiB0cnVlLCBmaXJzdFJ1bjogdHJ1ZSwgZmluaXNoZWQ6IGZhbHNlIH07XG4gICAgICAgIHZhciBjb250cm9sRmxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RyZWFtaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IChfYyA9IChfYiA9IHN0YXRlLnF1ZXVlZE9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2l6ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgICAgIHZhciBxdWV1ZVNpemVJc092ZXJIaWdoT3JFcXVhbFdhdGVybWFyayA9IHNpemUgPj0gX3RoaXMuX3dhdGVybWFya3MuaGlnaDtcbiAgICAgICAgICAgIHZhciBxdWV1ZVNpemVJc0JlbGxvd09yRXF1YWxMb3dXYXRlcm1hcmsgPSBzaXplIDw9IF90aGlzLl93YXRlcm1hcmtzLmxvdztcbiAgICAgICAgICAgIGlmIChxdWV1ZVNpemVJc092ZXJIaWdoT3JFcXVhbFdhdGVybWFyayAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdHJlYW1pbmcucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChxdWV1ZVNpemVJc0JlbGxvd09yRXF1YWxMb3dXYXRlcm1hcmsgJiYgc3RhdGUucGF1c2VkKSB8fCAoc3RhdGUuZmlyc3RSdW4gJiYgIXF1ZXVlU2l6ZUlzT3ZlckhpZ2hPckVxdWFsV2F0ZXJtYXJrKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmZpcnN0UnVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3RyZWFtaW5nLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZU9ic2VydmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3RhdGUucXVldWVkT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUucXVldWVkT2JzZXJ2ZXIgPSB0aGlzLl9jcmVhdGVRdWV1ZWRSZXN1bHRPYnNlcnZlcihjb250cm9sRmxvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fc3Vic2NyaWJlKHN0YXRlLnF1ZXVlZE9ic2VydmVyLCB0cnVlKS5jYXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc3RyZWFtaW5nID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbEZsb3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgc3RhdGUucXVldWVkT2JzZXJ2ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfTtcbiAgICAgICAgdmFyIGFzc2VydFN1bW1hcnkgPSBmdW5jdGlvbiAoc3VtbWFyeSkge1xuICAgICAgICAgICAgaWYgKHN1bW1hcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnSW52YWxpZFN0YXRlOiBSZXN1bHQgc3RyZWFtIGZpbmlzaGVkIHdpdGhvdXQgU3VtbWFyeScsIGVycm9yXzEuUFJPVE9DT0xfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlZE9ic2VydmVyLCBuZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0U3VtbWFyeShzdGF0ZS5zdW1tYXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHN0YXRlLnN1bW1hcnkgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaW5pdGlhbGl6ZU9ic2VydmVyKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlZE9ic2VydmVyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHF1ZXVlZE9ic2VydmVyLmRlcXVldWUoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb25lID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmZpbmlzaGVkID0gbmV4dC5kb25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdW1tYXJ5ID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5leHRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTsgfSxcbiAgICAgICAgICAgIHJldHVybjogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlZE9ic2VydmVyLCBsYXN0O1xuICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydFN1bW1hcnkoc3RhdGUuc3VtbWFyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGRvbmU6IHRydWUsIHZhbHVlOiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBzdGF0ZS5zdW1tYXJ5IH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IHN0YXRlLnN0cmVhbWluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGluaXRpYWxpemVPYnNlcnZlcigpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZWRPYnNlcnZlciA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBxdWV1ZWRPYnNlcnZlci5kZXF1ZXVlVW50aWxEb25lKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QudmFsdWUgPSB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBsYXN0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnN1bW1hcnkgPSBsYXN0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsYXN0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7IH0sXG4gICAgICAgICAgICBwZWVrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlZE9ic2VydmVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0U3VtbWFyeShzdGF0ZS5zdW1tYXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHN0YXRlLnN1bW1hcnkgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaW5pdGlhbGl6ZU9ic2VydmVyKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlZE9ic2VydmVyID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHF1ZXVlZE9ic2VydmVyLmhlYWQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTsgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIGFsbCByZXN1bHRzIGFuZCBjYWxscyB0aGUgcGFzc2VkIGluIGZ1bmN0aW9uIHdpdGggdGhlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiAqU2hvdWxkIG5vdCBiZSBjb21iaW5lZCB3aXRoIHtAbGluayBSZXN1bHQjc3Vic2NyaWJlfSBmdW5jdGlvbi4qXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHJlc3VsdDoge3JlY29yZHM6QXJyYXk8UmVjb3JkPiwgc3VtbWFyeTogUmVzdWx0U3VtbWFyeX0pfSBvbkZ1bGZpbGxlZCAtIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqIHdoZW4gZmluaXNoZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcjoge21lc3NhZ2U6c3RyaW5nLCBjb2RlOnN0cmluZ30pfSBvblJlamVjdGVkIC0gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHVwb24gZXJyb3JzLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UuXG4gICAgICovXG4gICAgUmVzdWx0LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZVByb21pc2UoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhdGNoIGVycm9ycyB3aGVuIHVzaW5nIHByb21pc2VzLlxuICAgICAqXG4gICAgICogKlNob3VsZCBub3QgYmUgY29tYmluZWQgd2l0aCB7QGxpbmsgUmVzdWx0I3N1YnNjcmliZX0gZnVuY3Rpb24uKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcjogTmVvNGpFcnJvcil9IG9uUmVqZWN0ZWQgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgdXBvbiBlcnJvcnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZS5cbiAgICAgKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlUHJvbWlzZSgpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgUmVzdWx0LnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gKG9uZmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVQcm9taXNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RyZWFtIHJlY29yZHMgdG8gb2JzZXJ2ZXIgYXMgdGhleSBjb21lIGluLCB0aGlzIGlzIGEgbW9yZSBlZmZpY2llbnQgbWV0aG9kXG4gICAgICogb2YgaGFuZGxpbmcgdGhlIHJlc3VsdHMsIGFuZCBhbGxvd3MgeW91IHRvIGhhbmRsZSBhcmJpdHJhcmlseSBsYXJnZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihrZXlzOiBzdHJpbmdbXSl9IG9ic2VydmVyLm9uS2V5cyAtIGhhbmRsZSBzdHJlYW0gaGVhZCwgdGhlIGZpZWxkIGtleXMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihyZWNvcmQ6IFJlY29yZCl9IG9ic2VydmVyLm9uTmV4dCAtIGhhbmRsZSByZWNvcmRzLCBvbmUgYnkgb25lLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3VtbWFyeTogUmVzdWx0U3VtbWFyeSl9IG9ic2VydmVyLm9uQ29tcGxldGVkIC0gaGFuZGxlIHN0cmVhbSB0YWlsLCB0aGUgcmVzdWx0IHN1bW1hcnkuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcjoge21lc3NhZ2U6c3RyaW5nLCBjb2RlOnN0cmluZ30pfSBvYnNlcnZlci5vbkVycm9yIC0gaGFuZGxlIGVycm9ycy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFJlc3VsdC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZShvYnNlcnZlcilcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyByZXN1bHQgaXMgYWN0aXZlLCBpLmUuLCBuZWl0aGVyIGEgc3VtbWFyeSBub3IgYW4gZXJyb3IgaGFzIGJlZW4gcmVjZWl2ZWQgYnkgdGhlIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBuZWl0aGVyIGEgc3VtbWFyeSBvciBub3IgYW4gZXJyb3IgaGFzIGJlZW4gcmVjZWl2ZWQgYnkgdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1bW1hcnkgPT09IG51bGwgJiYgdGhpcy5fZXJyb3IgPT09IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdHJlYW0gcmVjb3JkcyB0byBvYnNlcnZlciBhcyB0aGV5IGNvbWUgaW4sIHRoaXMgaXMgYSBtb3JlIGVmZmljaWVudCBtZXRob2RcbiAgICAgKiBvZiBoYW5kbGluZyB0aGUgcmVzdWx0cywgYW5kIGFsbG93cyB5b3UgdG8gaGFuZGxlIGFyYml0cmFyaWx5IGxhcmdlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1Jlc3VsdE9ic2VydmVyfSBvYnNlcnZlciBUaGUgb2JzZXJ2ZXIgdG8gc2VuZCByZWNvcmRzIHRvLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGF1c2VkIFRoZSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzdHJlYW0gc2hvdWxkIGJlIHN0YXJ0ZWQgcGF1c2VkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8b2JzZXJ2ZXIuUmVzdWx0U3RyZWFtT2JzZXJ2ZXI+fSBUaGUgcmVzdWx0IHN0cmVhbSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHBhdXNlZCkge1xuICAgICAgICBpZiAocGF1c2VkID09PSB2b2lkIDApIHsgcGF1c2VkID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9vYnNlcnZlciA9IHRoaXMuX2RlY29yYXRlT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyZWFtT2JzZXJ2ZXJQcm9taXNlXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgaWYgKHBhdXNlZCkge1xuICAgICAgICAgICAgICAgIG8ucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG8uc3Vic2NyaWJlKF9vYnNlcnZlcik7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChfb2JzZXJ2ZXIub25FcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX29ic2VydmVyLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNvcmF0ZXMgdGhlIFJlc3VsdE9ic2VydmVyIHdpdGggdGhlIG5lY2Vzc2FyeSBtZXRob2RzLlxuICAgICAqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICogQHBhcmFtIHtSZXN1bHRPYnNlcnZlcn0gb2JzZXJ2ZXIgVGhlIFJlc3VsdE9ic2VydmVyIHRvIGRlY29yYXRlLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvcmF0ZWQgcmVzdWx0IG9ic2VydmVyXG4gICAgICovXG4gICAgUmVzdWx0LnByb3RvdHlwZS5fZGVjb3JhdGVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2IsIF9jLCBfZDtcbiAgICAgICAgdmFyIG9uQ29tcGxldGVkT3JpZ2luYWwgPSAoX2IgPSBvYnNlcnZlci5vbkNvbXBsZXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9PTl9DT01QTEVURUQ7XG4gICAgICAgIHZhciBvbkVycm9yT3JpZ2luYWwgPSAoX2MgPSBvYnNlcnZlci5vbkVycm9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX09OX0VSUk9SO1xuICAgICAgICB2YXIgb25LZXlzT3JpZ2luYWwgPSAoX2QgPSBvYnNlcnZlci5vbktleXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IERFRkFVTFRfT05fS0VZUztcbiAgICAgICAgdmFyIG9uQ29tcGxldGVkV3JhcHBlciA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMuX3JlbGVhc2VDb25uZWN0aW9uQW5kR2V0U3VtbWFyeShtZXRhZGF0YSkudGhlbihmdW5jdGlvbiAoc3VtbWFyeSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc3VtbWFyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25Db21wbGV0ZWRPcmlnaW5hbC5jYWxsKG9ic2VydmVyLCBfdGhpcy5fc3VtbWFyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9zdW1tYXJ5ID0gc3VtbWFyeTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25Db21wbGV0ZWRPcmlnaW5hbC5jYWxsKG9ic2VydmVyLCBzdW1tYXJ5KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKG9uRXJyb3JPcmlnaW5hbCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkVycm9yV3JhcHBlciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gbm90aWZ5IGNvbm5lY3Rpb24gaG9sZGVyIHRoYXQgdGhlIHVzZWQgY29ubmVjdGlvbiBpcyBub3QgbmVlZGVkIGFueSBtb3JlIGJlY2F1c2UgZXJyb3IgaGFwcGVuZWRcbiAgICAgICAgICAgIC8vIGFuZCByZXN1bHQgY2FuJ3QgYmVlIGNvbnN1bWVkIGFueSBmdXJ0aGVyOyBjYWxsIHRoZSBvcmlnaW5hbCBvbkVycm9yIGNhbGxiYWNrIGFmdGVyIHRoYXRcbiAgICAgICAgICAgIF90aGlzLl9jb25uZWN0aW9uSG9sZGVyLnJlbGVhc2VDb25uZWN0aW9uKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZVN0YWNrdHJhY2UoZXJyb3IsIF90aGlzLl9zdGFjayk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgb25FcnJvck9yaWdpbmFsLmNhbGwob2JzZXJ2ZXIsIGVycm9yKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKG9uRXJyb3JPcmlnaW5hbCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbktleXNXcmFwcGVyID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIF90aGlzLl9rZXlzID0ga2V5cztcbiAgICAgICAgICAgIHJldHVybiBvbktleXNPcmlnaW5hbC5jYWxsKG9ic2VydmVyLCBrZXlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uTmV4dDogKG9ic2VydmVyLm9uTmV4dCAhPSBudWxsKSA/IG9ic2VydmVyLm9uTmV4dC5iaW5kKG9ic2VydmVyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uS2V5czogb25LZXlzV3JhcHBlcixcbiAgICAgICAgICAgIG9uQ29tcGxldGVkOiBvbkNvbXBsZXRlZFdyYXBwZXIsXG4gICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yV3JhcHBlclxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2lnbmFscyB0aGUgc3RyZWFtIG9ic2VydmVyIHRoYXQgdGhlIGZ1dHVyZSByZWNvcmRzIHNob3VsZCBiZSBkaXNjYXJkZWQgb24gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdW1tYXJ5ID09PSBudWxsICYmIHRoaXMuX2Vycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJlYW1PYnNlcnZlclByb21pc2UudGhlbihmdW5jdGlvbiAobykgeyByZXR1cm4gby5jYW5jZWwoKTsgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBSZXN1bHQucHJvdG90eXBlLl9yZWxlYXNlQ29ubmVjdGlvbkFuZEdldFN1bW1hcnkgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIF9iID0gaW50ZXJuYWxfMS51dGlsLnZhbGlkYXRlUXVlcnlBbmRQYXJhbWV0ZXJzKHRoaXMuX3F1ZXJ5LCB0aGlzLl9wYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICBza2lwQXNzZXJ0czogdHJ1ZVxuICAgICAgICB9KSwgcXVlcnkgPSBfYi52YWxpZGF0ZWRRdWVyeSwgcGFyYW1ldGVycyA9IF9iLnBhcmFtcztcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSB0aGlzLl9jb25uZWN0aW9uSG9sZGVyO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbkhvbGRlclxuICAgICAgICAgICAgLmdldENvbm5lY3Rpb24oKVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgIC8vIG9uRnVsZmlsbGVkOlxuICAgICAgICBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Ib2xkZXJcbiAgICAgICAgICAgICAgICAucmVsZWFzZUNvbm5lY3Rpb24oKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbiA9PT0gbnVsbCB8fCBjb25uZWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmdldFByb3RvY29sVmVyc2lvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIFxuICAgICAgICAvLyBvblJlamVjdGVkOlxuICAgICAgICBmdW5jdGlvbiAoXykgeyByZXR1cm4gdW5kZWZpbmVkOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHByb3RvY29sVmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyByZXN1bHRfc3VtbWFyeV8xLmRlZmF1bHQocXVlcnksIHBhcmFtZXRlcnMsIG1ldGFkYXRhLCBwcm90b2NvbFZlcnNpb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlc3VsdC5wcm90b3R5cGUuX2NyZWF0ZVF1ZXVlZFJlc3VsdE9ic2VydmVyID0gZnVuY3Rpb24gKG9uUXVldWVTaXplQ2hhbmdlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZhYmxlUHJvbWlzZSA9IHt9O1xuICAgICAgICAgICAgcmVzb2x2YWJsZVByb21pc2UucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZhYmxlUHJvbWlzZS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZhYmxlUHJvbWlzZS5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Vycm9yKGVsZW1lbnRPckVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudE9yRXJyb3IgaW5zdGFuY2VvZiBFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXF1ZXVlKCkge1xuICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gKF9iID0gYnVmZmVyLnNoaWZ0KCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnVW5leHBlY3RlZCBlbXB0eSBidWZmZXInLCBlcnJvcl8xLlBST1RPQ09MX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZVNpemVDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBlbGVtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZUhvbGRlci5yZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwcm9taXNlSG9sZGVyLnJlc29sdmFibGUucHJvbWlzZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gW107XG4gICAgICAgIHZhciBwcm9taXNlSG9sZGVyID0geyByZXNvbHZhYmxlOiBudWxsIH07XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgIG9uTmV4dDogZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLl9wdXNoKHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZWNvcmQgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uIChzdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuX3B1c2goeyBkb25lOiB0cnVlLCB2YWx1ZTogc3VtbWFyeSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5fcHVzaChlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3B1c2g6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2VIb2xkZXIucmVzb2x2YWJsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IHByb21pc2VIb2xkZXIucmVzb2x2YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZUhvbGRlci5yZXNvbHZhYmxlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmFibGUucmVqZWN0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgb25RdWV1ZVNpemVDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlcXVldWU6IGRlcXVldWUsXG4gICAgICAgICAgICBkZXF1ZXVlVW50aWxEb25lOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnVlKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBkZXF1ZXVlKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pOyB9LFxuICAgICAgICAgICAgaGVhZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50LCBlbGVtZW50LCBlcnJvcl8zO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gYnVmZmVyWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZWxlbWVudF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VIb2xkZXIucmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgMywgNCwgNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHByb21pc2VIb2xkZXIucmVzb2x2YWJsZS5wcm9taXNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci51bnNoaWZ0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBlbGVtZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8zID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci51bnNoaWZ0KGVycm9yXzMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yXzM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZVNpemVDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTsgfSxcbiAgICAgICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfTtcbiAgICByZXR1cm4gUmVzdWx0O1xufSgpKTtcbl9hID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuZnVuY3Rpb24gY2FwdHVyZVN0YWNrdHJhY2UoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCcnKTtcbiAgICBpZiAoZXJyb3Iuc3RhY2sgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXJyb3Iuc3RhY2sucmVwbGFjZSgvXkVycm9yKFxcblxccikqLywgJycpOyAvLyB3ZSBkb24ndCBuZWVkIHRoZSAnRXJyb3JcXG4nIHBhcnQsIGlmIG9ubHkgaXQgZXhpc3RzXG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ3wgbnVsbH0gbmV3U3RhY2sgVGhlIG5ld1N0YWNrXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZVN0YWNrdHJhY2UoZXJyb3IsIG5ld1N0YWNrKSB7XG4gICAgaWYgKG5ld1N0YWNrICE9IG51bGwpIHtcbiAgICAgICAgLy8gRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nKCkgY29uY2F0ZW5hdGVzIGVycm9yLm5hbWUgYW5kIGVycm9yLm1lc3NhZ2UgbmljZWx5XG4gICAgICAgIC8vIHRoZW4gd2UgYWRkIHRoZSByZXN0IG9mIHRoZSBzdGFjayB0cmFjZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgICAgIGVycm9yLnN0YWNrID0gZXJyb3IudG9TdHJpbmcoKSArICdcXG4nICsgbmV3U3RhY2s7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/result.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/session.js":
/*!*******************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/session.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar observers_1 = __webpack_require__(/*! ./internal/observers */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/observers.js\");\nvar util_1 = __webpack_require__(/*! ./internal/util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\nvar constants_1 = __webpack_require__(/*! ./internal/constants */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/constants.js\");\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar result_1 = __importDefault(__webpack_require__(/*! ./result */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result.js\"));\nvar connection_holder_1 = __webpack_require__(/*! ./internal/connection-holder */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/connection-holder.js\");\nvar transaction_executor_1 = __webpack_require__(/*! ./internal/transaction-executor */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/transaction-executor.js\");\nvar bookmarks_1 = __webpack_require__(/*! ./internal/bookmarks */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/bookmarks.js\");\nvar tx_config_1 = __webpack_require__(/*! ./internal/tx-config */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/tx-config.js\");\nvar transaction_promise_1 = __importDefault(__webpack_require__(/*! ./transaction-promise */ \"(rsc)/./node_modules/neo4j-driver-core/lib/transaction-promise.js\"));\nvar transaction_managed_1 = __importDefault(__webpack_require__(/*! ./transaction-managed */ \"(rsc)/./node_modules/neo4j-driver-core/lib/transaction-managed.js\"));\nvar auth_util_1 = __webpack_require__(/*! ./internal/auth-util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/auth-util.js\");\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\nvar Session = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Object} args\n     * @param {string} args.mode the default access mode for this session.\n     * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n     * @param {Bookmarks} args.bookmarks - The initial bookmarks for this session.\n     * @param {string} args.database the database name\n     * @param {Object} args.config={} - This driver configuration.\n     * @param {boolean} args.reactive - Whether this session should create reactive streams\n     * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n     * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n     * @param {BookmarkManager} args.bookmarkManager - The bookmark manager used for this session.\n     * @param {NotificationFilter} args.notificationFilter - The notification filter used for this session.\n     * @param {AuthToken} args.auth - the target auth for the to-be-acquired connection\n     * @param {Logger} args.log - the logger used for logs in this session.\n     * @param {(user:string, database:string) => void} args.homeDatabaseCallback - callback used to update the home database cache\n     */\n    function Session(_a) {\n        var mode = _a.mode, connectionProvider = _a.connectionProvider, bookmarks = _a.bookmarks, database = _a.database, config = _a.config, reactive = _a.reactive, fetchSize = _a.fetchSize, impersonatedUser = _a.impersonatedUser, bookmarkManager = _a.bookmarkManager, notificationFilter = _a.notificationFilter, auth = _a.auth, log = _a.log, homeDatabaseCallback = _a.homeDatabaseCallback;\n        var _b;\n        this._mode = mode;\n        this._database = database;\n        this._reactive = reactive;\n        this._fetchSize = fetchSize;\n        this._homeDatabaseCallback = homeDatabaseCallback;\n        this._auth = auth;\n        this._getConnectionAcquistionBookmarks = this._getConnectionAcquistionBookmarks.bind(this);\n        this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n            mode: constants_1.ACCESS_MODE_READ,\n            auth: auth,\n            database: database,\n            bookmarks: bookmarks,\n            connectionProvider: connectionProvider,\n            impersonatedUser: impersonatedUser,\n            onDatabaseNameResolved: this._onDatabaseNameResolved.bind(this),\n            getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n            log: log\n        });\n        this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n            mode: constants_1.ACCESS_MODE_WRITE,\n            auth: auth,\n            database: database,\n            bookmarks: bookmarks,\n            connectionProvider: connectionProvider,\n            impersonatedUser: impersonatedUser,\n            onDatabaseNameResolved: this._onDatabaseNameResolved.bind(this),\n            getConnectionAcquistionBookmarks: this._getConnectionAcquistionBookmarks,\n            log: log\n        });\n        this._open = true;\n        this._hasTx = false;\n        this._impersonatedUser = impersonatedUser;\n        this._lastBookmarks = bookmarks !== null && bookmarks !== void 0 ? bookmarks : bookmarks_1.Bookmarks.empty();\n        this._configuredBookmarks = this._lastBookmarks;\n        this._transactionExecutor = _createTransactionExecutor(config);\n        this._databaseNameResolved = this._database !== '';\n        var calculatedWatermaks = this._calculateWatermaks();\n        this._lowRecordWatermark = calculatedWatermaks.low;\n        this._highRecordWatermark = calculatedWatermaks.high;\n        this._results = [];\n        this._bookmarkManager = bookmarkManager;\n        this._notificationFilter = notificationFilter;\n        this._log = log;\n        this._databaseGuess = config === null || config === void 0 ? void 0 : config.cachedHomeDatabase;\n        this._isRoutingSession = (_b = config === null || config === void 0 ? void 0 : config.routingDriver) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n     * Run Cypher query\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the query and parameters as separate arguments.\n     *\n     * @public\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @return {Result} New Result.\n     */\n    Session.prototype.run = function (query, parameters, transactionConfig) {\n        var _this = this;\n        var _a = (0, util_1.validateQueryAndParameters)(query, parameters), validatedQuery = _a.validatedQuery, params = _a.params;\n        var autoCommitTxConfig = (transactionConfig != null)\n            ? new tx_config_1.TxConfig(transactionConfig, this._log)\n            : tx_config_1.TxConfig.empty();\n        var result = this._run(validatedQuery, params, function (connection) { return __awaiter(_this, void 0, void 0, function () {\n            var bookmarks;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._bookmarks()];\n                    case 1:\n                        bookmarks = _a.sent();\n                        this._assertSessionIsOpen();\n                        return [2 /*return*/, connection.run(validatedQuery, params, {\n                                bookmarks: bookmarks,\n                                txConfig: autoCommitTxConfig,\n                                mode: this._mode,\n                                database: this._database,\n                                apiTelemetryConfig: {\n                                    api: constants_1.TELEMETRY_APIS.AUTO_COMMIT_TRANSACTION\n                                },\n                                impersonatedUser: this._impersonatedUser,\n                                afterComplete: function (meta) { return _this._onCompleteCallback(meta, bookmarks); },\n                                reactive: this._reactive,\n                                fetchSize: this._fetchSize,\n                                lowRecordWatermark: this._lowRecordWatermark,\n                                highRecordWatermark: this._highRecordWatermark,\n                                notificationFilter: this._notificationFilter,\n                                onDb: this._onDatabaseNameResolved.bind(this)\n                            })];\n                }\n            });\n        }); });\n        this._results.push(result);\n        return result;\n    };\n    Session.prototype._run = function (query, parameters, customRunner) {\n        var _a = this._acquireAndConsumeConnection(customRunner), connectionHolder = _a.connectionHolder, resultPromise = _a.resultPromise;\n        var observerPromise = resultPromise.catch(function (error) { return Promise.resolve(new observers_1.FailedObserver({ error: error })); });\n        var watermarks = { high: this._highRecordWatermark, low: this._lowRecordWatermark };\n        return new result_1.default(observerPromise, query, parameters, connectionHolder, watermarks);\n    };\n    /**\n     * This method is used by Rediscovery on the neo4j-driver-bolt-protocol package.\n     *\n     * @private\n     * @param {function()} connectionConsumer The method which will use the connection\n     * @returns {Promise<T>} A connection promise\n     */\n    Session.prototype._acquireConnection = function (connectionConsumer) {\n        var _this = this;\n        var _a = this._acquireAndConsumeConnection(connectionConsumer), connectionHolder = _a.connectionHolder, resultPromise = _a.resultPromise;\n        return resultPromise.then(function (result) { return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, connectionHolder.releaseConnection()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, result];\n                }\n            });\n        }); });\n    };\n    /**\n     * Acquires a {@link Connection}, consume it and return a promise of the result along with\n     * the {@link ConnectionHolder} used in the process.\n     *\n     * @private\n     * @param connectionConsumer\n     * @returns {object} The connection holder and connection promise.\n     */\n    Session.prototype._acquireAndConsumeConnection = function (connectionConsumer) {\n        var resultPromise;\n        var connectionHolder = this._connectionHolderWithMode(this._mode);\n        if (!this._open) {\n            resultPromise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n        }\n        else if (!this._hasTx && connectionHolder.initializeConnection(this._databaseGuess)) {\n            resultPromise = connectionHolder\n                .getConnection()\n                // Connection won't be null at this point since the initialize method\n                // return\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                .then(function (connection) { return connectionConsumer(connection); });\n        }\n        else {\n            resultPromise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' +\n                'session with an open transaction; either run from within the ' +\n                'transaction or use a different session.'));\n        }\n        return { connectionHolder: connectionHolder, resultPromise: resultPromise };\n    };\n    /**\n     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n     *\n     * While a transaction is open the session cannot be used to run queries outside the transaction.\n     *\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @returns {TransactionPromise} New Transaction.\n     */\n    Session.prototype.beginTransaction = function (transactionConfig) {\n        // this function needs to support bookmarks parameter for backwards compatibility\n        // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n        // that's why we need to check parameter type and decide how to interpret the value\n        var arg = transactionConfig;\n        var txConfig = tx_config_1.TxConfig.empty();\n        if (arg != null) {\n            txConfig = new tx_config_1.TxConfig(arg, this._log);\n        }\n        return this._beginTransaction(this._mode, txConfig, { api: constants_1.TELEMETRY_APIS.UNMANAGED_TRANSACTION });\n    };\n    Session.prototype._beginTransaction = function (accessMode, txConfig, apiTelemetryConfig) {\n        var _this = this;\n        if (!this._open) {\n            throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n        }\n        if (this._hasTx) {\n            throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' +\n                'either run from within the transaction or use a different session.');\n        }\n        var mode = Session._validateSessionMode(accessMode);\n        var connectionHolder = this._connectionHolderWithMode(mode);\n        connectionHolder.initializeConnection(this._databaseGuess);\n        this._hasTx = true;\n        var tx = new transaction_promise_1.default({\n            connectionHolder: connectionHolder,\n            impersonatedUser: this._impersonatedUser,\n            onClose: this._transactionClosed.bind(this),\n            onBookmarks: function (newBm, oldBm, db) { return _this._updateBookmarks(newBm, oldBm, db); },\n            onConnection: this._assertSessionIsOpen.bind(this),\n            reactive: this._reactive,\n            fetchSize: this._fetchSize,\n            lowRecordWatermark: this._lowRecordWatermark,\n            highRecordWatermark: this._highRecordWatermark,\n            notificationFilter: this._notificationFilter,\n            apiTelemetryConfig: apiTelemetryConfig,\n            onDbCallback: this._onDatabaseNameResolved.bind(this)\n        });\n        tx._begin(function () { return _this._bookmarks(); }, txConfig);\n        return tx;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._assertSessionIsOpen = function () {\n        if (!this._open) {\n            throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._transactionClosed = function () {\n        this._hasTx = false;\n    };\n    /**\n     * Return the bookmarks received following the last completed {@link Transaction}.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use {@link Session#lastBookmarks} instead.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     * @see {@link Session#lastBookmarks}\n     */\n    Session.prototype.lastBookmark = function () {\n        return this.lastBookmarks();\n    };\n    /**\n     * Return the bookmarks received following the last completed {@link Transaction}.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     */\n    Session.prototype.lastBookmarks = function () {\n        return this._lastBookmarks.values();\n    };\n    Session.prototype._bookmarks = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarks;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, ((_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks())];\n                    case 1:\n                        bookmarks = _b.sent();\n                        if (bookmarks === undefined) {\n                            return [2 /*return*/, this._lastBookmarks];\n                        }\n                        return [2 /*return*/, new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(bookmarks), false), __read(this._configuredBookmarks), false))];\n                }\n            });\n        });\n    };\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use {@link Session#executeRead} instead.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     * @see {@link Session#executeRead}\n     */\n    Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @deprecated This method will be removed in version 6.0. Please, use {@link Session#executeWrite} instead.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     * @see {@link Session#executeWrite}\n     */\n    Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n    };\n    Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n        var _this = this;\n        return this._transactionExecutor.execute(function (apiTelemetryConfig) { return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig); }, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n     * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n     * {@link Session#run} for these).\n     *\n     * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n    Session.prototype.executeRead = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._executeInTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * NOTE: Because it is an explicit transaction from the server point of view, Cypher queries using\n     * \"CALL {} IN TRANSACTIONS\" or the older \"USING PERIODIC COMMIT\" construct will not work (call\n     * {@link Session#run} for these).\n     *\n     * @param {function(tx: ManagedTransaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n    Session.prototype.executeWrite = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig, this._log);\n        return this._executeInTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n    };\n    /**\n     * @private\n     * @param {SessionMode} accessMode\n     * @param {TxConfig} transactionConfig\n     * @param {ManagedTransactionWork} transactionWork\n     * @returns {Promise}\n     */\n    Session.prototype._executeInTransaction = function (accessMode, transactionConfig, transactionWork) {\n        var _this = this;\n        return this._transactionExecutor.execute(function (apiTelemetryConfig) { return _this._beginTransaction(accessMode, transactionConfig, apiTelemetryConfig); }, transactionWork, transaction_managed_1.default.fromTransaction);\n    };\n    /**\n     * Sets the resolved database name in the session context.\n     * @private\n     * @param {string|undefined} database The resolved database name\n     * @returns {void}\n     */\n    Session.prototype._onDatabaseNameResolved = function (database) {\n        if (this._isRoutingSession) {\n            this._databaseGuess = database;\n            if (!this._databaseNameResolved) {\n                var normalizedDatabase = database !== null && database !== void 0 ? database : '';\n                this._database = normalizedDatabase;\n                this._readConnectionHolder.setDatabase(normalizedDatabase);\n                this._writeConnectionHolder.setDatabase(normalizedDatabase);\n                this._databaseNameResolved = true;\n                if (this._homeDatabaseCallback != null) {\n                    this._homeDatabaseCallback((0, auth_util_1.cacheKey)(this._auth, this._impersonatedUser), database);\n                }\n            }\n        }\n    };\n    Session.prototype._getConnectionAcquistionBookmarks = function () {\n        var _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var bookmarks;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, ((_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.getBookmarks())];\n                    case 1:\n                        bookmarks = _b.sent();\n                        if (bookmarks === undefined) {\n                            return [2 /*return*/, this._lastBookmarks];\n                        }\n                        return [2 /*return*/, new bookmarks_1.Bookmarks(__spreadArray(__spreadArray([], __read(this._configuredBookmarks), false), __read(bookmarks), false))];\n                }\n            });\n        });\n    };\n    /**\n     * Update value of the last bookmarks.\n     * @private\n     * @param {Bookmarks} newBookmarks - The new bookmarks.\n     * @returns {void}\n     */\n    Session.prototype._updateBookmarks = function (newBookmarks, previousBookmarks, database) {\n        var _a, _b, _c;\n        if ((newBookmarks != null) && !newBookmarks.isEmpty()) {\n            (_a = this._bookmarkManager) === null || _a === void 0 ? void 0 : _a.updateBookmarks((_b = previousBookmarks === null || previousBookmarks === void 0 ? void 0 : previousBookmarks.values()) !== null && _b !== void 0 ? _b : [], (_c = newBookmarks === null || newBookmarks === void 0 ? void 0 : newBookmarks.values()) !== null && _c !== void 0 ? _c : []).catch(function () { });\n            this._lastBookmarks = newBookmarks;\n            this._configuredBookmarks = bookmarks_1.Bookmarks.empty();\n        }\n    };\n    /**\n     * Close this session.\n     * @return {Promise}\n     */\n    Session.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this._open) return [3 /*break*/, 3];\n                        this._open = false;\n                        this._results.forEach(function (result) { return result._cancel(); });\n                        this._transactionExecutor.close();\n                        return [4 /*yield*/, this._readConnectionHolder.close(this._hasTx)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this._writeConnectionHolder.close(this._hasTx)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // eslint-disable-next-line\n    // @ts-ignore\n    Session.prototype[Symbol.asyncDispose] = function () {\n        return this.close();\n    };\n    Session.prototype._connectionHolderWithMode = function (mode) {\n        if (mode === constants_1.ACCESS_MODE_READ) {\n            return this._readConnectionHolder;\n        }\n        else if (mode === constants_1.ACCESS_MODE_WRITE) {\n            return this._writeConnectionHolder;\n        }\n        else {\n            throw (0, error_1.newError)('Unknown access mode: ' + mode);\n        }\n    };\n    /**\n     * @private\n     * @param {Object} meta Connection metadatada\n     * @returns {void}\n     */\n    Session.prototype._onCompleteCallback = function (meta, previousBookmarks) {\n        this._updateBookmarks(new bookmarks_1.Bookmarks(meta.bookmark), previousBookmarks, meta.db);\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._calculateWatermaks = function () {\n        if (this._fetchSize === constants_1.FETCH_ALL) {\n            return {\n                low: Number.MAX_VALUE,\n                high: Number.MAX_VALUE // we shall never reach this number to disable auto pull\n            };\n        }\n        return {\n            low: 0.3 * this._fetchSize,\n            high: 0.7 * this._fetchSize\n        };\n    };\n    /**\n     * Configure the transaction executor\n     *\n     * This used by {@link Driver#executeQuery}\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._configureTransactionExecutor = function (pipelined, telemetryApi) {\n        this._transactionExecutor.pipelineBegin = pipelined;\n        this._transactionExecutor.telemetryApi = telemetryApi;\n    };\n    /**\n     * @protected\n     */\n    Session._validateSessionMode = function (rawMode) {\n        var mode = rawMode !== null && rawMode !== void 0 ? rawMode : constants_1.ACCESS_MODE_WRITE;\n        if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n            throw (0, error_1.newError)('Illegal session mode ' + mode);\n        }\n        return mode;\n    };\n    return Session;\n}());\n/**\n * @private\n * @param {object} config\n * @returns {TransactionExecutor} The transaction executor\n */\nfunction _createTransactionExecutor(config) {\n    var _a;\n    var maxRetryTimeMs = (_a = config === null || config === void 0 ? void 0 : config.maxTransactionRetryTime) !== null && _a !== void 0 ? _a : null;\n    return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\nexports[\"default\"] = Session;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3Nlc3Npb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNB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V0FBVztBQUMxQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpWUFBaVk7QUFDalk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMEJBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi9zZXNzaW9uLmpzPzE5N2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Byb21pc2UtZnVuY3Rpb24tYXN5bmMgKi9cbnZhciBvYnNlcnZlcnNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL29ic2VydmVyc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC91dGlsXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvY29uc3RhbnRzXCIpO1xudmFyIGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbnZhciByZXN1bHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHRcIikpO1xudmFyIGNvbm5lY3Rpb25faG9sZGVyXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9jb25uZWN0aW9uLWhvbGRlclwiKTtcbnZhciB0cmFuc2FjdGlvbl9leGVjdXRvcl8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvdHJhbnNhY3Rpb24tZXhlY3V0b3JcIik7XG52YXIgYm9va21hcmtzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9ib29rbWFya3NcIik7XG52YXIgdHhfY29uZmlnXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC90eC1jb25maWdcIik7XG52YXIgdHJhbnNhY3Rpb25fcHJvbWlzZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXByb21pc2VcIikpO1xudmFyIHRyYW5zYWN0aW9uX21hbmFnZWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi1tYW5hZ2VkXCIpKTtcbnZhciBhdXRoX3V0aWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2F1dGgtdXRpbFwiKTtcbi8qKlxuICogQSBTZXNzaW9uIGluc3RhbmNlIGlzIHVzZWQgZm9yIGhhbmRsaW5nIHRoZSBjb25uZWN0aW9uIGFuZFxuICogc2VuZGluZyBxdWVyaWVzIHRocm91Z2ggdGhlIGNvbm5lY3Rpb24uXG4gKiBJbiBhIHNpbmdsZSBzZXNzaW9uLCBtdWx0aXBsZSBxdWVyaWVzIHdpbGwgYmUgZXhlY3V0ZWQgc2VyaWFsbHkuXG4gKiBJbiBvcmRlciB0byBleGVjdXRlIHBhcmFsbGVsIHF1ZXJpZXMsIG11bHRpcGxlIHNlc3Npb25zIGFyZSByZXF1aXJlZC5cbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cbnZhciBTZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm1vZGUgdGhlIGRlZmF1bHQgYWNjZXNzIG1vZGUgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25Qcm92aWRlcn0gYXJncy5jb25uZWN0aW9uUHJvdmlkZXIgLSBUaGUgY29ubmVjdGlvbiBwcm92aWRlciB0byBhY3F1aXJlIGNvbm5lY3Rpb25zIGZyb20uXG4gICAgICogQHBhcmFtIHtCb29rbWFya3N9IGFyZ3MuYm9va21hcmtzIC0gVGhlIGluaXRpYWwgYm9va21hcmtzIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGF0YWJhc2UgdGhlIGRhdGFiYXNlIG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncy5jb25maWc9e30gLSBUaGlzIGRyaXZlciBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5yZWFjdGl2ZSAtIFdoZXRoZXIgdGhpcyBzZXNzaW9uIHNob3VsZCBjcmVhdGUgcmVhY3RpdmUgc3RyZWFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmZldGNoU2l6ZSAtIERlZmluZXMgaG93IG1hbnkgcmVjb3JkcyBpcyBwdWxsZWQgaW4gZWFjaCBwdWxsaW5nIGJhdGNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuaW1wZXJzb25hdGVkVXNlciAtIFRoZSB1c2VybmFtZSB3aGljaCB0aGUgdXNlciB3YW50cyB0byBpbXBlcnNvbmF0ZSBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBzZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7Qm9va21hcmtNYW5hZ2VyfSBhcmdzLmJvb2ttYXJrTWFuYWdlciAtIFRoZSBib29rbWFyayBtYW5hZ2VyIHVzZWQgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0ge05vdGlmaWNhdGlvbkZpbHRlcn0gYXJncy5ub3RpZmljYXRpb25GaWx0ZXIgLSBUaGUgbm90aWZpY2F0aW9uIGZpbHRlciB1c2VkIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICogQHBhcmFtIHtBdXRoVG9rZW59IGFyZ3MuYXV0aCAtIHRoZSB0YXJnZXQgYXV0aCBmb3IgdGhlIHRvLWJlLWFjcXVpcmVkIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge0xvZ2dlcn0gYXJncy5sb2cgLSB0aGUgbG9nZ2VyIHVzZWQgZm9yIGxvZ3MgaW4gdGhpcyBzZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7KHVzZXI6c3RyaW5nLCBkYXRhYmFzZTpzdHJpbmcpID0+IHZvaWR9IGFyZ3MuaG9tZURhdGFiYXNlQ2FsbGJhY2sgLSBjYWxsYmFjayB1c2VkIHRvIHVwZGF0ZSB0aGUgaG9tZSBkYXRhYmFzZSBjYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlc3Npb24oX2EpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBfYS5tb2RlLCBjb25uZWN0aW9uUHJvdmlkZXIgPSBfYS5jb25uZWN0aW9uUHJvdmlkZXIsIGJvb2ttYXJrcyA9IF9hLmJvb2ttYXJrcywgZGF0YWJhc2UgPSBfYS5kYXRhYmFzZSwgY29uZmlnID0gX2EuY29uZmlnLCByZWFjdGl2ZSA9IF9hLnJlYWN0aXZlLCBmZXRjaFNpemUgPSBfYS5mZXRjaFNpemUsIGltcGVyc29uYXRlZFVzZXIgPSBfYS5pbXBlcnNvbmF0ZWRVc2VyLCBib29rbWFya01hbmFnZXIgPSBfYS5ib29rbWFya01hbmFnZXIsIG5vdGlmaWNhdGlvbkZpbHRlciA9IF9hLm5vdGlmaWNhdGlvbkZpbHRlciwgYXV0aCA9IF9hLmF1dGgsIGxvZyA9IF9hLmxvZywgaG9tZURhdGFiYXNlQ2FsbGJhY2sgPSBfYS5ob21lRGF0YWJhc2VDYWxsYmFjaztcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5fZGF0YWJhc2UgPSBkYXRhYmFzZTtcbiAgICAgICAgdGhpcy5fcmVhY3RpdmUgPSByZWFjdGl2ZTtcbiAgICAgICAgdGhpcy5fZmV0Y2hTaXplID0gZmV0Y2hTaXplO1xuICAgICAgICB0aGlzLl9ob21lRGF0YWJhc2VDYWxsYmFjayA9IGhvbWVEYXRhYmFzZUNhbGxiYWNrO1xuICAgICAgICB0aGlzLl9hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy5fZ2V0Q29ubmVjdGlvbkFjcXVpc3Rpb25Cb29rbWFya3MgPSB0aGlzLl9nZXRDb25uZWN0aW9uQWNxdWlzdGlvbkJvb2ttYXJrcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWFkQ29ubmVjdGlvbkhvbGRlciA9IG5ldyBjb25uZWN0aW9uX2hvbGRlcl8xLkNvbm5lY3Rpb25Ib2xkZXIoe1xuICAgICAgICAgICAgbW9kZTogY29uc3RhbnRzXzEuQUNDRVNTX01PREVfUkVBRCxcbiAgICAgICAgICAgIGF1dGg6IGF1dGgsXG4gICAgICAgICAgICBkYXRhYmFzZTogZGF0YWJhc2UsXG4gICAgICAgICAgICBib29rbWFya3M6IGJvb2ttYXJrcyxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qcm92aWRlcjogY29ubmVjdGlvblByb3ZpZGVyLFxuICAgICAgICAgICAgaW1wZXJzb25hdGVkVXNlcjogaW1wZXJzb25hdGVkVXNlcixcbiAgICAgICAgICAgIG9uRGF0YWJhc2VOYW1lUmVzb2x2ZWQ6IHRoaXMuX29uRGF0YWJhc2VOYW1lUmVzb2x2ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzOiB0aGlzLl9nZXRDb25uZWN0aW9uQWNxdWlzdGlvbkJvb2ttYXJrcyxcbiAgICAgICAgICAgIGxvZzogbG9nXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl93cml0ZUNvbm5lY3Rpb25Ib2xkZXIgPSBuZXcgY29ubmVjdGlvbl9ob2xkZXJfMS5Db25uZWN0aW9uSG9sZGVyKHtcbiAgICAgICAgICAgIG1vZGU6IGNvbnN0YW50c18xLkFDQ0VTU19NT0RFX1dSSVRFLFxuICAgICAgICAgICAgYXV0aDogYXV0aCxcbiAgICAgICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZSxcbiAgICAgICAgICAgIGJvb2ttYXJrczogYm9va21hcmtzLFxuICAgICAgICAgICAgY29ubmVjdGlvblByb3ZpZGVyOiBjb25uZWN0aW9uUHJvdmlkZXIsXG4gICAgICAgICAgICBpbXBlcnNvbmF0ZWRVc2VyOiBpbXBlcnNvbmF0ZWRVc2VyLFxuICAgICAgICAgICAgb25EYXRhYmFzZU5hbWVSZXNvbHZlZDogdGhpcy5fb25EYXRhYmFzZU5hbWVSZXNvbHZlZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0Q29ubmVjdGlvbkFjcXVpc3Rpb25Cb29rbWFya3M6IHRoaXMuX2dldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzLFxuICAgICAgICAgICAgbG9nOiBsb2dcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYXNUeCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbXBlcnNvbmF0ZWRVc2VyID0gaW1wZXJzb25hdGVkVXNlcjtcbiAgICAgICAgdGhpcy5fbGFzdEJvb2ttYXJrcyA9IGJvb2ttYXJrcyAhPT0gbnVsbCAmJiBib29rbWFya3MgIT09IHZvaWQgMCA/IGJvb2ttYXJrcyA6IGJvb2ttYXJrc18xLkJvb2ttYXJrcy5lbXB0eSgpO1xuICAgICAgICB0aGlzLl9jb25maWd1cmVkQm9va21hcmtzID0gdGhpcy5fbGFzdEJvb2ttYXJrcztcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25FeGVjdXRvciA9IF9jcmVhdGVUcmFuc2FjdGlvbkV4ZWN1dG9yKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2RhdGFiYXNlTmFtZVJlc29sdmVkID0gdGhpcy5fZGF0YWJhc2UgIT09ICcnO1xuICAgICAgICB2YXIgY2FsY3VsYXRlZFdhdGVybWFrcyA9IHRoaXMuX2NhbGN1bGF0ZVdhdGVybWFrcygpO1xuICAgICAgICB0aGlzLl9sb3dSZWNvcmRXYXRlcm1hcmsgPSBjYWxjdWxhdGVkV2F0ZXJtYWtzLmxvdztcbiAgICAgICAgdGhpcy5faGlnaFJlY29yZFdhdGVybWFyayA9IGNhbGN1bGF0ZWRXYXRlcm1ha3MuaGlnaDtcbiAgICAgICAgdGhpcy5fcmVzdWx0cyA9IFtdO1xuICAgICAgICB0aGlzLl9ib29rbWFya01hbmFnZXIgPSBib29rbWFya01hbmFnZXI7XG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvbkZpbHRlciA9IG5vdGlmaWNhdGlvbkZpbHRlcjtcbiAgICAgICAgdGhpcy5fbG9nID0gbG9nO1xuICAgICAgICB0aGlzLl9kYXRhYmFzZUd1ZXNzID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmNhY2hlZEhvbWVEYXRhYmFzZTtcbiAgICAgICAgdGhpcy5faXNSb3V0aW5nU2Vzc2lvbiA9IChfYiA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5yb3V0aW5nRHJpdmVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIEN5cGhlciBxdWVyeVxuICAgICAqIENvdWxkIGJlIGNhbGxlZCB3aXRoIGEgcXVlcnkgb2JqZWN0IGkuZS46IGB7dGV4dDogXCJNQVRDSCAuLi5cIiwgcGFyYW1ldGVyczoge3BhcmFtOiAxfX1gXG4gICAgICogb3Igd2l0aCB0aGUgcXVlcnkgYW5kIHBhcmFtZXRlcnMgYXMgc2VwYXJhdGUgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7bWl4ZWR9IHF1ZXJ5IC0gQ3lwaGVyIHF1ZXJ5IHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE1hcCB3aXRoIHBhcmFtZXRlcnMgdG8gdXNlIGluIHF1ZXJ5XG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gW3RyYW5zYWN0aW9uQ29uZmlnXSAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBuZXcgYXV0by1jb21taXQgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybiB7UmVzdWx0fSBOZXcgUmVzdWx0LlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChxdWVyeSwgcGFyYW1ldGVycywgdHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gKDAsIHV0aWxfMS52YWxpZGF0ZVF1ZXJ5QW5kUGFyYW1ldGVycykocXVlcnksIHBhcmFtZXRlcnMpLCB2YWxpZGF0ZWRRdWVyeSA9IF9hLnZhbGlkYXRlZFF1ZXJ5LCBwYXJhbXMgPSBfYS5wYXJhbXM7XG4gICAgICAgIHZhciBhdXRvQ29tbWl0VHhDb25maWcgPSAodHJhbnNhY3Rpb25Db25maWcgIT0gbnVsbClcbiAgICAgICAgICAgID8gbmV3IHR4X2NvbmZpZ18xLlR4Q29uZmlnKHRyYW5zYWN0aW9uQ29uZmlnLCB0aGlzLl9sb2cpXG4gICAgICAgICAgICA6IHR4X2NvbmZpZ18xLlR4Q29uZmlnLmVtcHR5KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9ydW4odmFsaWRhdGVkUXVlcnksIHBhcmFtcywgZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib29rbWFya3M7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9ib29rbWFya3MoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2ttYXJrcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fzc2VydFNlc3Npb25Jc09wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjb25uZWN0aW9uLnJ1bih2YWxpZGF0ZWRRdWVyeSwgcGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2ttYXJrczogYm9va21hcmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eENvbmZpZzogYXV0b0NvbW1pdFR4Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLl9tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZTogdGhpcy5fZGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVRlbGVtZXRyeUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpOiBjb25zdGFudHNfMS5URUxFTUVUUllfQVBJUy5BVVRPX0NPTU1JVF9UUkFOU0FDVElPTlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBlcnNvbmF0ZWRVc2VyOiB0aGlzLl9pbXBlcnNvbmF0ZWRVc2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckNvbXBsZXRlOiBmdW5jdGlvbiAobWV0YSkgeyByZXR1cm4gX3RoaXMuX29uQ29tcGxldGVDYWxsYmFjayhtZXRhLCBib29rbWFya3MpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFjdGl2ZTogdGhpcy5fcmVhY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoU2l6ZTogdGhpcy5fZmV0Y2hTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dSZWNvcmRXYXRlcm1hcms6IHRoaXMuX2xvd1JlY29yZFdhdGVybWFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFJlY29yZFdhdGVybWFyazogdGhpcy5faGlnaFJlY29yZFdhdGVybWFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uRmlsdGVyOiB0aGlzLl9ub3RpZmljYXRpb25GaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRGI6IHRoaXMuX29uRGF0YWJhc2VOYW1lUmVzb2x2ZWQuYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICB0aGlzLl9yZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLl9ydW4gPSBmdW5jdGlvbiAocXVlcnksIHBhcmFtZXRlcnMsIGN1c3RvbVJ1bm5lcikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9hY3F1aXJlQW5kQ29uc3VtZUNvbm5lY3Rpb24oY3VzdG9tUnVubmVyKSwgY29ubmVjdGlvbkhvbGRlciA9IF9hLmNvbm5lY3Rpb25Ib2xkZXIsIHJlc3VsdFByb21pc2UgPSBfYS5yZXN1bHRQcm9taXNlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJQcm9taXNlID0gcmVzdWx0UHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgb2JzZXJ2ZXJzXzEuRmFpbGVkT2JzZXJ2ZXIoeyBlcnJvcjogZXJyb3IgfSkpOyB9KTtcbiAgICAgICAgdmFyIHdhdGVybWFya3MgPSB7IGhpZ2g6IHRoaXMuX2hpZ2hSZWNvcmRXYXRlcm1hcmssIGxvdzogdGhpcy5fbG93UmVjb3JkV2F0ZXJtYXJrIH07XG4gICAgICAgIHJldHVybiBuZXcgcmVzdWx0XzEuZGVmYXVsdChvYnNlcnZlclByb21pc2UsIHF1ZXJ5LCBwYXJhbWV0ZXJzLCBjb25uZWN0aW9uSG9sZGVyLCB3YXRlcm1hcmtzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgUmVkaXNjb3Zlcnkgb24gdGhlIG5lbzRqLWRyaXZlci1ib2x0LXByb3RvY29sIHBhY2thZ2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY29ubmVjdGlvbkNvbnN1bWVyIFRoZSBtZXRob2Qgd2hpY2ggd2lsbCB1c2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUPn0gQSBjb25uZWN0aW9uIHByb21pc2VcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fYWNxdWlyZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoY29ubmVjdGlvbkNvbnN1bWVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2FjcXVpcmVBbmRDb25zdW1lQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uc3VtZXIpLCBjb25uZWN0aW9uSG9sZGVyID0gX2EuY29ubmVjdGlvbkhvbGRlciwgcmVzdWx0UHJvbWlzZSA9IF9hLnJlc3VsdFByb21pc2U7XG4gICAgICAgIHJldHVybiByZXN1bHRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBjb25uZWN0aW9uSG9sZGVyLnJlbGVhc2VDb25uZWN0aW9uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSB7QGxpbmsgQ29ubmVjdGlvbn0sIGNvbnN1bWUgaXQgYW5kIHJldHVybiBhIHByb21pc2Ugb2YgdGhlIHJlc3VsdCBhbG9uZyB3aXRoXG4gICAgICogdGhlIHtAbGluayBDb25uZWN0aW9uSG9sZGVyfSB1c2VkIGluIHRoZSBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkNvbnN1bWVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIGNvbm5lY3Rpb24gaG9sZGVyIGFuZCBjb25uZWN0aW9uIHByb21pc2UuXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX2FjcXVpcmVBbmRDb25zdW1lQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjb25uZWN0aW9uQ29uc3VtZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdFByb21pc2U7XG4gICAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gdGhpcy5fY29ubmVjdGlvbkhvbGRlcldpdGhNb2RlKHRoaXMuX21vZGUpO1xuICAgICAgICBpZiAoIXRoaXMuX29wZW4pIHtcbiAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSBQcm9taXNlLnJlamVjdCgoMCwgZXJyb3JfMS5uZXdFcnJvcikoJ0Nhbm5vdCBydW4gcXVlcnkgaW4gYSBjbG9zZWQgc2Vzc2lvbi4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hhc1R4ICYmIGNvbm5lY3Rpb25Ib2xkZXIuaW5pdGlhbGl6ZUNvbm5lY3Rpb24odGhpcy5fZGF0YWJhc2VHdWVzcykpIHtcbiAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSBjb25uZWN0aW9uSG9sZGVyXG4gICAgICAgICAgICAgICAgLmdldENvbm5lY3Rpb24oKVxuICAgICAgICAgICAgICAgIC8vIENvbm5lY3Rpb24gd29uJ3QgYmUgbnVsbCBhdCB0aGlzIHBvaW50IHNpbmNlIHRoZSBpbml0aWFsaXplIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHsgcmV0dXJuIGNvbm5lY3Rpb25Db25zdW1lcihjb25uZWN0aW9uKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRQcm9taXNlID0gUHJvbWlzZS5yZWplY3QoKDAsIGVycm9yXzEubmV3RXJyb3IpKCdRdWVyaWVzIGNhbm5vdCBiZSBydW4gZGlyZWN0bHkgb24gYSAnICtcbiAgICAgICAgICAgICAgICAnc2Vzc2lvbiB3aXRoIGFuIG9wZW4gdHJhbnNhY3Rpb247IGVpdGhlciBydW4gZnJvbSB3aXRoaW4gdGhlICcgK1xuICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbiBvciB1c2UgYSBkaWZmZXJlbnQgc2Vzc2lvbi4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY29ubmVjdGlvbkhvbGRlcjogY29ubmVjdGlvbkhvbGRlciwgcmVzdWx0UHJvbWlzZTogcmVzdWx0UHJvbWlzZSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQmVnaW4gYSBuZXcgdHJhbnNhY3Rpb24gaW4gdGhpcyBzZXNzaW9uLiBBIHNlc3Npb24gY2FuIGhhdmUgYXQgbW9zdCBvbmUgdHJhbnNhY3Rpb24gcnVubmluZyBhdCBhIHRpbWUsIGlmIHlvdVxuICAgICAqIHdhbnQgdG8gcnVuIG11bHRpcGxlIGNvbmN1cnJlbnQgdHJhbnNhY3Rpb25zLCB5b3Ugc2hvdWxkIHVzZSBtdWx0aXBsZSBjb25jdXJyZW50IHNlc3Npb25zLlxuICAgICAqXG4gICAgICogV2hpbGUgYSB0cmFuc2FjdGlvbiBpcyBvcGVuIHRoZSBzZXNzaW9uIGNhbm5vdCBiZSB1c2VkIHRvIHJ1biBxdWVyaWVzIG91dHNpZGUgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gW3RyYW5zYWN0aW9uQ29uZmlnXSAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBuZXcgYXV0by1jb21taXQgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9uUHJvbWlzZX0gTmV3IFRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmJlZ2luVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25Db25maWcpIHtcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBzdXBwb3J0IGJvb2ttYXJrcyBwYXJhbWV0ZXIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIC8vIHBhcmFtZXRlciB3YXMgb2YgdHlwZSB7c3RyaW5nfHN0cmluZ1tdfSBhbmQgcmVwcmVzZW50ZWQgZWl0aGVyIGEgc2luZ2xlIG9yIG11bHRpcGxlIGJvb2ttYXJrc1xuICAgICAgICAvLyB0aGF0J3Mgd2h5IHdlIG5lZWQgdG8gY2hlY2sgcGFyYW1ldGVyIHR5cGUgYW5kIGRlY2lkZSBob3cgdG8gaW50ZXJwcmV0IHRoZSB2YWx1ZVxuICAgICAgICB2YXIgYXJnID0gdHJhbnNhY3Rpb25Db25maWc7XG4gICAgICAgIHZhciB0eENvbmZpZyA9IHR4X2NvbmZpZ18xLlR4Q29uZmlnLmVtcHR5KCk7XG4gICAgICAgIGlmIChhcmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHhDb25maWcgPSBuZXcgdHhfY29uZmlnXzEuVHhDb25maWcoYXJnLCB0aGlzLl9sb2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9iZWdpblRyYW5zYWN0aW9uKHRoaXMuX21vZGUsIHR4Q29uZmlnLCB7IGFwaTogY29uc3RhbnRzXzEuVEVMRU1FVFJZX0FQSVMuVU5NQU5BR0VEX1RSQU5TQUNUSU9OIH0pO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX2JlZ2luVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoYWNjZXNzTW9kZSwgdHhDb25maWcsIGFwaVRlbGVtZXRyeUNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuX29wZW4pIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnQ2Fubm90IGJlZ2luIGEgdHJhbnNhY3Rpb24gb24gYSBjbG9zZWQgc2Vzc2lvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faGFzVHgpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnWW91IGNhbm5vdCBiZWdpbiBhIHRyYW5zYWN0aW9uIG9uIGEgc2Vzc2lvbiB3aXRoIGFuIG9wZW4gdHJhbnNhY3Rpb247ICcgK1xuICAgICAgICAgICAgICAgICdlaXRoZXIgcnVuIGZyb20gd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBvciB1c2UgYSBkaWZmZXJlbnQgc2Vzc2lvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kZSA9IFNlc3Npb24uX3ZhbGlkYXRlU2Vzc2lvbk1vZGUoYWNjZXNzTW9kZSk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gdGhpcy5fY29ubmVjdGlvbkhvbGRlcldpdGhNb2RlKG1vZGUpO1xuICAgICAgICBjb25uZWN0aW9uSG9sZGVyLmluaXRpYWxpemVDb25uZWN0aW9uKHRoaXMuX2RhdGFiYXNlR3Vlc3MpO1xuICAgICAgICB0aGlzLl9oYXNUeCA9IHRydWU7XG4gICAgICAgIHZhciB0eCA9IG5ldyB0cmFuc2FjdGlvbl9wcm9taXNlXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiBjb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgICAgaW1wZXJzb25hdGVkVXNlcjogdGhpcy5faW1wZXJzb25hdGVkVXNlcixcbiAgICAgICAgICAgIG9uQ2xvc2U6IHRoaXMuX3RyYW5zYWN0aW9uQ2xvc2VkLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvbkJvb2ttYXJrczogZnVuY3Rpb24gKG5ld0JtLCBvbGRCbSwgZGIpIHsgcmV0dXJuIF90aGlzLl91cGRhdGVCb29rbWFya3MobmV3Qm0sIG9sZEJtLCBkYik7IH0sXG4gICAgICAgICAgICBvbkNvbm5lY3Rpb246IHRoaXMuX2Fzc2VydFNlc3Npb25Jc09wZW4uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlYWN0aXZlOiB0aGlzLl9yZWFjdGl2ZSxcbiAgICAgICAgICAgIGZldGNoU2l6ZTogdGhpcy5fZmV0Y2hTaXplLFxuICAgICAgICAgICAgbG93UmVjb3JkV2F0ZXJtYXJrOiB0aGlzLl9sb3dSZWNvcmRXYXRlcm1hcmssXG4gICAgICAgICAgICBoaWdoUmVjb3JkV2F0ZXJtYXJrOiB0aGlzLl9oaWdoUmVjb3JkV2F0ZXJtYXJrLFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uRmlsdGVyOiB0aGlzLl9ub3RpZmljYXRpb25GaWx0ZXIsXG4gICAgICAgICAgICBhcGlUZWxlbWV0cnlDb25maWc6IGFwaVRlbGVtZXRyeUNvbmZpZyxcbiAgICAgICAgICAgIG9uRGJDYWxsYmFjazogdGhpcy5fb25EYXRhYmFzZU5hbWVSZXNvbHZlZC5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgICAgICB0eC5fYmVnaW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2Jvb2ttYXJrcygpOyB9LCB0eENvbmZpZyk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX2Fzc2VydFNlc3Npb25Jc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3Blbikge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdZb3UgY2Fubm90IHJ1biBtb3JlIHRyYW5zYWN0aW9ucyBvbiBhIGNsb3NlZCBzZXNzaW9uLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLl90cmFuc2FjdGlvbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFzVHggPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYm9va21hcmtzIHJlY2VpdmVkIGZvbGxvd2luZyB0aGUgbGFzdCBjb21wbGV0ZWQge0BsaW5rIFRyYW5zYWN0aW9ufS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDYuMC4gUGxlYXNlLCB1c2Uge0BsaW5rIFNlc3Npb24jbGFzdEJvb2ttYXJrc30gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSBBIHJlZmVyZW5jZSB0byBhIHByZXZpb3VzIHRyYW5zYWN0aW9uLlxuICAgICAqIEBzZWUge0BsaW5rIFNlc3Npb24jbGFzdEJvb2ttYXJrc31cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5sYXN0Qm9va21hcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RCb29rbWFya3MoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYm9va21hcmtzIHJlY2VpdmVkIGZvbGxvd2luZyB0aGUgbGFzdCBjb21wbGV0ZWQge0BsaW5rIFRyYW5zYWN0aW9ufS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSBBIHJlZmVyZW5jZSB0byBhIHByZXZpb3VzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmxhc3RCb29rbWFya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXN0Qm9va21hcmtzLnZhbHVlcygpO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX2Jvb2ttYXJrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYm9va21hcmtzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCAoKF9hID0gdGhpcy5fYm9va21hcmtNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Qm9va21hcmtzKCkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYm9va21hcmtzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2ttYXJrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2xhc3RCb29rbWFya3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBib29rbWFya3NfMS5Cb29rbWFya3MoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYm9va21hcmtzKSwgZmFsc2UpLCBfX3JlYWQodGhpcy5fY29uZmlndXJlZEJvb2ttYXJrcyksIGZhbHNlKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgZ2l2ZW4gdW5pdCBvZiB3b3JrIGluIGEge0BsaW5rIFJFQUR9IHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogVHJhbnNhY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGNvbW1pdHRlZCB1bmxlc3MgdGhlIGdpdmVuIGZ1bmN0aW9uIHRocm93cyBvciByZXR1cm5zIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAgICAgKiBTb21lIGZhaWx1cmVzIG9mIHRoZSBnaXZlbiBmdW5jdGlvbiBvciB0aGUgY29tbWl0IGl0c2VsZiB3aWxsIGJlIHJldHJpZWQgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmIHdpdGggaW5pdGlhbFxuICAgICAqIGRlbGF5IG9mIDEgc2Vjb25kIGFuZCBtYXhpbXVtIHJldHJ5IHRpbWUgb2YgMzAgc2Vjb25kcy4gTWF4aW11bSByZXRyeSB0aW1lIGlzIGNvbmZpZ3VyYWJsZSB2aWEgZHJpdmVyIGNvbmZpZydzXG4gICAgICogYG1heFRyYW5zYWN0aW9uUmV0cnlUaW1lYCBwcm9wZXJ0eSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjAuIFBsZWFzZSwgdXNlIHtAbGluayBTZXNzaW9uI2V4ZWN1dGVSZWFkfSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih0eDogVHJhbnNhY3Rpb24pOiBQcm9taXNlfSB0cmFuc2FjdGlvbldvcmsgLSBDYWxsYmFjayB0aGF0IGV4ZWN1dGVzIG9wZXJhdGlvbnMgYWdhaW5zdFxuICAgICAqIGEgZ2l2ZW4ge0BsaW5rIFRyYW5zYWN0aW9ufS5cbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSBbdHJhbnNhY3Rpb25Db25maWddIC0gQ29uZmlndXJhdGlvbiBmb3IgYWxsIHRyYW5zYWN0aW9ucyBzdGFydGVkIHRvIGV4ZWN1dGUgdGhlIHVuaXQgb2Ygd29yay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBwcm9taXNlIGFzIHJldHVybmVkIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbiBvciByZWplY3RlZCBwcm9taXNlIHdoZW4gZ2l2ZW5cbiAgICAgKiBmdW5jdGlvbiBvciBjb21taXQgZmFpbHMuXG4gICAgICogQHNlZSB7QGxpbmsgU2Vzc2lvbiNleGVjdXRlUmVhZH1cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5yZWFkVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25Xb3JrLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IHR4X2NvbmZpZ18xLlR4Q29uZmlnKHRyYW5zYWN0aW9uQ29uZmlnLCB0aGlzLl9sb2cpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVHJhbnNhY3Rpb24oY29uc3RhbnRzXzEuQUNDRVNTX01PREVfUkVBRCwgY29uZmlnLCB0cmFuc2FjdGlvbldvcmspO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBnaXZlbiB1bml0IG9mIHdvcmsgaW4gYSB7QGxpbmsgV1JJVEV9IHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogVHJhbnNhY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGNvbW1pdHRlZCB1bmxlc3MgdGhlIGdpdmVuIGZ1bmN0aW9uIHRocm93cyBvciByZXR1cm5zIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAgICAgKiBTb21lIGZhaWx1cmVzIG9mIHRoZSBnaXZlbiBmdW5jdGlvbiBvciB0aGUgY29tbWl0IGl0c2VsZiB3aWxsIGJlIHJldHJpZWQgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmIHdpdGggaW5pdGlhbFxuICAgICAqIGRlbGF5IG9mIDEgc2Vjb25kIGFuZCBtYXhpbXVtIHJldHJ5IHRpbWUgb2YgMzAgc2Vjb25kcy4gTWF4aW11bSByZXRyeSB0aW1lIGlzIGNvbmZpZ3VyYWJsZSB2aWEgZHJpdmVyIGNvbmZpZydzXG4gICAgICogYG1heFRyYW5zYWN0aW9uUmV0cnlUaW1lYCBwcm9wZXJ0eSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjAuIFBsZWFzZSwgdXNlIHtAbGluayBTZXNzaW9uI2V4ZWN1dGVXcml0ZX0gaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odHg6IFRyYW5zYWN0aW9uKTogUHJvbWlzZX0gdHJhbnNhY3Rpb25Xb3JrIC0gQ2FsbGJhY2sgdGhhdCBleGVjdXRlcyBvcGVyYXRpb25zIGFnYWluc3RcbiAgICAgKiBhIGdpdmVuIHtAbGluayBUcmFuc2FjdGlvbn0uXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkNvbmZpZ30gW3RyYW5zYWN0aW9uQ29uZmlnXSAtIENvbmZpZ3VyYXRpb24gZm9yIGFsbCB0cmFuc2FjdGlvbnMgc3RhcnRlZCB0byBleGVjdXRlIHRoZSB1bml0IG9mIHdvcmsuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgcHJvbWlzZSBhcyByZXR1cm5lZCBieSB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3IgcmVqZWN0ZWQgcHJvbWlzZSB3aGVuIGdpdmVuXG4gICAgICogZnVuY3Rpb24gb3IgY29tbWl0IGZhaWxzLlxuICAgICAqIEBzZWUge0BsaW5rIFNlc3Npb24jZXhlY3V0ZVdyaXRlfVxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLndyaXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25Xb3JrLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IHR4X2NvbmZpZ18xLlR4Q29uZmlnKHRyYW5zYWN0aW9uQ29uZmlnLCB0aGlzLl9sb2cpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVHJhbnNhY3Rpb24oY29uc3RhbnRzXzEuQUNDRVNTX01PREVfV1JJVEUsIGNvbmZpZywgdHJhbnNhY3Rpb25Xb3JrKTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLl9ydW5UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChhY2Nlc3NNb2RlLCB0cmFuc2FjdGlvbkNvbmZpZywgdHJhbnNhY3Rpb25Xb3JrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbkV4ZWN1dG9yLmV4ZWN1dGUoZnVuY3Rpb24gKGFwaVRlbGVtZXRyeUNvbmZpZykgeyByZXR1cm4gX3RoaXMuX2JlZ2luVHJhbnNhY3Rpb24oYWNjZXNzTW9kZSwgdHJhbnNhY3Rpb25Db25maWcsIGFwaVRlbGVtZXRyeUNvbmZpZyk7IH0sIHRyYW5zYWN0aW9uV29yayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGdpdmVuIHVuaXQgb2Ygd29yayBpbiBhIHtAbGluayBSRUFEfSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIFRyYW5zYWN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBiZSBjb21taXR0ZWQgdW5sZXNzIHRoZSBnaXZlbiBmdW5jdGlvbiB0aHJvd3Mgb3IgcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UuXG4gICAgICogU29tZSBmYWlsdXJlcyBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3IgdGhlIGNvbW1pdCBpdHNlbGYgd2lsbCBiZSByZXRyaWVkIHdpdGggZXhwb25lbnRpYWwgYmFja29mZiB3aXRoIGluaXRpYWxcbiAgICAgKiBkZWxheSBvZiAxIHNlY29uZCBhbmQgbWF4aW11bSByZXRyeSB0aW1lIG9mIDMwIHNlY29uZHMuIE1heGltdW0gcmV0cnkgdGltZSBpcyBjb25maWd1cmFibGUgdmlhIGRyaXZlciBjb25maWcnc1xuICAgICAqIGBtYXhUcmFuc2FjdGlvblJldHJ5VGltZWAgcHJvcGVydHkgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogTk9URTogQmVjYXVzZSBpdCBpcyBhbiBleHBsaWNpdCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgcG9pbnQgb2YgdmlldywgQ3lwaGVyIHF1ZXJpZXMgdXNpbmdcbiAgICAgKiBcIkNBTEwge30gSU4gVFJBTlNBQ1RJT05TXCIgb3IgdGhlIG9sZGVyIFwiVVNJTkcgUEVSSU9ESUMgQ09NTUlUXCIgY29uc3RydWN0IHdpbGwgbm90IHdvcmsgKGNhbGxcbiAgICAgKiB7QGxpbmsgU2Vzc2lvbiNydW59IGZvciB0aGVzZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHR4OiBNYW5hZ2VkVHJhbnNhY3Rpb24pOiBQcm9taXNlfSB0cmFuc2FjdGlvbldvcmsgLSBDYWxsYmFjayB0aGF0IGV4ZWN1dGVzIG9wZXJhdGlvbnMgYWdhaW5zdFxuICAgICAqIGEgZ2l2ZW4ge0BsaW5rIFRyYW5zYWN0aW9ufS5cbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlnfSBbdHJhbnNhY3Rpb25Db25maWddIC0gQ29uZmlndXJhdGlvbiBmb3IgYWxsIHRyYW5zYWN0aW9ucyBzdGFydGVkIHRvIGV4ZWN1dGUgdGhlIHVuaXQgb2Ygd29yay5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBwcm9taXNlIGFzIHJldHVybmVkIGJ5IHRoZSBnaXZlbiBmdW5jdGlvbiBvciByZWplY3RlZCBwcm9taXNlIHdoZW4gZ2l2ZW5cbiAgICAgKiBmdW5jdGlvbiBvciBjb21taXQgZmFpbHMuXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZXhlY3V0ZVJlYWQgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25Xb3JrLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IHR4X2NvbmZpZ18xLlR4Q29uZmlnKHRyYW5zYWN0aW9uQ29uZmlnLCB0aGlzLl9sb2cpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUluVHJhbnNhY3Rpb24oY29uc3RhbnRzXzEuQUNDRVNTX01PREVfUkVBRCwgY29uZmlnLCB0cmFuc2FjdGlvbldvcmspO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBnaXZlbiB1bml0IG9mIHdvcmsgaW4gYSB7QGxpbmsgV1JJVEV9IHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogVHJhbnNhY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGNvbW1pdHRlZCB1bmxlc3MgdGhlIGdpdmVuIGZ1bmN0aW9uIHRocm93cyBvciByZXR1cm5zIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAgICAgKiBTb21lIGZhaWx1cmVzIG9mIHRoZSBnaXZlbiBmdW5jdGlvbiBvciB0aGUgY29tbWl0IGl0c2VsZiB3aWxsIGJlIHJldHJpZWQgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmIHdpdGggaW5pdGlhbFxuICAgICAqIGRlbGF5IG9mIDEgc2Vjb25kIGFuZCBtYXhpbXVtIHJldHJ5IHRpbWUgb2YgMzAgc2Vjb25kcy4gTWF4aW11bSByZXRyeSB0aW1lIGlzIGNvbmZpZ3VyYWJsZSB2aWEgZHJpdmVyIGNvbmZpZydzXG4gICAgICogYG1heFRyYW5zYWN0aW9uUmV0cnlUaW1lYCBwcm9wZXJ0eSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBCZWNhdXNlIGl0IGlzIGFuIGV4cGxpY2l0IHRyYW5zYWN0aW9uIGZyb20gdGhlIHNlcnZlciBwb2ludCBvZiB2aWV3LCBDeXBoZXIgcXVlcmllcyB1c2luZ1xuICAgICAqIFwiQ0FMTCB7fSBJTiBUUkFOU0FDVElPTlNcIiBvciB0aGUgb2xkZXIgXCJVU0lORyBQRVJJT0RJQyBDT01NSVRcIiBjb25zdHJ1Y3Qgd2lsbCBub3Qgd29yayAoY2FsbFxuICAgICAqIHtAbGluayBTZXNzaW9uI3J1bn0gZm9yIHRoZXNlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odHg6IE1hbmFnZWRUcmFuc2FjdGlvbik6IFByb21pc2V9IHRyYW5zYWN0aW9uV29yayAtIENhbGxiYWNrIHRoYXQgZXhlY3V0ZXMgb3BlcmF0aW9ucyBhZ2FpbnN0XG4gICAgICogYSBnaXZlbiB7QGxpbmsgVHJhbnNhY3Rpb259LlxuICAgICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maWd9IFt0cmFuc2FjdGlvbkNvbmZpZ10gLSBDb25maWd1cmF0aW9uIGZvciBhbGwgdHJhbnNhY3Rpb25zIHN0YXJ0ZWQgdG8gZXhlY3V0ZSB0aGUgdW5pdCBvZiB3b3JrLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHByb21pc2UgYXMgcmV0dXJuZWQgYnkgdGhlIGdpdmVuIGZ1bmN0aW9uIG9yIHJlamVjdGVkIHByb21pc2Ugd2hlbiBnaXZlblxuICAgICAqIGZ1bmN0aW9uIG9yIGNvbW1pdCBmYWlscy5cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5leGVjdXRlV3JpdGUgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25Xb3JrLCB0cmFuc2FjdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IHR4X2NvbmZpZ18xLlR4Q29uZmlnKHRyYW5zYWN0aW9uQ29uZmlnLCB0aGlzLl9sb2cpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhlY3V0ZUluVHJhbnNhY3Rpb24oY29uc3RhbnRzXzEuQUNDRVNTX01PREVfV1JJVEUsIGNvbmZpZywgdHJhbnNhY3Rpb25Xb3JrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTZXNzaW9uTW9kZX0gYWNjZXNzTW9kZVxuICAgICAqIEBwYXJhbSB7VHhDb25maWd9IHRyYW5zYWN0aW9uQ29uZmlnXG4gICAgICogQHBhcmFtIHtNYW5hZ2VkVHJhbnNhY3Rpb25Xb3JrfSB0cmFuc2FjdGlvbldvcmtcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fZXhlY3V0ZUluVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoYWNjZXNzTW9kZSwgdHJhbnNhY3Rpb25Db25maWcsIHRyYW5zYWN0aW9uV29yaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25FeGVjdXRvci5leGVjdXRlKGZ1bmN0aW9uIChhcGlUZWxlbWV0cnlDb25maWcpIHsgcmV0dXJuIF90aGlzLl9iZWdpblRyYW5zYWN0aW9uKGFjY2Vzc01vZGUsIHRyYW5zYWN0aW9uQ29uZmlnLCBhcGlUZWxlbWV0cnlDb25maWcpOyB9LCB0cmFuc2FjdGlvbldvcmssIHRyYW5zYWN0aW9uX21hbmFnZWRfMS5kZWZhdWx0LmZyb21UcmFuc2FjdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZXNvbHZlZCBkYXRhYmFzZSBuYW1lIGluIHRoZSBzZXNzaW9uIGNvbnRleHQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGRhdGFiYXNlIFRoZSByZXNvbHZlZCBkYXRhYmFzZSBuYW1lXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX29uRGF0YWJhc2VOYW1lUmVzb2x2ZWQgPSBmdW5jdGlvbiAoZGF0YWJhc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUm91dGluZ1Nlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFiYXNlR3Vlc3MgPSBkYXRhYmFzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGF0YWJhc2VOYW1lUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZERhdGFiYXNlID0gZGF0YWJhc2UgIT09IG51bGwgJiYgZGF0YWJhc2UgIT09IHZvaWQgMCA/IGRhdGFiYXNlIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YWJhc2UgPSBub3JtYWxpemVkRGF0YWJhc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZENvbm5lY3Rpb25Ib2xkZXIuc2V0RGF0YWJhc2Uobm9ybWFsaXplZERhdGFiYXNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUNvbm5lY3Rpb25Ib2xkZXIuc2V0RGF0YWJhc2Uobm9ybWFsaXplZERhdGFiYXNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhYmFzZU5hbWVSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvbWVEYXRhYmFzZUNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faG9tZURhdGFiYXNlQ2FsbGJhY2soKDAsIGF1dGhfdXRpbF8xLmNhY2hlS2V5KSh0aGlzLl9hdXRoLCB0aGlzLl9pbXBlcnNvbmF0ZWRVc2VyKSwgZGF0YWJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX2dldENvbm5lY3Rpb25BY3F1aXN0aW9uQm9va21hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib29rbWFya3M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sICgoX2EgPSB0aGlzLl9ib29rbWFya01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRCb29rbWFya3MoKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rbWFya3MgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9va21hcmtzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fbGFzdEJvb2ttYXJrc107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IGJvb2ttYXJrc18xLkJvb2ttYXJrcyhfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZCh0aGlzLl9jb25maWd1cmVkQm9va21hcmtzKSwgZmFsc2UpLCBfX3JlYWQoYm9va21hcmtzKSwgZmFsc2UpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHZhbHVlIG9mIHRoZSBsYXN0IGJvb2ttYXJrcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9va21hcmtzfSBuZXdCb29rbWFya3MgLSBUaGUgbmV3IGJvb2ttYXJrcy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fdXBkYXRlQm9va21hcmtzID0gZnVuY3Rpb24gKG5ld0Jvb2ttYXJrcywgcHJldmlvdXNCb29rbWFya3MsIGRhdGFiYXNlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoKG5ld0Jvb2ttYXJrcyAhPSBudWxsKSAmJiAhbmV3Qm9va21hcmtzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5fYm9va21hcmtNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlQm9va21hcmtzKChfYiA9IHByZXZpb3VzQm9va21hcmtzID09PSBudWxsIHx8IHByZXZpb3VzQm9va21hcmtzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2aW91c0Jvb2ttYXJrcy52YWx1ZXMoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sIChfYyA9IG5ld0Jvb2ttYXJrcyA9PT0gbnVsbCB8fCBuZXdCb29rbWFya3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld0Jvb2ttYXJrcy52YWx1ZXMoKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Qm9va21hcmtzID0gbmV3Qm9va21hcmtzO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlndXJlZEJvb2ttYXJrcyA9IGJvb2ttYXJrc18xLkJvb2ttYXJrcy5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGlzIHNlc3Npb24uXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcGVuKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuX2NhbmNlbCgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uRXhlY3V0b3IuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3JlYWRDb25uZWN0aW9uSG9sZGVyLmNsb3NlKHRoaXMuX2hhc1R4KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX3dyaXRlQ29ubmVjdGlvbkhvbGRlci5jbG9zZSh0aGlzLl9oYXNUeCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBTZXNzaW9uLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNEaXNwb3NlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLl9jb25uZWN0aW9uSG9sZGVyV2l0aE1vZGUgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgICBpZiAobW9kZSA9PT0gY29uc3RhbnRzXzEuQUNDRVNTX01PREVfUkVBRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRDb25uZWN0aW9uSG9sZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IGNvbnN0YW50c18xLkFDQ0VTU19NT0RFX1dSSVRFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVDb25uZWN0aW9uSG9sZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdVbmtub3duIGFjY2VzcyBtb2RlOiAnICsgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGEgQ29ubmVjdGlvbiBtZXRhZGF0YWRhXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX29uQ29tcGxldGVDYWxsYmFjayA9IGZ1bmN0aW9uIChtZXRhLCBwcmV2aW91c0Jvb2ttYXJrcykge1xuICAgICAgICB0aGlzLl91cGRhdGVCb29rbWFya3MobmV3IGJvb2ttYXJrc18xLkJvb2ttYXJrcyhtZXRhLmJvb2ttYXJrKSwgcHJldmlvdXNCb29rbWFya3MsIG1ldGEuZGIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fY2FsY3VsYXRlV2F0ZXJtYWtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZmV0Y2hTaXplID09PSBjb25zdGFudHNfMS5GRVRDSF9BTEwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG93OiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgICAgIGhpZ2g6IE51bWJlci5NQVhfVkFMVUUgLy8gd2Ugc2hhbGwgbmV2ZXIgcmVhY2ggdGhpcyBudW1iZXIgdG8gZGlzYWJsZSBhdXRvIHB1bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvdzogMC4zICogdGhpcy5fZmV0Y2hTaXplLFxuICAgICAgICAgICAgaGlnaDogMC43ICogdGhpcy5fZmV0Y2hTaXplXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIHRyYW5zYWN0aW9uIGV4ZWN1dG9yXG4gICAgICpcbiAgICAgKiBUaGlzIHVzZWQgYnkge0BsaW5rIERyaXZlciNleGVjdXRlUXVlcnl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fY29uZmlndXJlVHJhbnNhY3Rpb25FeGVjdXRvciA9IGZ1bmN0aW9uIChwaXBlbGluZWQsIHRlbGVtZXRyeUFwaSkge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbkV4ZWN1dG9yLnBpcGVsaW5lQmVnaW4gPSBwaXBlbGluZWQ7XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uRXhlY3V0b3IudGVsZW1ldHJ5QXBpID0gdGVsZW1ldHJ5QXBpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIFNlc3Npb24uX3ZhbGlkYXRlU2Vzc2lvbk1vZGUgPSBmdW5jdGlvbiAocmF3TW9kZSkge1xuICAgICAgICB2YXIgbW9kZSA9IHJhd01vZGUgIT09IG51bGwgJiYgcmF3TW9kZSAhPT0gdm9pZCAwID8gcmF3TW9kZSA6IGNvbnN0YW50c18xLkFDQ0VTU19NT0RFX1dSSVRFO1xuICAgICAgICBpZiAobW9kZSAhPT0gY29uc3RhbnRzXzEuQUNDRVNTX01PREVfUkVBRCAmJiBtb2RlICE9PSBjb25zdGFudHNfMS5BQ0NFU1NfTU9ERV9XUklURSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdJbGxlZ2FsIHNlc3Npb24gbW9kZSAnICsgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfTtcbiAgICByZXR1cm4gU2Vzc2lvbjtcbn0oKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gKiBAcmV0dXJucyB7VHJhbnNhY3Rpb25FeGVjdXRvcn0gVGhlIHRyYW5zYWN0aW9uIGV4ZWN1dG9yXG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVUcmFuc2FjdGlvbkV4ZWN1dG9yKGNvbmZpZykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgbWF4UmV0cnlUaW1lTXMgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubWF4VHJhbnNhY3Rpb25SZXRyeVRpbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyB0cmFuc2FjdGlvbl9leGVjdXRvcl8xLlRyYW5zYWN0aW9uRXhlY3V0b3IobWF4UmV0cnlUaW1lTXMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2Vzc2lvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/session.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/spatial-types.js":
/*!*************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/spatial-types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPoint = exports.Point = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar util_1 = __webpack_require__(/*! ./internal/util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\nvar POINT_IDENTIFIER_PROPERTY = '__isPoint__';\n/**\n * Represents a single two or three-dimensional point in a particular coordinate reference system.\n * Created `Point` objects are frozen with `Object.freeze()` in constructor and thus immutable.\n */\nvar Point = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {T} srid - The coordinate reference system identifier.\n     * @param {number} x - The `x` coordinate of the point.\n     * @param {number} y - The `y` coordinate of the point.\n     * @param {number} [z=undefined] - The `z` coordinate of the point or `undefined` if point has 2 dimensions.\n     */\n    function Point(srid, x, y, z) {\n        /**\n         * The coordinate reference system identifier.\n         * @type {T}\n         */\n        this.srid = (0, util_1.assertNumberOrInteger)(srid, 'SRID');\n        /**\n         * The `x` coordinate of the point.\n         * @type {number}\n         */\n        this.x = (0, util_1.assertNumber)(x, 'X coordinate');\n        /**\n         * The `y` coordinate of the point.\n         * @type {number}\n         */\n        this.y = (0, util_1.assertNumber)(y, 'Y coordinate');\n        /**\n         * The `z` coordinate of the point or `undefined` if point is 2-dimensional.\n         * @type {number}\n         */\n        this.z = z === null || z === undefined ? z : (0, util_1.assertNumber)(z, 'Z coordinate');\n        Object.freeze(this);\n    }\n    /**\n     * @ignore\n     */\n    Point.prototype.toString = function () {\n        return this.z != null && !isNaN(this.z)\n            ? \"Point{srid=\".concat(formatAsFloat(this.srid), \", x=\").concat(formatAsFloat(this.x), \", y=\").concat(formatAsFloat(this.y), \", z=\").concat(formatAsFloat(this.z), \"}\")\n            : \"Point{srid=\".concat(formatAsFloat(this.srid), \", x=\").concat(formatAsFloat(this.x), \", y=\").concat(formatAsFloat(this.y), \"}\");\n    };\n    return Point;\n}());\nexports.Point = Point;\nfunction formatAsFloat(number) {\n    return Number.isInteger(number) ? number.toString() + '.0' : number.toString();\n}\nObject.defineProperty(Point.prototype, POINT_IDENTIFIER_PROPERTY, {\n    value: true,\n    enumerable: false,\n    configurable: false,\n    writable: false\n});\n/**\n * Test if given object is an instance of {@link Point} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Point}, `false` otherwise.\n */\nfunction isPoint(obj) {\n    var anyObj = obj;\n    return obj != null && anyObj[POINT_IDENTIFIER_PROPERTY] === true;\n}\nexports.isPoint = isPoint;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3NwYXRpYWwtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0ZBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRKQUE0SjtBQUNqTCxxQkFBcUIsc0hBQXNIO0FBQzNJO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RCxXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTLDZCQUE2QixZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvc3BhdGlhbC10eXBlcy5qcz8zODYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1BvaW50ID0gZXhwb3J0cy5Qb2ludCA9IHZvaWQgMDtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvdXRpbFwiKTtcbnZhciBQT0lOVF9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNQb2ludF9fJztcbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSB0d28gb3IgdGhyZWUtZGltZW5zaW9uYWwgcG9pbnQgaW4gYSBwYXJ0aWN1bGFyIGNvb3JkaW5hdGUgcmVmZXJlbmNlIHN5c3RlbS5cbiAqIENyZWF0ZWQgYFBvaW50YCBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cbnZhciBQb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1R9IHNyaWQgLSBUaGUgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3o9dW5kZWZpbmVkXSAtIFRoZSBgemAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgb3IgYHVuZGVmaW5lZGAgaWYgcG9pbnQgaGFzIDIgZGltZW5zaW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQb2ludChzcmlkLCB4LCB5LCB6KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtIGlkZW50aWZpZXIuXG4gICAgICAgICAqIEB0eXBlIHtUfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcmlkID0gKDAsIHV0aWxfMS5hc3NlcnROdW1iZXJPckludGVnZXIpKHNyaWQsICdTUklEJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0gKDAsIHV0aWxfMS5hc3NlcnROdW1iZXIpKHgsICdYIGNvb3JkaW5hdGUnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkgPSAoMCwgdXRpbF8xLmFzc2VydE51bWJlcikoeSwgJ1kgY29vcmRpbmF0ZScpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGB6YCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBvciBgdW5kZWZpbmVkYCBpZiBwb2ludCBpcyAyLWRpbWVuc2lvbmFsLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56ID0geiA9PT0gbnVsbCB8fCB6ID09PSB1bmRlZmluZWQgPyB6IDogKDAsIHV0aWxfMS5hc3NlcnROdW1iZXIpKHosICdaIGNvb3JkaW5hdGUnKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIFBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueiAhPSBudWxsICYmICFpc05hTih0aGlzLnopXG4gICAgICAgICAgICA/IFwiUG9pbnR7c3JpZD1cIi5jb25jYXQoZm9ybWF0QXNGbG9hdCh0aGlzLnNyaWQpLCBcIiwgeD1cIikuY29uY2F0KGZvcm1hdEFzRmxvYXQodGhpcy54KSwgXCIsIHk9XCIpLmNvbmNhdChmb3JtYXRBc0Zsb2F0KHRoaXMueSksIFwiLCB6PVwiKS5jb25jYXQoZm9ybWF0QXNGbG9hdCh0aGlzLnopLCBcIn1cIilcbiAgICAgICAgICAgIDogXCJQb2ludHtzcmlkPVwiLmNvbmNhdChmb3JtYXRBc0Zsb2F0KHRoaXMuc3JpZCksIFwiLCB4PVwiKS5jb25jYXQoZm9ybWF0QXNGbG9hdCh0aGlzLngpLCBcIiwgeT1cIikuY29uY2F0KGZvcm1hdEFzRmxvYXQodGhpcy55KSwgXCJ9XCIpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvaW50O1xufSgpKTtcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbmZ1bmN0aW9uIGZvcm1hdEFzRmxvYXQobnVtYmVyKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIobnVtYmVyKSA/IG51bWJlci50b1N0cmluZygpICsgJy4wJyA6IG51bWJlci50b1N0cmluZygpO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50LnByb3RvdHlwZSwgUE9JTlRfSURFTlRJRklFUl9QUk9QRVJUWSwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG59KTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBvaW50fSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBQb2ludH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1BvaW50KG9iaikge1xuICAgIHZhciBhbnlPYmogPSBvYmo7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGFueU9ialtQT0lOVF9JREVOVElGSUVSX1BST1BFUlRZXSA9PT0gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNQb2ludCA9IGlzUG9pbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/spatial-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/temporal-types.js":
/*!**************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/temporal-types.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDateTime = exports.DateTime = exports.isLocalDateTime = exports.LocalDateTime = exports.isDate = exports.Date = exports.isTime = exports.Time = exports.isLocalTime = exports.LocalTime = exports.isDuration = exports.Duration = void 0;\nvar util = __importStar(__webpack_require__(/*! ./internal/temporal-util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/temporal-util.js\"));\nvar util_1 = __webpack_require__(/*! ./internal/util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar integer_1 = __importStar(__webpack_require__(/*! ./integer */ \"(rsc)/./node_modules/neo4j-driver-core/lib/integer.js\"));\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n    value: true,\n    enumerable: false,\n    configurable: false,\n    writable: false\n};\nvar DURATION_IDENTIFIER_PROPERTY = '__isDuration__';\nvar LOCAL_TIME_IDENTIFIER_PROPERTY = '__isLocalTime__';\nvar TIME_IDENTIFIER_PROPERTY = '__isTime__';\nvar DATE_IDENTIFIER_PROPERTY = '__isDate__';\nvar LOCAL_DATE_TIME_IDENTIFIER_PROPERTY = '__isLocalDateTime__';\nvar DATE_TIME_IDENTIFIER_PROPERTY = '__isDateTime__';\n/**\n * Represents an ISO 8601 duration. Contains both date-based values (years, months, days) and time-based values (seconds, nanoseconds).\n * Created `Duration` objects are frozen with `Object.freeze()` in constructor and thus immutable.\n */\nvar Duration = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {NumberOrInteger} months - The number of months for the new duration.\n     * @param {NumberOrInteger} days - The number of days for the new duration.\n     * @param {NumberOrInteger} seconds - The number of seconds for the new duration.\n     * @param {NumberOrInteger} nanoseconds - The number of nanoseconds for the new duration.\n     */\n    function Duration(months, days, seconds, nanoseconds) {\n        /**\n         * The number of months.\n         * @type {NumberOrInteger}\n         */\n        this.months = (0, util_1.assertNumberOrInteger)(months, 'Months');\n        /**\n         * The number of days.\n         * @type {NumberOrInteger}\n         */\n        this.days = (0, util_1.assertNumberOrInteger)(days, 'Days');\n        (0, util_1.assertNumberOrInteger)(seconds, 'Seconds');\n        (0, util_1.assertNumberOrInteger)(nanoseconds, 'Nanoseconds');\n        /**\n         * The number of seconds.\n         * @type {NumberOrInteger}\n         */\n        this.seconds = util.normalizeSecondsForDuration(seconds, nanoseconds);\n        /**\n         * The number of nanoseconds.\n         * @type {NumberOrInteger}\n         */\n        this.nanoseconds = util.normalizeNanosecondsForDuration(nanoseconds);\n        Object.freeze(this);\n    }\n    /**\n     * @ignore\n     */\n    Duration.prototype.toString = function () {\n        return util.durationToIsoString(this.months, this.days, this.seconds, this.nanoseconds);\n    };\n    return Duration;\n}());\nexports.Duration = Duration;\nObject.defineProperty(Duration.prototype, DURATION_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Duration} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Duration}, `false` otherwise.\n */\nfunction isDuration(obj) {\n    return hasIdentifierProperty(obj, DURATION_IDENTIFIER_PROPERTY);\n}\nexports.isDuration = isDuration;\n/**\n * Represents an instant capturing the time of day, but not the date, nor the timezone.\n * Created {@link LocalTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.\n */\nvar LocalTime = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {NumberOrInteger} hour - The hour for the new local time.\n     * @param {NumberOrInteger} minute - The minute for the new local time.\n     * @param {NumberOrInteger} second - The second for the new local time.\n     * @param {NumberOrInteger} nanosecond - The nanosecond for the new local time.\n     */\n    function LocalTime(hour, minute, second, nanosecond) {\n        /**\n         * The hour.\n         * @type {NumberOrInteger}\n         */\n        this.hour = util.assertValidHour(hour);\n        /**\n         * The minute.\n         * @type {NumberOrInteger}\n         */\n        this.minute = util.assertValidMinute(minute);\n        /**\n         * The second.\n         * @type {NumberOrInteger}\n         */\n        this.second = util.assertValidSecond(second);\n        /**\n         * The nanosecond.\n         * @type {NumberOrInteger}\n         */\n        this.nanosecond = util.assertValidNanosecond(nanosecond);\n        Object.freeze(this);\n    }\n    /**\n     * Create a {@link LocalTime} object from the given standard JavaScript `Date` and optional nanoseconds.\n     * Year, month, day and time zone offset components of the given date are ignored.\n     * @param {global.Date} standardDate - The standard JavaScript date to convert.\n     * @param {NumberOrInteger|undefined} nanosecond - The optional amount of nanoseconds.\n     * @return {LocalTime<number>} New LocalTime.\n     */\n    LocalTime.fromStandardDate = function (standardDate, nanosecond) {\n        verifyStandardDateAndNanos(standardDate, nanosecond);\n        var totalNanoseconds = util.totalNanoseconds(standardDate, nanosecond);\n        return new LocalTime(standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), totalNanoseconds instanceof integer_1.default\n            ? totalNanoseconds.toInt()\n            : typeof totalNanoseconds === 'bigint'\n                ? (0, integer_1.int)(totalNanoseconds).toInt()\n                : totalNanoseconds);\n    };\n    /**\n     * @ignore\n     */\n    LocalTime.prototype.toString = function () {\n        return util.timeToIsoString(this.hour, this.minute, this.second, this.nanosecond);\n    };\n    return LocalTime;\n}());\nexports.LocalTime = LocalTime;\nObject.defineProperty(LocalTime.prototype, LOCAL_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link LocalTime} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link LocalTime}, `false` otherwise.\n */\nfunction isLocalTime(obj) {\n    return hasIdentifierProperty(obj, LOCAL_TIME_IDENTIFIER_PROPERTY);\n}\nexports.isLocalTime = isLocalTime;\n/**\n * Represents an instant capturing the time of day, and the timezone offset in seconds, but not the date.\n * Created {@link Time} objects are frozen with `Object.freeze()` in constructor and thus immutable.\n */\nvar Time = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {NumberOrInteger} hour - The hour for the new local time.\n     * @param {NumberOrInteger} minute - The minute for the new local time.\n     * @param {NumberOrInteger} second - The second for the new local time.\n     * @param {NumberOrInteger} nanosecond - The nanosecond for the new local time.\n     * @param {NumberOrInteger} timeZoneOffsetSeconds - The time zone offset in seconds. Value represents the difference, in seconds, from UTC to local time.\n     * This is different from standard JavaScript `Date.getTimezoneOffset()` which is the difference, in minutes, from local time to UTC.\n     */\n    function Time(hour, minute, second, nanosecond, timeZoneOffsetSeconds) {\n        /**\n         * The hour.\n         * @type {NumberOrInteger}\n         */\n        this.hour = util.assertValidHour(hour);\n        /**\n         * The minute.\n         * @type {NumberOrInteger}\n         */\n        this.minute = util.assertValidMinute(minute);\n        /**\n         * The second.\n         * @type {NumberOrInteger}\n         */\n        this.second = util.assertValidSecond(second);\n        /**\n         * The nanosecond.\n         * @type {NumberOrInteger}\n         */\n        this.nanosecond = util.assertValidNanosecond(nanosecond);\n        /**\n         * The time zone offset in seconds.\n         * @type {NumberOrInteger}\n         */\n        this.timeZoneOffsetSeconds = (0, util_1.assertNumberOrInteger)(timeZoneOffsetSeconds, 'Time zone offset in seconds');\n        Object.freeze(this);\n    }\n    /**\n     * Create a {@link Time} object from the given standard JavaScript `Date` and optional nanoseconds.\n     * Year, month and day components of the given date are ignored.\n     * @param {global.Date} standardDate - The standard JavaScript date to convert.\n     * @param {NumberOrInteger|undefined} nanosecond - The optional amount of nanoseconds.\n     * @return {Time<number>} New Time.\n     */\n    Time.fromStandardDate = function (standardDate, nanosecond) {\n        verifyStandardDateAndNanos(standardDate, nanosecond);\n        return new Time(standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), (0, integer_1.toNumber)(util.totalNanoseconds(standardDate, nanosecond)), util.timeZoneOffsetInSeconds(standardDate));\n    };\n    /**\n     * @ignore\n     */\n    Time.prototype.toString = function () {\n        return (util.timeToIsoString(this.hour, this.minute, this.second, this.nanosecond) + util.timeZoneOffsetToIsoString(this.timeZoneOffsetSeconds));\n    };\n    return Time;\n}());\nexports.Time = Time;\nObject.defineProperty(Time.prototype, TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Time} class.\n * @param {Object} obj the object to test.\n * @return {boolean} `true` if given object is a {@link Time}, `false` otherwise.\n */\nfunction isTime(obj) {\n    return hasIdentifierProperty(obj, TIME_IDENTIFIER_PROPERTY);\n}\nexports.isTime = isTime;\n/**\n * Represents an instant capturing the date, but not the time, nor the timezone.\n * Created {@link Date} objects are frozen with `Object.freeze()` in constructor and thus immutable.\n */\nvar Date = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {NumberOrInteger} year - The year for the new local date.\n     * @param {NumberOrInteger} month - The month for the new local date.\n     * @param {NumberOrInteger} day - The day for the new local date.\n     */\n    function Date(year, month, day) {\n        /**\n         * The year.\n         * @type {NumberOrInteger}\n         */\n        this.year = util.assertValidYear(year);\n        /**\n         * The month.\n         * @type {NumberOrInteger}\n         */\n        this.month = util.assertValidMonth(month);\n        /**\n         * The day.\n         * @type {NumberOrInteger}\n         */\n        this.day = util.assertValidDay(day);\n        Object.freeze(this);\n    }\n    /**\n     * Create a {@link Date} object from the given standard JavaScript `Date`.\n     * Hour, minute, second, millisecond and time zone offset components of the given date are ignored.\n     *\n     * NOTE: the function {@link toStandardDate} and {@link fromStandardDate} are not inverses of one another. {@link fromStandardDate} takes the Day, Month and Year in local time from the supplies JavaScript Date object, while {@link toStandardDate} creates a new JavaScript Date object at midnight UTC. This incongruity will be rectified in 6.0\n     * If your timezone has a negative offset from UTC, creating a JavaScript Date at midnight UTC and converting it with {@link fromStandardDate} will result in a Date for the day before.\n     *\n     * @param {global.Date} standardDate - The standard JavaScript date to convert.\n     * @return {Date} New Date.\n     */\n    Date.fromStandardDate = function (standardDate) {\n        verifyStandardDateAndNanos(standardDate);\n        return new Date(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate());\n    };\n    /**\n     * Convert date to standard JavaScript `Date`.\n     *\n     * The time component of the returned `Date` is set to midnight\n     * and the time zone is set to UTC.\n     *\n     * NOTE: the function {@link toStandardDate} and {@link fromStandardDate} are not inverses of one another. {@link fromStandardDate} takes the Day, Month and Year in local time from the supplies JavaScript Date object, while {@link toStandardDate} creates a new JavaScript Date object at midnight UTC. This incongruity will be rectified in 6.0\n     *\n     * @returns {StandardDate} Standard JavaScript `Date` at `00:00:00.000` UTC.\n     */\n    Date.prototype.toStandardDate = function () {\n        return util.isoStringToStandardDate(this.toString());\n    };\n    /**\n     * @ignore\n     */\n    Date.prototype.toString = function () {\n        return util.dateToIsoString(this.year, this.month, this.day);\n    };\n    return Date;\n}());\nexports.Date = Date;\nObject.defineProperty(Date.prototype, DATE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link Date} class.\n * @param {Object} obj - The object to test.\n * @return {boolean} `true` if given object is a {@link Date}, `false` otherwise.\n */\nfunction isDate(obj) {\n    return hasIdentifierProperty(obj, DATE_IDENTIFIER_PROPERTY);\n}\nexports.isDate = isDate;\n/**\n * Represents an instant capturing the date and the time, but not the timezone.\n * Created {@link LocalDateTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.\n */\nvar LocalDateTime = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {NumberOrInteger} year - The year for the new local date.\n     * @param {NumberOrInteger} month - The month for the new local date.\n     * @param {NumberOrInteger} day - The day for the new local date.\n     * @param {NumberOrInteger} hour - The hour for the new local time.\n     * @param {NumberOrInteger} minute - The minute for the new local time.\n     * @param {NumberOrInteger} second - The second for the new local time.\n     * @param {NumberOrInteger} nanosecond - The nanosecond for the new local time.\n     */\n    function LocalDateTime(year, month, day, hour, minute, second, nanosecond) {\n        /**\n         * The year.\n         * @type {NumberOrInteger}\n         */\n        this.year = util.assertValidYear(year);\n        /**\n         * The month.\n         * @type {NumberOrInteger}\n         */\n        this.month = util.assertValidMonth(month);\n        /**\n         * The day.\n         * @type {NumberOrInteger}\n         */\n        this.day = util.assertValidDay(day);\n        /**\n         * The hour.\n         * @type {NumberOrInteger}\n         */\n        this.hour = util.assertValidHour(hour);\n        /**\n         * The minute.\n         * @type {NumberOrInteger}\n         */\n        this.minute = util.assertValidMinute(minute);\n        /**\n         * The second.\n         * @type {NumberOrInteger}\n         */\n        this.second = util.assertValidSecond(second);\n        /**\n         * The nanosecond.\n         * @type {NumberOrInteger}\n         */\n        this.nanosecond = util.assertValidNanosecond(nanosecond);\n        Object.freeze(this);\n    }\n    /**\n     * Create a {@link LocalDateTime} object from the given standard JavaScript `Date` and optional nanoseconds.\n     * Time zone offset component of the given date is ignored.\n     * @param {global.Date} standardDate - The standard JavaScript date to convert.\n     * @param {NumberOrInteger|undefined} nanosecond - The optional amount of nanoseconds.\n     * @return {LocalDateTime} New LocalDateTime.\n     */\n    LocalDateTime.fromStandardDate = function (standardDate, nanosecond) {\n        verifyStandardDateAndNanos(standardDate, nanosecond);\n        return new LocalDateTime(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate(), standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), (0, integer_1.toNumber)(util.totalNanoseconds(standardDate, nanosecond)));\n    };\n    /**\n     * Convert date to standard JavaScript `Date`.\n     *\n     * @returns {StandardDate} Standard JavaScript `Date` at the local timezone\n     */\n    LocalDateTime.prototype.toStandardDate = function () {\n        return util.isoStringToStandardDate(this.toString());\n    };\n    /**\n     * @ignore\n     */\n    LocalDateTime.prototype.toString = function () {\n        return localDateTimeToString(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);\n    };\n    return LocalDateTime;\n}());\nexports.LocalDateTime = LocalDateTime;\nObject.defineProperty(LocalDateTime.prototype, LOCAL_DATE_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link LocalDateTime} class.\n * @param {Object} obj - The object to test.\n * @return {boolean} `true` if given object is a {@link LocalDateTime}, `false` otherwise.\n */\nfunction isLocalDateTime(obj) {\n    return hasIdentifierProperty(obj, LOCAL_DATE_TIME_IDENTIFIER_PROPERTY);\n}\nexports.isLocalDateTime = isLocalDateTime;\n/**\n * Represents an instant capturing the date, the time and the timezone identifier.\n * Created {@ DateTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.\n */\nvar DateTime = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {NumberOrInteger} year - The year for the new date-time.\n     * @param {NumberOrInteger} month - The month for the new date-time.\n     * @param {NumberOrInteger} day - The day for the new date-time.\n     * @param {NumberOrInteger} hour - The hour for the new date-time.\n     * @param {NumberOrInteger} minute - The minute for the new date-time.\n     * @param {NumberOrInteger} second - The second for the new date-time.\n     * @param {NumberOrInteger} nanosecond - The nanosecond for the new date-time.\n     * @param {NumberOrInteger} timeZoneOffsetSeconds - The time zone offset in seconds. Either this argument or `timeZoneId` should be defined.\n     * Value represents the difference, in seconds, from UTC to local time.\n     * This is different from standard JavaScript `Date.getTimezoneOffset()` which is the difference, in minutes, from local time to UTC.\n     * @param {string|null} timeZoneId - The time zone id for the new date-time. Either this argument or `timeZoneOffsetSeconds` should be defined.\n     */\n    function DateTime(year, month, day, hour, minute, second, nanosecond, timeZoneOffsetSeconds, timeZoneId) {\n        /**\n         * The year.\n         * @type {NumberOrInteger}\n         */\n        this.year = util.assertValidYear(year);\n        /**\n         * The month.\n         * @type {NumberOrInteger}\n         */\n        this.month = util.assertValidMonth(month);\n        /**\n         * The day.\n         * @type {NumberOrInteger}\n         */\n        this.day = util.assertValidDay(day);\n        /**\n         * The hour.\n         * @type {NumberOrInteger}\n         */\n        this.hour = util.assertValidHour(hour);\n        /**\n         * The minute.\n         * @type {NumberOrInteger}\n         */\n        this.minute = util.assertValidMinute(minute);\n        /**\n         * The second.\n         * @type {NumberOrInteger}\n         */\n        this.second = util.assertValidSecond(second);\n        /**\n         * The nanosecond.\n         * @type {NumberOrInteger}\n         */\n        this.nanosecond = util.assertValidNanosecond(nanosecond);\n        var _a = __read(verifyTimeZoneArguments(timeZoneOffsetSeconds, timeZoneId), 2), offset = _a[0], id = _a[1];\n        /**\n         * The time zone offset in seconds.\n         *\n         * *Either this or {@link timeZoneId} is defined.*\n         *\n         * @type {NumberOrInteger}\n         */\n        this.timeZoneOffsetSeconds = offset;\n        /**\n         * The time zone id.\n         *\n         * *Either this or {@link timeZoneOffsetSeconds} is defined.*\n         *\n         * @type {string}\n         */\n        this.timeZoneId = id !== null && id !== void 0 ? id : undefined;\n        Object.freeze(this);\n    }\n    /**\n     * Create a {@link DateTime} object from the given standard JavaScript `Date` and optional nanoseconds.\n     * @param {global.Date} standardDate - The standard JavaScript date to convert.\n     * @param {NumberOrInteger|undefined} nanosecond - The optional amount of nanoseconds.\n     * @return {DateTime} New DateTime.\n     */\n    DateTime.fromStandardDate = function (standardDate, nanosecond) {\n        verifyStandardDateAndNanos(standardDate, nanosecond);\n        return new DateTime(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate(), standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), (0, integer_1.toNumber)(util.totalNanoseconds(standardDate, nanosecond)), util.timeZoneOffsetInSeconds(standardDate), null /* no time zone id */);\n    };\n    /**\n     * Convert date to standard JavaScript `Date`.\n     *\n     * @returns {StandardDate} Standard JavaScript `Date` at the defined time zone offset\n     * @throws {Error} If the time zone offset is not defined in the object.\n     */\n    DateTime.prototype.toStandardDate = function () {\n        return util.toStandardDate(this._toUTC());\n    };\n    /**\n     * @ignore\n     */\n    DateTime.prototype.toString = function () {\n        var _a;\n        var localDateTimeStr = localDateTimeToString(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);\n        var timeOffset = this.timeZoneOffsetSeconds != null\n            ? util.timeZoneOffsetToIsoString((_a = this.timeZoneOffsetSeconds) !== null && _a !== void 0 ? _a : 0)\n            : '';\n        var timeZoneStr = this.timeZoneId != null\n            ? \"[\".concat(this.timeZoneId, \"]\")\n            : '';\n        return localDateTimeStr + timeOffset + timeZoneStr;\n    };\n    /**\n     * @private\n     * @returns {number}\n     */\n    DateTime.prototype._toUTC = function () {\n        var _a;\n        if (this.timeZoneOffsetSeconds === undefined) {\n            throw new Error('Requires DateTime created with time zone offset');\n        }\n        var epochSecond = util.localDateTimeToEpochSecond(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);\n        var utcSecond = epochSecond.subtract((_a = this.timeZoneOffsetSeconds) !== null && _a !== void 0 ? _a : 0);\n        return (0, integer_1.int)(utcSecond)\n            .multiply(1000)\n            .add((0, integer_1.int)(this.nanosecond).div(1000000))\n            .toNumber();\n    };\n    return DateTime;\n}());\nexports.DateTime = DateTime;\nObject.defineProperty(DateTime.prototype, DATE_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\n * Test if given object is an instance of {@link DateTime} class.\n * @param {Object} obj - The object to test.\n * @return {boolean} `true` if given object is a {@link DateTime}, `false` otherwise.\n */\nfunction isDateTime(obj) {\n    return hasIdentifierProperty(obj, DATE_TIME_IDENTIFIER_PROPERTY);\n}\nexports.isDateTime = isDateTime;\nfunction hasIdentifierProperty(obj, property) {\n    return obj != null && obj[property] === true;\n}\nfunction localDateTimeToString(year, month, day, hour, minute, second, nanosecond) {\n    return (util.dateToIsoString(year, month, day) +\n        'T' +\n        util.timeToIsoString(hour, minute, second, nanosecond));\n}\n/**\n * @private\n * @param {NumberOrInteger} timeZoneOffsetSeconds\n * @param {string | null } timeZoneId\n * @returns {Array<NumberOrInteger | undefined | null, string | undefined | null>}\n */\nfunction verifyTimeZoneArguments(timeZoneOffsetSeconds, timeZoneId) {\n    var offsetDefined = timeZoneOffsetSeconds !== null && timeZoneOffsetSeconds !== undefined;\n    var idDefined = timeZoneId !== null && timeZoneId !== undefined && timeZoneId !== '';\n    if (!offsetDefined && !idDefined) {\n        throw (0, error_1.newError)(\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        \"Unable to create DateTime without either time zone offset or id. Please specify either of them. Given offset: \".concat(timeZoneOffsetSeconds, \" and id: \").concat(timeZoneId));\n    }\n    var result = [undefined, undefined];\n    if (offsetDefined) {\n        (0, util_1.assertNumberOrInteger)(timeZoneOffsetSeconds, 'Time zone offset in seconds');\n        result[0] = timeZoneOffsetSeconds;\n    }\n    if (idDefined) {\n        (0, util_1.assertString)(timeZoneId, 'Time zone ID');\n        util.assertValidZoneId('Time zone ID', timeZoneId);\n        result[1] = timeZoneId;\n    }\n    return result;\n}\n/**\n * @private\n * @param {StandardDate} standardDate\n * @param {NumberOrInteger} nanosecond\n * @returns {void}\n */\nfunction verifyStandardDateAndNanos(standardDate, nanosecond) {\n    (0, util_1.assertValidDate)(standardDate, 'Standard date');\n    if (nanosecond !== null && nanosecond !== undefined) {\n        (0, util_1.assertNumberOrInteger)(nanosecond, 'Nanosecond');\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3RlbXBvcmFsLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcscUJBQXFCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsWUFBWSxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQjtBQUN6Tyx3QkFBd0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDMUQsYUFBYSxtQkFBTyxDQUFDLG9GQUFpQjtBQUN0QyxjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0IsNkJBQTZCLG1CQUFPLENBQUMsd0VBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0QsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUyw2QkFBNkIsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3RlbXBvcmFsLXR5cGVzLmpzPzE3YWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzRGF0ZVRpbWUgPSBleHBvcnRzLkRhdGVUaW1lID0gZXhwb3J0cy5pc0xvY2FsRGF0ZVRpbWUgPSBleHBvcnRzLkxvY2FsRGF0ZVRpbWUgPSBleHBvcnRzLmlzRGF0ZSA9IGV4cG9ydHMuRGF0ZSA9IGV4cG9ydHMuaXNUaW1lID0gZXhwb3J0cy5UaW1lID0gZXhwb3J0cy5pc0xvY2FsVGltZSA9IGV4cG9ydHMuTG9jYWxUaW1lID0gZXhwb3J0cy5pc0R1cmF0aW9uID0gZXhwb3J0cy5EdXJhdGlvbiA9IHZvaWQgMDtcbnZhciB1dGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludGVybmFsL3RlbXBvcmFsLXV0aWxcIikpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxcIik7XG52YXIgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xudmFyIGludGVnZXJfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnRlZ2VyXCIpKTtcbnZhciBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMgPSB7XG4gICAgdmFsdWU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2Vcbn07XG52YXIgRFVSQVRJT05fSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzRHVyYXRpb25fXyc7XG52YXIgTE9DQUxfVElNRV9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNMb2NhbFRpbWVfXyc7XG52YXIgVElNRV9JREVOVElGSUVSX1BST1BFUlRZID0gJ19faXNUaW1lX18nO1xudmFyIERBVEVfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzRGF0ZV9fJztcbnZhciBMT0NBTF9EQVRFX1RJTUVfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzTG9jYWxEYXRlVGltZV9fJztcbnZhciBEQVRFX1RJTUVfSURFTlRJRklFUl9QUk9QRVJUWSA9ICdfX2lzRGF0ZVRpbWVfXyc7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSVNPIDg2MDEgZHVyYXRpb24uIENvbnRhaW5zIGJvdGggZGF0ZS1iYXNlZCB2YWx1ZXMgKHllYXJzLCBtb250aHMsIGRheXMpIGFuZCB0aW1lLWJhc2VkIHZhbHVlcyAoc2Vjb25kcywgbmFub3NlY29uZHMpLlxuICogQ3JlYXRlZCBgRHVyYXRpb25gIG9iamVjdHMgYXJlIGZyb3plbiB3aXRoIGBPYmplY3QuZnJlZXplKClgIGluIGNvbnN0cnVjdG9yIGFuZCB0aHVzIGltbXV0YWJsZS5cbiAqL1xudmFyIER1cmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBtb250aHMgLSBUaGUgbnVtYmVyIG9mIG1vbnRocyBmb3IgdGhlIG5ldyBkdXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gZGF5cyAtIFRoZSBudW1iZXIgb2YgZGF5cyBmb3IgdGhlIG5ldyBkdXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBmb3IgdGhlIG5ldyBkdXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gbmFub3NlY29uZHMgLSBUaGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzIGZvciB0aGUgbmV3IGR1cmF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIER1cmF0aW9uKG1vbnRocywgZGF5cywgc2Vjb25kcywgbmFub3NlY29uZHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgbW9udGhzLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb250aHMgPSAoMCwgdXRpbF8xLmFzc2VydE51bWJlck9ySW50ZWdlcikobW9udGhzLCAnTW9udGhzJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGRheXMuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRheXMgPSAoMCwgdXRpbF8xLmFzc2VydE51bWJlck9ySW50ZWdlcikoZGF5cywgJ0RheXMnKTtcbiAgICAgICAgKDAsIHV0aWxfMS5hc3NlcnROdW1iZXJPckludGVnZXIpKHNlY29uZHMsICdTZWNvbmRzJyk7XG4gICAgICAgICgwLCB1dGlsXzEuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKShuYW5vc2Vjb25kcywgJ05hbm9zZWNvbmRzJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHNlY29uZHMuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlY29uZHMgPSB1dGlsLm5vcm1hbGl6ZVNlY29uZHNGb3JEdXJhdGlvbihzZWNvbmRzLCBuYW5vc2Vjb25kcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIG5hbm9zZWNvbmRzLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyA9IHV0aWwubm9ybWFsaXplTmFub3NlY29uZHNGb3JEdXJhdGlvbihuYW5vc2Vjb25kcyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBEdXJhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmR1cmF0aW9uVG9Jc29TdHJpbmcodGhpcy5tb250aHMsIHRoaXMuZGF5cywgdGhpcy5zZWNvbmRzLCB0aGlzLm5hbm9zZWNvbmRzKTtcbiAgICB9O1xuICAgIHJldHVybiBEdXJhdGlvbjtcbn0oKSk7XG5leHBvcnRzLkR1cmF0aW9uID0gRHVyYXRpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVyYXRpb24ucHJvdG90eXBlLCBEVVJBVElPTl9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRHVyYXRpb259IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIER1cmF0aW9ufSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRHVyYXRpb24ob2JqKSB7XG4gICAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIERVUkFUSU9OX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuZXhwb3J0cy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW50IGNhcHR1cmluZyB0aGUgdGltZSBvZiBkYXksIGJ1dCBub3QgdGhlIGRhdGUsIG5vciB0aGUgdGltZXpvbmUuXG4gKiBDcmVhdGVkIHtAbGluayBMb2NhbFRpbWV9IG9iamVjdHMgYXJlIGZyb3plbiB3aXRoIGBPYmplY3QuZnJlZXplKClgIGluIGNvbnN0cnVjdG9yIGFuZCB0aHVzIGltbXV0YWJsZS5cbiAqL1xudmFyIExvY2FsVGltZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gaG91ciAtIFRoZSBob3VyIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IG1pbnV0ZSAtIFRoZSBtaW51dGUgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gc2Vjb25kIC0gVGhlIHNlY29uZCBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBuYW5vc2Vjb25kIC0gVGhlIG5hbm9zZWNvbmQgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2NhbFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBob3VyLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3VyID0gdXRpbC5hc3NlcnRWYWxpZEhvdXIoaG91cik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWludXRlLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW51dGUgPSB1dGlsLmFzc2VydFZhbGlkTWludXRlKG1pbnV0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2Vjb25kLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkU2Vjb25kKHNlY29uZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFub3NlY29uZC5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFub3NlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWROYW5vc2Vjb25kKG5hbm9zZWNvbmQpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgTG9jYWxUaW1lfSBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gc3RhbmRhcmQgSmF2YVNjcmlwdCBgRGF0ZWAgYW5kIG9wdGlvbmFsIG5hbm9zZWNvbmRzLlxuICAgICAqIFllYXIsIG1vbnRoLCBkYXkgYW5kIHRpbWUgem9uZSBvZmZzZXQgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gZGF0ZSBhcmUgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge2dsb2JhbC5EYXRlfSBzdGFuZGFyZERhdGUgLSBUaGUgc3RhbmRhcmQgSmF2YVNjcmlwdCBkYXRlIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ8dW5kZWZpbmVkfSBuYW5vc2Vjb25kIC0gVGhlIG9wdGlvbmFsIGFtb3VudCBvZiBuYW5vc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJuIHtMb2NhbFRpbWU8bnVtYmVyPn0gTmV3IExvY2FsVGltZS5cbiAgICAgKi9cbiAgICBMb2NhbFRpbWUuZnJvbVN0YW5kYXJkRGF0ZSA9IGZ1bmN0aW9uIChzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpIHtcbiAgICAgICAgdmVyaWZ5U3RhbmRhcmREYXRlQW5kTmFub3Moc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKTtcbiAgICAgICAgdmFyIHRvdGFsTmFub3NlY29uZHMgPSB1dGlsLnRvdGFsTmFub3NlY29uZHMoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoc3RhbmRhcmREYXRlLmdldEhvdXJzKCksIHN0YW5kYXJkRGF0ZS5nZXRNaW51dGVzKCksIHN0YW5kYXJkRGF0ZS5nZXRTZWNvbmRzKCksIHRvdGFsTmFub3NlY29uZHMgaW5zdGFuY2VvZiBpbnRlZ2VyXzEuZGVmYXVsdFxuICAgICAgICAgICAgPyB0b3RhbE5hbm9zZWNvbmRzLnRvSW50KClcbiAgICAgICAgICAgIDogdHlwZW9mIHRvdGFsTmFub3NlY29uZHMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgPyAoMCwgaW50ZWdlcl8xLmludCkodG90YWxOYW5vc2Vjb25kcykudG9JbnQoKVxuICAgICAgICAgICAgICAgIDogdG90YWxOYW5vc2Vjb25kcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgTG9jYWxUaW1lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwudGltZVRvSXNvU3RyaW5nKHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm5hbm9zZWNvbmQpO1xuICAgIH07XG4gICAgcmV0dXJuIExvY2FsVGltZTtcbn0oKSk7XG5leHBvcnRzLkxvY2FsVGltZSA9IExvY2FsVGltZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2NhbFRpbWUucHJvdG90eXBlLCBMT0NBTF9USU1FX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBMb2NhbFRpbWV9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4gb2JqZWN0IGlzIGEge0BsaW5rIExvY2FsVGltZX0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0xvY2FsVGltZShvYmopIHtcbiAgICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgTE9DQUxfVElNRV9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbmV4cG9ydHMuaXNMb2NhbFRpbWUgPSBpc0xvY2FsVGltZTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbnN0YW50IGNhcHR1cmluZyB0aGUgdGltZSBvZiBkYXksIGFuZCB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIHNlY29uZHMsIGJ1dCBub3QgdGhlIGRhdGUuXG4gKiBDcmVhdGVkIHtAbGluayBUaW1lfSBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cbnZhciBUaW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBob3VyIC0gVGhlIGhvdXIgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gbWludXRlIC0gVGhlIG1pbnV0ZSBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBzZWNvbmQgLSBUaGUgc2Vjb25kIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IG5hbm9zZWNvbmQgLSBUaGUgbmFub3NlY29uZCBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSB0aW1lWm9uZU9mZnNldFNlY29uZHMgLSBUaGUgdGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzLiBWYWx1ZSByZXByZXNlbnRzIHRoZSBkaWZmZXJlbmNlLCBpbiBzZWNvbmRzLCBmcm9tIFVUQyB0byBsb2NhbCB0aW1lLlxuICAgICAqIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gc3RhbmRhcmQgSmF2YVNjcmlwdCBgRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpYCB3aGljaCBpcyB0aGUgZGlmZmVyZW5jZSwgaW4gbWludXRlcywgZnJvbSBsb2NhbCB0aW1lIHRvIFVUQy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUaW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vc2Vjb25kLCB0aW1lWm9uZU9mZnNldFNlY29uZHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBob3VyLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3VyID0gdXRpbC5hc3NlcnRWYWxpZEhvdXIoaG91cik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWludXRlLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW51dGUgPSB1dGlsLmFzc2VydFZhbGlkTWludXRlKG1pbnV0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2Vjb25kLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkU2Vjb25kKHNlY29uZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFub3NlY29uZC5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFub3NlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWROYW5vc2Vjb25kKG5hbm9zZWNvbmQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcy5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGltZVpvbmVPZmZzZXRTZWNvbmRzID0gKDAsIHV0aWxfMS5hc3NlcnROdW1iZXJPckludGVnZXIpKHRpbWVab25lT2Zmc2V0U2Vjb25kcywgJ1RpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcycpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgVGltZX0gb2JqZWN0IGZyb20gdGhlIGdpdmVuIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgIGFuZCBvcHRpb25hbCBuYW5vc2Vjb25kcy5cbiAgICAgKiBZZWFyLCBtb250aCBhbmQgZGF5IGNvbXBvbmVudHMgb2YgdGhlIGdpdmVuIGRhdGUgYXJlIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIHtnbG9iYWwuRGF0ZX0gc3RhbmRhcmREYXRlIC0gVGhlIHN0YW5kYXJkIEphdmFTY3JpcHQgZGF0ZSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfHVuZGVmaW5lZH0gbmFub3NlY29uZCAtIFRoZSBvcHRpb25hbCBhbW91bnQgb2YgbmFub3NlY29uZHMuXG4gICAgICogQHJldHVybiB7VGltZTxudW1iZXI+fSBOZXcgVGltZS5cbiAgICAgKi9cbiAgICBUaW1lLmZyb21TdGFuZGFyZERhdGUgPSBmdW5jdGlvbiAoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSB7XG4gICAgICAgIHZlcmlmeVN0YW5kYXJkRGF0ZUFuZE5hbm9zKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCk7XG4gICAgICAgIHJldHVybiBuZXcgVGltZShzdGFuZGFyZERhdGUuZ2V0SG91cnMoKSwgc3RhbmRhcmREYXRlLmdldE1pbnV0ZXMoKSwgc3RhbmRhcmREYXRlLmdldFNlY29uZHMoKSwgKDAsIGludGVnZXJfMS50b051bWJlcikodXRpbC50b3RhbE5hbm9zZWNvbmRzKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCkpLCB1dGlsLnRpbWVab25lT2Zmc2V0SW5TZWNvbmRzKHN0YW5kYXJkRGF0ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIFRpbWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHV0aWwudGltZVRvSXNvU3RyaW5nKHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm5hbm9zZWNvbmQpICsgdXRpbC50aW1lWm9uZU9mZnNldFRvSXNvU3RyaW5nKHRoaXMudGltZVpvbmVPZmZzZXRTZWNvbmRzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZTtcbn0oKSk7XG5leHBvcnRzLlRpbWUgPSBUaW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpbWUucHJvdG90eXBlLCBUSU1FX0lERU5USUZJRVJfUFJPUEVSVFksIElERU5USUZJRVJfUFJPUEVSVFlfQVRUUklCVVRFUyk7XG4vKipcbiAqIFRlc3QgaWYgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBUaW1lfSBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBUaW1lfSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVGltZShvYmopIHtcbiAgICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgVElNRV9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbmV4cG9ydHMuaXNUaW1lID0gaXNUaW1lO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbnQgY2FwdHVyaW5nIHRoZSBkYXRlLCBidXQgbm90IHRoZSB0aW1lLCBub3IgdGhlIHRpbWV6b25lLlxuICogQ3JlYXRlZCB7QGxpbmsgRGF0ZX0gb2JqZWN0cyBhcmUgZnJvemVuIHdpdGggYE9iamVjdC5mcmVlemUoKWAgaW4gY29uc3RydWN0b3IgYW5kIHRodXMgaW1tdXRhYmxlLlxuICovXG52YXIgRGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0geWVhciAtIFRoZSB5ZWFyIGZvciB0aGUgbmV3IGxvY2FsIGRhdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IG1vbnRoIC0gVGhlIG1vbnRoIGZvciB0aGUgbmV3IGxvY2FsIGRhdGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IGRheSAtIFRoZSBkYXkgZm9yIHRoZSBuZXcgbG9jYWwgZGF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRlKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB5ZWFyLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ZWFyID0gdXRpbC5hc3NlcnRWYWxpZFllYXIoeWVhcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbW9udGguXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vbnRoID0gdXRpbC5hc3NlcnRWYWxpZE1vbnRoKG1vbnRoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXkuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRheSA9IHV0aWwuYXNzZXJ0VmFsaWREYXkoZGF5KTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEge0BsaW5rIERhdGV9IG9iamVjdCBmcm9tIHRoZSBnaXZlbiBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlYC5cbiAgICAgKiBIb3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgYW5kIHRpbWUgem9uZSBvZmZzZXQgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gZGF0ZSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IHRoZSBmdW5jdGlvbiB7QGxpbmsgdG9TdGFuZGFyZERhdGV9IGFuZCB7QGxpbmsgZnJvbVN0YW5kYXJkRGF0ZX0gYXJlIG5vdCBpbnZlcnNlcyBvZiBvbmUgYW5vdGhlci4ge0BsaW5rIGZyb21TdGFuZGFyZERhdGV9IHRha2VzIHRoZSBEYXksIE1vbnRoIGFuZCBZZWFyIGluIGxvY2FsIHRpbWUgZnJvbSB0aGUgc3VwcGxpZXMgSmF2YVNjcmlwdCBEYXRlIG9iamVjdCwgd2hpbGUge0BsaW5rIHRvU3RhbmRhcmREYXRlfSBjcmVhdGVzIGEgbmV3IEphdmFTY3JpcHQgRGF0ZSBvYmplY3QgYXQgbWlkbmlnaHQgVVRDLiBUaGlzIGluY29uZ3J1aXR5IHdpbGwgYmUgcmVjdGlmaWVkIGluIDYuMFxuICAgICAqIElmIHlvdXIgdGltZXpvbmUgaGFzIGEgbmVnYXRpdmUgb2Zmc2V0IGZyb20gVVRDLCBjcmVhdGluZyBhIEphdmFTY3JpcHQgRGF0ZSBhdCBtaWRuaWdodCBVVEMgYW5kIGNvbnZlcnRpbmcgaXQgd2l0aCB7QGxpbmsgZnJvbVN0YW5kYXJkRGF0ZX0gd2lsbCByZXN1bHQgaW4gYSBEYXRlIGZvciB0aGUgZGF5IGJlZm9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Z2xvYmFsLkRhdGV9IHN0YW5kYXJkRGF0ZSAtIFRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSBOZXcgRGF0ZS5cbiAgICAgKi9cbiAgICBEYXRlLmZyb21TdGFuZGFyZERhdGUgPSBmdW5jdGlvbiAoc3RhbmRhcmREYXRlKSB7XG4gICAgICAgIHZlcmlmeVN0YW5kYXJkRGF0ZUFuZE5hbm9zKHN0YW5kYXJkRGF0ZSk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShzdGFuZGFyZERhdGUuZ2V0RnVsbFllYXIoKSwgc3RhbmRhcmREYXRlLmdldE1vbnRoKCkgKyAxLCBzdGFuZGFyZERhdGUuZ2V0RGF0ZSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZGF0ZSB0byBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlYC5cbiAgICAgKlxuICAgICAqIFRoZSB0aW1lIGNvbXBvbmVudCBvZiB0aGUgcmV0dXJuZWQgYERhdGVgIGlzIHNldCB0byBtaWRuaWdodFxuICAgICAqIGFuZCB0aGUgdGltZSB6b25lIGlzIHNldCB0byBVVEMuXG4gICAgICpcbiAgICAgKiBOT1RFOiB0aGUgZnVuY3Rpb24ge0BsaW5rIHRvU3RhbmRhcmREYXRlfSBhbmQge0BsaW5rIGZyb21TdGFuZGFyZERhdGV9IGFyZSBub3QgaW52ZXJzZXMgb2Ygb25lIGFub3RoZXIuIHtAbGluayBmcm9tU3RhbmRhcmREYXRlfSB0YWtlcyB0aGUgRGF5LCBNb250aCBhbmQgWWVhciBpbiBsb2NhbCB0aW1lIGZyb20gdGhlIHN1cHBsaWVzIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QsIHdoaWxlIHtAbGluayB0b1N0YW5kYXJkRGF0ZX0gY3JlYXRlcyBhIG5ldyBKYXZhU2NyaXB0IERhdGUgb2JqZWN0IGF0IG1pZG5pZ2h0IFVUQy4gVGhpcyBpbmNvbmdydWl0eSB3aWxsIGJlIHJlY3RpZmllZCBpbiA2LjBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdGFuZGFyZERhdGV9IFN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgIGF0IGAwMDowMDowMC4wMDBgIFVUQy5cbiAgICAgKi9cbiAgICBEYXRlLnByb3RvdHlwZS50b1N0YW5kYXJkRGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaXNvU3RyaW5nVG9TdGFuZGFyZERhdGUodGhpcy50b1N0cmluZygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZGF0ZVRvSXNvU3RyaW5nKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXkpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGU7XG59KCkpO1xuZXhwb3J0cy5EYXRlID0gRGF0ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlLnByb3RvdHlwZSwgREFURV9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRGF0ZX0gY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIG9iamVjdCBpcyBhIHtAbGluayBEYXRlfSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgREFURV9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbnQgY2FwdHVyaW5nIHRoZSBkYXRlIGFuZCB0aGUgdGltZSwgYnV0IG5vdCB0aGUgdGltZXpvbmUuXG4gKiBDcmVhdGVkIHtAbGluayBMb2NhbERhdGVUaW1lfSBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cbnZhciBMb2NhbERhdGVUaW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSB5ZWFyIC0gVGhlIHllYXIgZm9yIHRoZSBuZXcgbG9jYWwgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gbW9udGggLSBUaGUgbW9udGggZm9yIHRoZSBuZXcgbG9jYWwgZGF0ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gZGF5IC0gVGhlIGRheSBmb3IgdGhlIG5ldyBsb2NhbCBkYXRlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBob3VyIC0gVGhlIGhvdXIgZm9yIHRoZSBuZXcgbG9jYWwgdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gbWludXRlIC0gVGhlIG1pbnV0ZSBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBzZWNvbmQgLSBUaGUgc2Vjb25kIGZvciB0aGUgbmV3IGxvY2FsIHRpbWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IG5hbm9zZWNvbmQgLSBUaGUgbmFub3NlY29uZCBmb3IgdGhlIG5ldyBsb2NhbCB0aW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvY2FsRGF0ZVRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB5ZWFyLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ZWFyID0gdXRpbC5hc3NlcnRWYWxpZFllYXIoeWVhcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbW9udGguXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vbnRoID0gdXRpbC5hc3NlcnRWYWxpZE1vbnRoKG1vbnRoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXkuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRheSA9IHV0aWwuYXNzZXJ0VmFsaWREYXkoZGF5KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBob3VyLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ob3VyID0gdXRpbC5hc3NlcnRWYWxpZEhvdXIoaG91cik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWludXRlLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW51dGUgPSB1dGlsLmFzc2VydFZhbGlkTWludXRlKG1pbnV0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2Vjb25kLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkU2Vjb25kKHNlY29uZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbmFub3NlY29uZC5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFub3NlY29uZCA9IHV0aWwuYXNzZXJ0VmFsaWROYW5vc2Vjb25kKG5hbm9zZWNvbmQpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB7QGxpbmsgTG9jYWxEYXRlVGltZX0gb2JqZWN0IGZyb20gdGhlIGdpdmVuIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgIGFuZCBvcHRpb25hbCBuYW5vc2Vjb25kcy5cbiAgICAgKiBUaW1lIHpvbmUgb2Zmc2V0IGNvbXBvbmVudCBvZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSB7Z2xvYmFsLkRhdGV9IHN0YW5kYXJkRGF0ZSAtIFRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcnx1bmRlZmluZWR9IG5hbm9zZWNvbmQgLSBUaGUgb3B0aW9uYWwgYW1vdW50IG9mIG5hbm9zZWNvbmRzLlxuICAgICAqIEByZXR1cm4ge0xvY2FsRGF0ZVRpbWV9IE5ldyBMb2NhbERhdGVUaW1lLlxuICAgICAqL1xuICAgIExvY2FsRGF0ZVRpbWUuZnJvbVN0YW5kYXJkRGF0ZSA9IGZ1bmN0aW9uIChzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpIHtcbiAgICAgICAgdmVyaWZ5U3RhbmRhcmREYXRlQW5kTmFub3Moc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbERhdGVUaW1lKHN0YW5kYXJkRGF0ZS5nZXRGdWxsWWVhcigpLCBzdGFuZGFyZERhdGUuZ2V0TW9udGgoKSArIDEsIHN0YW5kYXJkRGF0ZS5nZXREYXRlKCksIHN0YW5kYXJkRGF0ZS5nZXRIb3VycygpLCBzdGFuZGFyZERhdGUuZ2V0TWludXRlcygpLCBzdGFuZGFyZERhdGUuZ2V0U2Vjb25kcygpLCAoMCwgaW50ZWdlcl8xLnRvTnVtYmVyKSh1dGlsLnRvdGFsTmFub3NlY29uZHMoc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCBkYXRlIHRvIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0YW5kYXJkRGF0ZX0gU3RhbmRhcmQgSmF2YVNjcmlwdCBgRGF0ZWAgYXQgdGhlIGxvY2FsIHRpbWV6b25lXG4gICAgICovXG4gICAgTG9jYWxEYXRlVGltZS5wcm90b3R5cGUudG9TdGFuZGFyZERhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmlzb1N0cmluZ1RvU3RhbmRhcmREYXRlKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgTG9jYWxEYXRlVGltZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGVUaW1lVG9TdHJpbmcodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSwgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIHRoaXMubmFub3NlY29uZCk7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxEYXRlVGltZTtcbn0oKSk7XG5leHBvcnRzLkxvY2FsRGF0ZVRpbWUgPSBMb2NhbERhdGVUaW1lO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvY2FsRGF0ZVRpbWUucHJvdG90eXBlLCBMT0NBTF9EQVRFX1RJTUVfSURFTlRJRklFUl9QUk9QRVJUWSwgSURFTlRJRklFUl9QUk9QRVJUWV9BVFRSSUJVVEVTKTtcbi8qKlxuICogVGVzdCBpZiBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIExvY2FsRGF0ZVRpbWV9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgTG9jYWxEYXRlVGltZX0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0xvY2FsRGF0ZVRpbWUob2JqKSB7XG4gICAgcmV0dXJuIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIExPQ0FMX0RBVEVfVElNRV9JREVOVElGSUVSX1BST1BFUlRZKTtcbn1cbmV4cG9ydHMuaXNMb2NhbERhdGVUaW1lID0gaXNMb2NhbERhdGVUaW1lO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbnQgY2FwdHVyaW5nIHRoZSBkYXRlLCB0aGUgdGltZSBhbmQgdGhlIHRpbWV6b25lIGlkZW50aWZpZXIuXG4gKiBDcmVhdGVkIHtAIERhdGVUaW1lfSBvYmplY3RzIGFyZSBmcm96ZW4gd2l0aCBgT2JqZWN0LmZyZWV6ZSgpYCBpbiBjb25zdHJ1Y3RvciBhbmQgdGh1cyBpbW11dGFibGUuXG4gKi9cbnZhciBEYXRlVGltZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0geWVhciAtIFRoZSB5ZWFyIGZvciB0aGUgbmV3IGRhdGUtdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gbW9udGggLSBUaGUgbW9udGggZm9yIHRoZSBuZXcgZGF0ZS10aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBkYXkgLSBUaGUgZGF5IGZvciB0aGUgbmV3IGRhdGUtdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gaG91ciAtIFRoZSBob3VyIGZvciB0aGUgbmV3IGRhdGUtdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gbWludXRlIC0gVGhlIG1pbnV0ZSBmb3IgdGhlIG5ldyBkYXRlLXRpbWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJPckludGVnZXJ9IHNlY29uZCAtIFRoZSBzZWNvbmQgZm9yIHRoZSBuZXcgZGF0ZS10aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSBuYW5vc2Vjb25kIC0gVGhlIG5hbm9zZWNvbmQgZm9yIHRoZSBuZXcgZGF0ZS10aW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSB0aW1lWm9uZU9mZnNldFNlY29uZHMgLSBUaGUgdGltZSB6b25lIG9mZnNldCBpbiBzZWNvbmRzLiBFaXRoZXIgdGhpcyBhcmd1bWVudCBvciBgdGltZVpvbmVJZGAgc2hvdWxkIGJlIGRlZmluZWQuXG4gICAgICogVmFsdWUgcmVwcmVzZW50cyB0aGUgZGlmZmVyZW5jZSwgaW4gc2Vjb25kcywgZnJvbSBVVEMgdG8gbG9jYWwgdGltZS5cbiAgICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKWAgd2hpY2ggaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gbG9jYWwgdGltZSB0byBVVEMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdGltZVpvbmVJZCAtIFRoZSB0aW1lIHpvbmUgaWQgZm9yIHRoZSBuZXcgZGF0ZS10aW1lLiBFaXRoZXIgdGhpcyBhcmd1bWVudCBvciBgdGltZVpvbmVPZmZzZXRTZWNvbmRzYCBzaG91bGQgYmUgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRlVGltZSh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub3NlY29uZCwgdGltZVpvbmVPZmZzZXRTZWNvbmRzLCB0aW1lWm9uZUlkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgeWVhci5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueWVhciA9IHV0aWwuYXNzZXJ0VmFsaWRZZWFyKHllYXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vbnRoLlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb250aCA9IHV0aWwuYXNzZXJ0VmFsaWRNb250aChtb250aCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF5LlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyT3JJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXkgPSB1dGlsLmFzc2VydFZhbGlkRGF5KGRheSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaG91ci5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaG91ciA9IHV0aWwuYXNzZXJ0VmFsaWRIb3VyKGhvdXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1pbnV0ZS5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWludXRlID0gdXRpbC5hc3NlcnRWYWxpZE1pbnV0ZShtaW51dGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlY29uZC5cbiAgICAgICAgICogQHR5cGUge051bWJlck9ySW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Vjb25kID0gdXRpbC5hc3NlcnRWYWxpZFNlY29uZChzZWNvbmQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbm9zZWNvbmQuXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbm9zZWNvbmQgPSB1dGlsLmFzc2VydFZhbGlkTmFub3NlY29uZChuYW5vc2Vjb25kKTtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHZlcmlmeVRpbWVab25lQXJndW1lbnRzKHRpbWVab25lT2Zmc2V0U2Vjb25kcywgdGltZVpvbmVJZCksIDIpLCBvZmZzZXQgPSBfYVswXSwgaWQgPSBfYVsxXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHpvbmUgb2Zmc2V0IGluIHNlY29uZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqICpFaXRoZXIgdGhpcyBvciB7QGxpbmsgdGltZVpvbmVJZH0gaXMgZGVmaW5lZC4qXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJPckludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVab25lT2Zmc2V0U2Vjb25kcyA9IG9mZnNldDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHpvbmUgaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqICpFaXRoZXIgdGhpcyBvciB7QGxpbmsgdGltZVpvbmVPZmZzZXRTZWNvbmRzfSBpcyBkZWZpbmVkLipcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGltZVpvbmVJZCA9IGlkICE9PSBudWxsICYmIGlkICE9PSB2b2lkIDAgPyBpZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEge0BsaW5rIERhdGVUaW1lfSBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gc3RhbmRhcmQgSmF2YVNjcmlwdCBgRGF0ZWAgYW5kIG9wdGlvbmFsIG5hbm9zZWNvbmRzLlxuICAgICAqIEBwYXJhbSB7Z2xvYmFsLkRhdGV9IHN0YW5kYXJkRGF0ZSAtIFRoZSBzdGFuZGFyZCBKYXZhU2NyaXB0IGRhdGUgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcnx1bmRlZmluZWR9IG5hbm9zZWNvbmQgLSBUaGUgb3B0aW9uYWwgYW1vdW50IG9mIG5hbm9zZWNvbmRzLlxuICAgICAqIEByZXR1cm4ge0RhdGVUaW1lfSBOZXcgRGF0ZVRpbWUuXG4gICAgICovXG4gICAgRGF0ZVRpbWUuZnJvbVN0YW5kYXJkRGF0ZSA9IGZ1bmN0aW9uIChzdGFuZGFyZERhdGUsIG5hbm9zZWNvbmQpIHtcbiAgICAgICAgdmVyaWZ5U3RhbmRhcmREYXRlQW5kTmFub3Moc3RhbmRhcmREYXRlLCBuYW5vc2Vjb25kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZShzdGFuZGFyZERhdGUuZ2V0RnVsbFllYXIoKSwgc3RhbmRhcmREYXRlLmdldE1vbnRoKCkgKyAxLCBzdGFuZGFyZERhdGUuZ2V0RGF0ZSgpLCBzdGFuZGFyZERhdGUuZ2V0SG91cnMoKSwgc3RhbmRhcmREYXRlLmdldE1pbnV0ZXMoKSwgc3RhbmRhcmREYXRlLmdldFNlY29uZHMoKSwgKDAsIGludGVnZXJfMS50b051bWJlcikodXRpbC50b3RhbE5hbm9zZWNvbmRzKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCkpLCB1dGlsLnRpbWVab25lT2Zmc2V0SW5TZWNvbmRzKHN0YW5kYXJkRGF0ZSksIG51bGwgLyogbm8gdGltZSB6b25lIGlkICovKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZGF0ZSB0byBzdGFuZGFyZCBKYXZhU2NyaXB0IGBEYXRlYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdGFuZGFyZERhdGV9IFN0YW5kYXJkIEphdmFTY3JpcHQgYERhdGVgIGF0IHRoZSBkZWZpbmVkIHRpbWUgem9uZSBvZmZzZXRcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHRpbWUgem9uZSBvZmZzZXQgaXMgbm90IGRlZmluZWQgaW4gdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBEYXRlVGltZS5wcm90b3R5cGUudG9TdGFuZGFyZERhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsLnRvU3RhbmRhcmREYXRlKHRoaXMuX3RvVVRDKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIERhdGVUaW1lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgbG9jYWxEYXRlVGltZVN0ciA9IGxvY2FsRGF0ZVRpbWVUb1N0cmluZyh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5uYW5vc2Vjb25kKTtcbiAgICAgICAgdmFyIHRpbWVPZmZzZXQgPSB0aGlzLnRpbWVab25lT2Zmc2V0U2Vjb25kcyAhPSBudWxsXG4gICAgICAgICAgICA/IHV0aWwudGltZVpvbmVPZmZzZXRUb0lzb1N0cmluZygoX2EgPSB0aGlzLnRpbWVab25lT2Zmc2V0U2Vjb25kcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMClcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIHZhciB0aW1lWm9uZVN0ciA9IHRoaXMudGltZVpvbmVJZCAhPSBudWxsXG4gICAgICAgICAgICA/IFwiW1wiLmNvbmNhdCh0aGlzLnRpbWVab25lSWQsIFwiXVwiKVxuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgcmV0dXJuIGxvY2FsRGF0ZVRpbWVTdHIgKyB0aW1lT2Zmc2V0ICsgdGltZVpvbmVTdHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgRGF0ZVRpbWUucHJvdG90eXBlLl90b1VUQyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZU9mZnNldFNlY29uZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlcyBEYXRlVGltZSBjcmVhdGVkIHdpdGggdGltZSB6b25lIG9mZnNldCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcG9jaFNlY29uZCA9IHV0aWwubG9jYWxEYXRlVGltZVRvRXBvY2hTZWNvbmQodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSwgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIHRoaXMubmFub3NlY29uZCk7XG4gICAgICAgIHZhciB1dGNTZWNvbmQgPSBlcG9jaFNlY29uZC5zdWJ0cmFjdCgoX2EgPSB0aGlzLnRpbWVab25lT2Zmc2V0U2Vjb25kcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgICAgIHJldHVybiAoMCwgaW50ZWdlcl8xLmludCkodXRjU2Vjb25kKVxuICAgICAgICAgICAgLm11bHRpcGx5KDEwMDApXG4gICAgICAgICAgICAuYWRkKCgwLCBpbnRlZ2VyXzEuaW50KSh0aGlzLm5hbm9zZWNvbmQpLmRpdigxMDAwMDAwKSlcbiAgICAgICAgICAgIC50b051bWJlcigpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVUaW1lO1xufSgpKTtcbmV4cG9ydHMuRGF0ZVRpbWUgPSBEYXRlVGltZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlVGltZS5wcm90b3R5cGUsIERBVEVfVElNRV9JREVOVElGSUVSX1BST1BFUlRZLCBJREVOVElGSUVSX1BST1BFUlRZX0FUVFJJQlVURVMpO1xuLyoqXG4gKiBUZXN0IGlmIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRGF0ZVRpbWV9IGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBvYmplY3QgaXMgYSB7QGxpbmsgRGF0ZVRpbWV9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNEYXRlVGltZShvYmopIHtcbiAgICByZXR1cm4gaGFzSWRlbnRpZmllclByb3BlcnR5KG9iaiwgREFURV9USU1FX0lERU5USUZJRVJfUFJPUEVSVFkpO1xufVxuZXhwb3J0cy5pc0RhdGVUaW1lID0gaXNEYXRlVGltZTtcbmZ1bmN0aW9uIGhhc0lkZW50aWZpZXJQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9ialtwcm9wZXJ0eV0gPT09IHRydWU7XG59XG5mdW5jdGlvbiBsb2NhbERhdGVUaW1lVG9TdHJpbmcoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpIHtcbiAgICByZXR1cm4gKHV0aWwuZGF0ZVRvSXNvU3RyaW5nKHllYXIsIG1vbnRoLCBkYXkpICtcbiAgICAgICAgJ1QnICtcbiAgICAgICAgdXRpbC50aW1lVG9Jc29TdHJpbmcoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9zZWNvbmQpKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyT3JJbnRlZ2VyfSB0aW1lWm9uZU9mZnNldFNlY29uZHNcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB9IHRpbWVab25lSWRcbiAqIEByZXR1cm5zIHtBcnJheTxOdW1iZXJPckludGVnZXIgfCB1bmRlZmluZWQgfCBudWxsLCBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsPn1cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5VGltZVpvbmVBcmd1bWVudHModGltZVpvbmVPZmZzZXRTZWNvbmRzLCB0aW1lWm9uZUlkKSB7XG4gICAgdmFyIG9mZnNldERlZmluZWQgPSB0aW1lWm9uZU9mZnNldFNlY29uZHMgIT09IG51bGwgJiYgdGltZVpvbmVPZmZzZXRTZWNvbmRzICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIGlkRGVmaW5lZCA9IHRpbWVab25lSWQgIT09IG51bGwgJiYgdGltZVpvbmVJZCAhPT0gdW5kZWZpbmVkICYmIHRpbWVab25lSWQgIT09ICcnO1xuICAgIGlmICghb2Zmc2V0RGVmaW5lZCAmJiAhaWREZWZpbmVkKSB7XG4gICAgICAgIHRocm93ICgwLCBlcnJvcl8xLm5ld0Vycm9yKShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICBcIlVuYWJsZSB0byBjcmVhdGUgRGF0ZVRpbWUgd2l0aG91dCBlaXRoZXIgdGltZSB6b25lIG9mZnNldCBvciBpZC4gUGxlYXNlIHNwZWNpZnkgZWl0aGVyIG9mIHRoZW0uIEdpdmVuIG9mZnNldDogXCIuY29uY2F0KHRpbWVab25lT2Zmc2V0U2Vjb25kcywgXCIgYW5kIGlkOiBcIikuY29uY2F0KHRpbWVab25lSWQpKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gICAgaWYgKG9mZnNldERlZmluZWQpIHtcbiAgICAgICAgKDAsIHV0aWxfMS5hc3NlcnROdW1iZXJPckludGVnZXIpKHRpbWVab25lT2Zmc2V0U2Vjb25kcywgJ1RpbWUgem9uZSBvZmZzZXQgaW4gc2Vjb25kcycpO1xuICAgICAgICByZXN1bHRbMF0gPSB0aW1lWm9uZU9mZnNldFNlY29uZHM7XG4gICAgfVxuICAgIGlmIChpZERlZmluZWQpIHtcbiAgICAgICAgKDAsIHV0aWxfMS5hc3NlcnRTdHJpbmcpKHRpbWVab25lSWQsICdUaW1lIHpvbmUgSUQnKTtcbiAgICAgICAgdXRpbC5hc3NlcnRWYWxpZFpvbmVJZCgnVGltZSB6b25lIElEJywgdGltZVpvbmVJZCk7XG4gICAgICAgIHJlc3VsdFsxXSA9IHRpbWVab25lSWQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0YW5kYXJkRGF0ZX0gc3RhbmRhcmREYXRlXG4gKiBAcGFyYW0ge051bWJlck9ySW50ZWdlcn0gbmFub3NlY29uZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHZlcmlmeVN0YW5kYXJkRGF0ZUFuZE5hbm9zKHN0YW5kYXJkRGF0ZSwgbmFub3NlY29uZCkge1xuICAgICgwLCB1dGlsXzEuYXNzZXJ0VmFsaWREYXRlKShzdGFuZGFyZERhdGUsICdTdGFuZGFyZCBkYXRlJyk7XG4gICAgaWYgKG5hbm9zZWNvbmQgIT09IG51bGwgJiYgbmFub3NlY29uZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICgwLCB1dGlsXzEuYXNzZXJ0TnVtYmVyT3JJbnRlZ2VyKShuYW5vc2Vjb25kLCAnTmFub3NlY29uZCcpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/temporal-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/transaction-managed.js":
/*!*******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/transaction-managed.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Represents a transaction that is managed by the transaction executor.\n *\n * @public\n */\nvar ManagedTransaction = /** @class */ (function () {\n    /**\n     * @private\n     */\n    function ManagedTransaction(_a) {\n        var run = _a.run;\n        /**\n         * @private\n         */\n        this._run = run;\n    }\n    /**\n     * @private\n     * @param {Transaction} tx - Transaction to wrap\n     * @returns {ManagedTransaction} the ManagedTransaction\n     */\n    ManagedTransaction.fromTransaction = function (tx) {\n        return new ManagedTransaction({\n            run: tx.run.bind(tx)\n        });\n    };\n    /**\n     * Run Cypher query\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the query and parameters as separate arguments.\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @return {Result} New Result\n     */\n    ManagedTransaction.prototype.run = function (query, parameters) {\n        return this._run(query, parameters);\n    };\n    return ManagedTransaction;\n}());\nexports[\"default\"] = ManagedTransaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3RyYW5zYWN0aW9uLW1hbmFnZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0NBQWdDLFVBQVU7QUFDN0Y7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi90cmFuc2FjdGlvbi1tYW5hZ2VkLmpzP2IzMTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgXCJOZW80alwiXG4gKiBOZW80aiBTd2VkZW4gQUIgW2h0dHBzOi8vbmVvNGouY29tXVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24gdGhhdCBpcyBtYW5hZ2VkIGJ5IHRoZSB0cmFuc2FjdGlvbiBleGVjdXRvci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBNYW5hZ2VkVHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYW5hZ2VkVHJhbnNhY3Rpb24oX2EpIHtcbiAgICAgICAgdmFyIHJ1biA9IF9hLnJ1bjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ydW4gPSBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHggLSBUcmFuc2FjdGlvbiB0byB3cmFwXG4gICAgICogQHJldHVybnMge01hbmFnZWRUcmFuc2FjdGlvbn0gdGhlIE1hbmFnZWRUcmFuc2FjdGlvblxuICAgICAqL1xuICAgIE1hbmFnZWRUcmFuc2FjdGlvbi5mcm9tVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYW5hZ2VkVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgcnVuOiB0eC5ydW4uYmluZCh0eClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSdW4gQ3lwaGVyIHF1ZXJ5XG4gICAgICogQ291bGQgYmUgY2FsbGVkIHdpdGggYSBxdWVyeSBvYmplY3QgaS5lLjogYHt0ZXh0OiBcIk1BVENIIC4uLlwiLCBwYXJhbWV0ZXJzOiB7cGFyYW06IDF9fWBcbiAgICAgKiBvciB3aXRoIHRoZSBxdWVyeSBhbmQgcGFyYW1ldGVycyBhcyBzZXBhcmF0ZSBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHttaXhlZH0gcXVlcnkgLSBDeXBoZXIgcXVlcnkgdG8gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIC0gTWFwIHdpdGggcGFyYW1ldGVycyB0byB1c2UgaW4gcXVlcnlcbiAgICAgKiBAcmV0dXJuIHtSZXN1bHR9IE5ldyBSZXN1bHRcbiAgICAgKi9cbiAgICBNYW5hZ2VkVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChxdWVyeSwgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuKHF1ZXJ5LCBwYXJhbWV0ZXJzKTtcbiAgICB9O1xuICAgIHJldHVybiBNYW5hZ2VkVHJhbnNhY3Rpb247XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWFuYWdlZFRyYW5zYWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/transaction-managed.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/transaction-promise.js":
/*!*******************************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/transaction-promise.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar transaction_1 = __importDefault(__webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/neo4j-driver-core/lib/transaction.js\"));\n/**\n * Represents a Promise<{@link Transaction}> object and a {@link Transaction} object.\n *\n * Resolving this object promise verifies the result of the transaction begin and returns the {@link Transaction} object in case of success.\n *\n * The object can still also used as {@link Transaction} for convenience. The result of begin will be checked\n * during the next API calls in the object as it is in the transaction.\n *\n * @access public\n */\nvar TransactionPromise = /** @class */ (function (_super) {\n    __extends(TransactionPromise, _super);\n    /**\n     * @constructor\n     * @param {object} args\n     * @param {ConnectionHolder} args.connectionHolder - the connection holder to get connection from.\n     * @param {function()} args.onClose - Function to be called when transaction is committed or rolled back.\n     * @param {function(bookmarks: Bookmarks)} args.onBookmarks callback invoked when new bookmark is produced.\n     * @param {function()} args.onConnection - Function to be called when a connection is obtained to ensure the connection\n     * is not yet released.\n     * @param {boolean} args.reactive whether this transaction generates reactive streams\n     * @param {number} args.fetchSize - the record fetch size in each pulling batch.\n     * @param {string} args.impersonatedUser - The name of the user which should be impersonated for the duration of the session.\n     * @param {NotificationFilter} args.notificationFilter - The notification filter used for this transaction.\n     * @param {NonAutoCommitApiTelemetryConfig} args.apiTelemetryConfig - The api telemetry configuration. Empty/Null for disabling telemetry\n     */\n    function TransactionPromise(_b) {\n        var connectionHolder = _b.connectionHolder, onClose = _b.onClose, onBookmarks = _b.onBookmarks, onConnection = _b.onConnection, reactive = _b.reactive, fetchSize = _b.fetchSize, impersonatedUser = _b.impersonatedUser, highRecordWatermark = _b.highRecordWatermark, lowRecordWatermark = _b.lowRecordWatermark, notificationFilter = _b.notificationFilter, apiTelemetryConfig = _b.apiTelemetryConfig, onDbCallback = _b.onDbCallback;\n        var _this = _super.call(this, {\n            connectionHolder: connectionHolder,\n            onClose: onClose,\n            onBookmarks: onBookmarks,\n            onConnection: onConnection,\n            reactive: reactive,\n            fetchSize: fetchSize,\n            impersonatedUser: impersonatedUser,\n            highRecordWatermark: highRecordWatermark,\n            lowRecordWatermark: lowRecordWatermark,\n            notificationFilter: notificationFilter,\n            apiTelemetryConfig: apiTelemetryConfig\n        }) || this;\n        _this[_a] = 'TransactionPromise';\n        _this._onDbCallback = onDbCallback;\n        return _this;\n    }\n    /**\n     * Waits for the begin to complete.\n     *\n     * @param {function(transaction: Transaction)} onFulfilled - function to be called when finished.\n     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.\n     * @return {Promise} promise.\n     */\n    TransactionPromise.prototype.then = function (onfulfilled, onrejected) {\n        return this._getOrCreateBeginPromise().then(onfulfilled, onrejected);\n    };\n    /**\n     * Catch errors when using promises.\n     *\n     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.\n     * @return {Promise} promise.\n     */\n    TransactionPromise.prototype.catch = function (onrejected) {\n        return this._getOrCreateBeginPromise().catch(onrejected);\n    };\n    /**\n     * Called when finally the begin is done\n     *\n     * @param {function()|null} onfinally - function when the promise finished\n     * @return {Promise} promise.\n     */\n    TransactionPromise.prototype.finally = function (onfinally) {\n        return this._getOrCreateBeginPromise().finally(onfinally);\n    };\n    TransactionPromise.prototype._getOrCreateBeginPromise = function () {\n        var _this = this;\n        if (this._beginPromise == null) {\n            this._beginPromise = new Promise(function (resolve, reject) {\n                _this._resolve = resolve;\n                _this._reject = reject;\n                if (_this._beginError != null) {\n                    reject(_this._beginError);\n                }\n                if (_this._beginMetadata != null) {\n                    resolve(_this._toTransaction());\n                }\n            });\n        }\n        return this._beginPromise;\n    };\n    /**\n     * @access private\n     */\n    TransactionPromise.prototype._toTransaction = function () {\n        return __assign(__assign({}, this), { run: _super.prototype.run.bind(this), commit: _super.prototype.commit.bind(this), rollback: _super.prototype.rollback.bind(this), close: _super.prototype.close.bind(this), isOpen: _super.prototype.isOpen.bind(this), _begin: this._begin.bind(this) });\n    };\n    /**\n     * @access private\n     */\n    TransactionPromise.prototype._begin = function (bookmarks, txConfig) {\n        return _super.prototype._begin.call(this, bookmarks, txConfig, {\n            onError: this._onBeginError.bind(this),\n            onComplete: this._onBeginMetadata.bind(this),\n            onDB: this._onDbCallback\n        });\n    };\n    /**\n     * @access private\n     * @returns {void}\n     */\n    TransactionPromise.prototype._onBeginError = function (error) {\n        this._beginError = error;\n        if (this._reject != null) {\n            this._reject(error);\n        }\n    };\n    /**\n     * @access private\n     * @returns {void}\n     */\n    TransactionPromise.prototype._onBeginMetadata = function (metadata) {\n        this._beginMetadata = metadata !== null && metadata !== void 0 ? metadata : {};\n        if (this._resolve != null) {\n            this._resolve(this._toTransaction());\n        }\n    };\n    return TransactionPromise;\n}(transaction_1.default));\n_a = Symbol.toStringTag;\nexports[\"default\"] = TransactionPromise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3RyYW5zYWN0aW9uLXByb21pc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLG9DQUFvQyxtQkFBTyxDQUFDLGdGQUFlO0FBQzNEO0FBQ0EseUJBQXlCLGtCQUFrQixnQkFBZ0IsbUJBQW1CO0FBQzlFO0FBQ0EsK0ZBQStGLG1CQUFtQjtBQUNsSDtBQUNBLHNDQUFzQyxtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLFlBQVk7QUFDM0IsZUFBZSxnQ0FBZ0M7QUFDL0MsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxpQ0FBaUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsZUFBZSxpQkFBaUIsNEJBQTRCLEdBQUc7QUFDL0QsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsd1BBQXdQO0FBQ3RTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmNlbC1uZW80ai1haS1vcGVuYWkvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3RyYW5zYWN0aW9uLXByb21pc2UuanM/YzU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9wcm9taXNlLWZ1bmN0aW9uLWFzeW5jICovXG52YXIgdHJhbnNhY3Rpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBQcm9taXNlPHtAbGluayBUcmFuc2FjdGlvbn0+IG9iamVjdCBhbmQgYSB7QGxpbmsgVHJhbnNhY3Rpb259IG9iamVjdC5cbiAqXG4gKiBSZXNvbHZpbmcgdGhpcyBvYmplY3QgcHJvbWlzZSB2ZXJpZmllcyB0aGUgcmVzdWx0IG9mIHRoZSB0cmFuc2FjdGlvbiBiZWdpbiBhbmQgcmV0dXJucyB0aGUge0BsaW5rIFRyYW5zYWN0aW9ufSBvYmplY3QgaW4gY2FzZSBvZiBzdWNjZXNzLlxuICpcbiAqIFRoZSBvYmplY3QgY2FuIHN0aWxsIGFsc28gdXNlZCBhcyB7QGxpbmsgVHJhbnNhY3Rpb259IGZvciBjb252ZW5pZW5jZS4gVGhlIHJlc3VsdCBvZiBiZWdpbiB3aWxsIGJlIGNoZWNrZWRcbiAqIGR1cmluZyB0aGUgbmV4dCBBUEkgY2FsbHMgaW4gdGhlIG9iamVjdCBhcyBpdCBpcyBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQGFjY2VzcyBwdWJsaWNcbiAqL1xudmFyIFRyYW5zYWN0aW9uUHJvbWlzZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJhbnNhY3Rpb25Qcm9taXNlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAgICogQHBhcmFtIHtDb25uZWN0aW9uSG9sZGVyfSBhcmdzLmNvbm5lY3Rpb25Ib2xkZXIgLSB0aGUgY29ubmVjdGlvbiBob2xkZXIgdG8gZ2V0IGNvbm5lY3Rpb24gZnJvbS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGFyZ3Mub25DbG9zZSAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRyYW5zYWN0aW9uIGlzIGNvbW1pdHRlZCBvciByb2xsZWQgYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGJvb2ttYXJrczogQm9va21hcmtzKX0gYXJncy5vbkJvb2ttYXJrcyBjYWxsYmFjayBpbnZva2VkIHdoZW4gbmV3IGJvb2ttYXJrIGlzIHByb2R1Y2VkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gYXJncy5vbkNvbm5lY3Rpb24gLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgb2J0YWluZWQgdG8gZW5zdXJlIHRoZSBjb25uZWN0aW9uXG4gICAgICogaXMgbm90IHlldCByZWxlYXNlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MucmVhY3RpdmUgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIGdlbmVyYXRlcyByZWFjdGl2ZSBzdHJlYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuZmV0Y2hTaXplIC0gdGhlIHJlY29yZCBmZXRjaCBzaXplIGluIGVhY2ggcHVsbGluZyBiYXRjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy5pbXBlcnNvbmF0ZWRVc2VyIC0gVGhlIG5hbWUgb2YgdGhlIHVzZXIgd2hpY2ggc2hvdWxkIGJlIGltcGVyc29uYXRlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBzZXNzaW9uLlxuICAgICAqIEBwYXJhbSB7Tm90aWZpY2F0aW9uRmlsdGVyfSBhcmdzLm5vdGlmaWNhdGlvbkZpbHRlciAtIFRoZSBub3RpZmljYXRpb24gZmlsdGVyIHVzZWQgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHtOb25BdXRvQ29tbWl0QXBpVGVsZW1ldHJ5Q29uZmlnfSBhcmdzLmFwaVRlbGVtZXRyeUNvbmZpZyAtIFRoZSBhcGkgdGVsZW1ldHJ5IGNvbmZpZ3VyYXRpb24uIEVtcHR5L051bGwgZm9yIGRpc2FibGluZyB0ZWxlbWV0cnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvblByb21pc2UoX2IpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfYi5jb25uZWN0aW9uSG9sZGVyLCBvbkNsb3NlID0gX2Iub25DbG9zZSwgb25Cb29rbWFya3MgPSBfYi5vbkJvb2ttYXJrcywgb25Db25uZWN0aW9uID0gX2Iub25Db25uZWN0aW9uLCByZWFjdGl2ZSA9IF9iLnJlYWN0aXZlLCBmZXRjaFNpemUgPSBfYi5mZXRjaFNpemUsIGltcGVyc29uYXRlZFVzZXIgPSBfYi5pbXBlcnNvbmF0ZWRVc2VyLCBoaWdoUmVjb3JkV2F0ZXJtYXJrID0gX2IuaGlnaFJlY29yZFdhdGVybWFyaywgbG93UmVjb3JkV2F0ZXJtYXJrID0gX2IubG93UmVjb3JkV2F0ZXJtYXJrLCBub3RpZmljYXRpb25GaWx0ZXIgPSBfYi5ub3RpZmljYXRpb25GaWx0ZXIsIGFwaVRlbGVtZXRyeUNvbmZpZyA9IF9iLmFwaVRlbGVtZXRyeUNvbmZpZywgb25EYkNhbGxiYWNrID0gX2Iub25EYkNhbGxiYWNrO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiBjb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgICAgb25DbG9zZTogb25DbG9zZSxcbiAgICAgICAgICAgIG9uQm9va21hcmtzOiBvbkJvb2ttYXJrcyxcbiAgICAgICAgICAgIG9uQ29ubmVjdGlvbjogb25Db25uZWN0aW9uLFxuICAgICAgICAgICAgcmVhY3RpdmU6IHJlYWN0aXZlLFxuICAgICAgICAgICAgZmV0Y2hTaXplOiBmZXRjaFNpemUsXG4gICAgICAgICAgICBpbXBlcnNvbmF0ZWRVc2VyOiBpbXBlcnNvbmF0ZWRVc2VyLFxuICAgICAgICAgICAgaGlnaFJlY29yZFdhdGVybWFyazogaGlnaFJlY29yZFdhdGVybWFyayxcbiAgICAgICAgICAgIGxvd1JlY29yZFdhdGVybWFyazogbG93UmVjb3JkV2F0ZXJtYXJrLFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uRmlsdGVyOiBub3RpZmljYXRpb25GaWx0ZXIsXG4gICAgICAgICAgICBhcGlUZWxlbWV0cnlDb25maWc6IGFwaVRlbGVtZXRyeUNvbmZpZ1xuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICBfdGhpc1tfYV0gPSAnVHJhbnNhY3Rpb25Qcm9taXNlJztcbiAgICAgICAgX3RoaXMuX29uRGJDYWxsYmFjayA9IG9uRGJDYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIGJlZ2luIHRvIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pfSBvbkZ1bGZpbGxlZCAtIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGZpbmlzaGVkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3I6IHttZXNzYWdlOnN0cmluZywgY29kZTpzdHJpbmd9KX0gb25SZWplY3RlZCAtIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB1cG9uIGVycm9ycy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlLlxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVCZWdpblByb21pc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhdGNoIGVycm9ycyB3aGVuIHVzaW5nIHByb21pc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcjogTmVvNGpFcnJvcil9IG9uUmVqZWN0ZWQgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgdXBvbiBlcnJvcnMuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZS5cbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvblByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9ucmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlQmVnaW5Qcm9taXNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBmaW5hbGx5IHRoZSBiZWdpbiBpcyBkb25lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl8bnVsbH0gb25maW5hbGx5IC0gZnVuY3Rpb24gd2hlbiB0aGUgcHJvbWlzZSBmaW5pc2hlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UuXG4gICAgICovXG4gICAgVHJhbnNhY3Rpb25Qcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gKG9uZmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGVCZWdpblByb21pc2UoKS5maW5hbGx5KG9uZmluYWxseSk7XG4gICAgfTtcbiAgICBUcmFuc2FjdGlvblByb21pc2UucHJvdG90eXBlLl9nZXRPckNyZWF0ZUJlZ2luUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2JlZ2luUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9iZWdpblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9iZWdpbkVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzLl9iZWdpbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9iZWdpbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5fdG9UcmFuc2FjdGlvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYmVnaW5Qcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgVHJhbnNhY3Rpb25Qcm9taXNlLnByb3RvdHlwZS5fdG9UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzKSwgeyBydW46IF9zdXBlci5wcm90b3R5cGUucnVuLmJpbmQodGhpcyksIGNvbW1pdDogX3N1cGVyLnByb3RvdHlwZS5jb21taXQuYmluZCh0aGlzKSwgcm9sbGJhY2s6IF9zdXBlci5wcm90b3R5cGUucm9sbGJhY2suYmluZCh0aGlzKSwgY2xvc2U6IF9zdXBlci5wcm90b3R5cGUuY2xvc2UuYmluZCh0aGlzKSwgaXNPcGVuOiBfc3VwZXIucHJvdG90eXBlLmlzT3Blbi5iaW5kKHRoaXMpLCBfYmVnaW46IHRoaXMuX2JlZ2luLmJpbmQodGhpcykgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvblByb21pc2UucHJvdG90eXBlLl9iZWdpbiA9IGZ1bmN0aW9uIChib29rbWFya3MsIHR4Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl9iZWdpbi5jYWxsKHRoaXMsIGJvb2ttYXJrcywgdHhDb25maWcsIHtcbiAgICAgICAgICAgIG9uRXJyb3I6IHRoaXMuX29uQmVnaW5FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogdGhpcy5fb25CZWdpbk1ldGFkYXRhLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvbkRCOiB0aGlzLl9vbkRiQ2FsbGJhY2tcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvblByb21pc2UucHJvdG90eXBlLl9vbkJlZ2luRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5FcnJvciA9IGVycm9yO1xuICAgICAgICBpZiAodGhpcy5fcmVqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uUHJvbWlzZS5wcm90b3R5cGUuX29uQmVnaW5NZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLl9iZWdpbk1ldGFkYXRhID0gbWV0YWRhdGEgIT09IG51bGwgJiYgbWV0YWRhdGEgIT09IHZvaWQgMCA/IG1ldGFkYXRhIDoge307XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdG9UcmFuc2FjdGlvbigpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uUHJvbWlzZTtcbn0odHJhbnNhY3Rpb25fMS5kZWZhdWx0KSk7XG5fYSA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zYWN0aW9uUHJvbWlzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/transaction-promise.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/transaction.js":
/*!***********************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/transaction.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* eslint-disable @typescript-eslint/promise-function-async */\nvar util_1 = __webpack_require__(/*! ./internal/util */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/util.js\");\nvar connection_holder_1 = __webpack_require__(/*! ./internal/connection-holder */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/connection-holder.js\");\nvar bookmarks_1 = __webpack_require__(/*! ./internal/bookmarks */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/bookmarks.js\");\nvar tx_config_1 = __webpack_require__(/*! ./internal/tx-config */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/tx-config.js\");\nvar observers_1 = __webpack_require__(/*! ./internal/observers */ \"(rsc)/./node_modules/neo4j-driver-core/lib/internal/observers.js\");\nvar error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/neo4j-driver-core/lib/error.js\");\nvar result_1 = __importDefault(__webpack_require__(/*! ./result */ \"(rsc)/./node_modules/neo4j-driver-core/lib/result.js\"));\n/**\n * Represents a transaction in the Neo4j database.\n *\n * @access public\n */\nvar Transaction = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {object} args\n     * @param {ConnectionHolder} args.connectionHolder - the connection holder to get connection from.\n     * @param {function()} args.onClose - Function to be called when transaction is committed or rolled back.\n     * @param {function(bookmarks: Bookmarks)} args.onBookmarks callback invoked when new bookmark is produced.\n     * @param {function()} args.onConnection - Function to be called when a connection is obtained to ensure the conneciton\n     * is not yet released.\n     * @param {boolean} args.reactive whether this transaction generates reactive streams\n     * @param {number} args.fetchSize - the record fetch size in each pulling batch.\n     * @param {string} args.impersonatedUser - The name of the user which should be impersonated for the duration of the session.\n     * @param {number} args.highRecordWatermark - The high watermark for the record buffer.\n     * @param {number} args.lowRecordWatermark - The low watermark for the record buffer.\n     * @param {NotificationFilter} args.notificationFilter - The notification filter used for this transaction.\n     * @param {NonAutoCommitApiTelemetryConfig} args.apiTelemetryConfig - The api telemetry configuration. Empty/Null for disabling telemetry\n     */\n    function Transaction(_a) {\n        var connectionHolder = _a.connectionHolder, onClose = _a.onClose, onBookmarks = _a.onBookmarks, onConnection = _a.onConnection, reactive = _a.reactive, fetchSize = _a.fetchSize, impersonatedUser = _a.impersonatedUser, highRecordWatermark = _a.highRecordWatermark, lowRecordWatermark = _a.lowRecordWatermark, notificationFilter = _a.notificationFilter, apiTelemetryConfig = _a.apiTelemetryConfig;\n        var _this = this;\n        this._connectionHolder = connectionHolder;\n        this._reactive = reactive;\n        this._state = _states.ACTIVE;\n        this._onClose = onClose;\n        this._onBookmarks = onBookmarks;\n        this._onConnection = onConnection;\n        this._onError = this._onErrorCallback.bind(this);\n        this._fetchSize = fetchSize;\n        this._onComplete = this._onCompleteCallback.bind(this);\n        this._results = [];\n        this._impersonatedUser = impersonatedUser;\n        this._lowRecordWatermak = lowRecordWatermark;\n        this._highRecordWatermark = highRecordWatermark;\n        this._bookmarks = bookmarks_1.Bookmarks.empty();\n        this._notificationFilter = notificationFilter;\n        this._apiTelemetryConfig = apiTelemetryConfig;\n        this._acceptActive = function () { }; // satisfy DenoJS\n        this._activePromise = new Promise(function (resolve, reject) {\n            _this._acceptActive = resolve;\n        });\n    }\n    /**\n     * @private\n     * @param {Bookmarks | string |  string []} bookmarks\n     * @param {TxConfig} txConfig\n     * @param {Object} events List of observers to events\n     * @returns {void}\n     */\n    Transaction.prototype._begin = function (getBookmarks, txConfig, events) {\n        var _this = this;\n        this._connectionHolder\n            .getConnection()\n            .then(function (connection) { return __awaiter(_this, void 0, void 0, function () {\n            var _a;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        this._onConnection();\n                        if (!(connection != null)) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, getBookmarks()];\n                    case 1:\n                        _a._bookmarks = _b.sent();\n                        return [2 /*return*/, connection.beginTransaction({\n                                bookmarks: this._bookmarks,\n                                txConfig: txConfig,\n                                mode: this._connectionHolder.mode(),\n                                database: this._connectionHolder.database(),\n                                impersonatedUser: this._impersonatedUser,\n                                notificationFilter: this._notificationFilter,\n                                apiTelemetryConfig: this._apiTelemetryConfig,\n                                beforeError: function (error) {\n                                    if (events != null) {\n                                        events.onError(error);\n                                    }\n                                    _this._onError(error).catch(function () { });\n                                },\n                                afterComplete: function (metadata) {\n                                    if (events != null) {\n                                        events.onComplete(metadata);\n                                    }\n                                    if (metadata.db !== undefined && ((events === null || events === void 0 ? void 0 : events.onDB) != null)) {\n                                        events.onDB(metadata.db);\n                                    }\n                                    _this._onComplete(metadata);\n                                }\n                            })];\n                    case 2: throw (0, error_1.newError)('No connection available');\n                }\n            });\n        }); })\n            .catch(function (error) {\n            if (events != null) {\n                events.onError(error);\n            }\n            _this._onError(error).catch(function () { });\n        })\n            // It should make the transaction active anyway\n            // further errors will be treated by the existing\n            // observers\n            .finally(function () { return _this._acceptActive(); });\n    };\n    /**\n     * Run Cypher query\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the query and parameters as separate arguments.\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @return {Result} New Result\n     */\n    Transaction.prototype.run = function (query, parameters) {\n        var _a = (0, util_1.validateQueryAndParameters)(query, parameters), validatedQuery = _a.validatedQuery, params = _a.params;\n        var result = this._state.run(validatedQuery, params, {\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: this._onComplete,\n            onConnection: this._onConnection,\n            reactive: this._reactive,\n            fetchSize: this._fetchSize,\n            highRecordWatermark: this._highRecordWatermark,\n            lowRecordWatermark: this._lowRecordWatermak,\n            preparationJob: this._activePromise\n        });\n        this._results.push(result);\n        return result;\n    };\n    /**\n     * Commits the transaction and returns the result.\n     *\n     * After committing the transaction can no longer be used.\n     *\n     * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.\n     */\n    Transaction.prototype.commit = function () {\n        var _this = this;\n        var committed = this._state.commit({\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: function (meta) { return _this._onCompleteCallback(meta, _this._bookmarks); },\n            onConnection: this._onConnection,\n            pendingResults: this._results,\n            preparationJob: this._activePromise\n        });\n        this._state = committed.state;\n        // clean up\n        this._onClose();\n        return new Promise(function (resolve, reject) {\n            committed.result.subscribe({\n                onCompleted: function () { return resolve(); },\n                onError: function (error) { return reject(error); }\n            });\n        });\n    };\n    /**\n     * Rollbacks the transaction.\n     *\n     * After rolling back, the transaction can no longer be used.\n     *\n     * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during\n     * rollback.\n     */\n    Transaction.prototype.rollback = function () {\n        var rolledback = this._state.rollback({\n            connectionHolder: this._connectionHolder,\n            onError: this._onError,\n            onComplete: this._onComplete,\n            onConnection: this._onConnection,\n            pendingResults: this._results,\n            preparationJob: this._activePromise\n        });\n        this._state = rolledback.state;\n        // clean up\n        this._onClose();\n        return new Promise(function (resolve, reject) {\n            rolledback.result.subscribe({\n                onCompleted: function () { return resolve(); },\n                onError: function (error) { return reject(error); }\n            });\n        });\n    };\n    /**\n     * Check if this transaction is active, which means commit and rollback did not happen.\n     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.\n     */\n    Transaction.prototype.isOpen = function () {\n        return this._state === _states.ACTIVE;\n    };\n    /**\n     * Closes the transaction\n     *\n     * This method will roll back the transaction if it is not already committed or rolled back.\n     *\n     * @returns {Promise<void>} An empty promise if closed successfully or error if any error happened during\n     */\n    Transaction.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.isOpen()) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.rollback()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // eslint-disable-next-line\n    // @ts-ignore\n    Transaction.prototype[Symbol.asyncDispose] = function () {\n        return this.close();\n    };\n    Transaction.prototype._onErrorCallback = function (error) {\n        // error will be \"acknowledged\" by sending a RESET message\n        // database will then forget about this transaction and cleanup all corresponding resources\n        // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it\n        if (this._state === _states.FAILED) {\n            // already failed, nothing to do\n            // if we call onError for each result again, we might run into an infinite loop, that causes an OOM eventually\n            return Promise.resolve(null);\n        }\n        this._state = _states.FAILED;\n        this._onClose();\n        this._results.forEach(function (result) {\n            if (result.isOpen()) {\n                // @ts-expect-error\n                result._streamObserverPromise\n                    .then(function (resultStreamObserver) { return resultStreamObserver.onError(error); })\n                    // Nothing to do since we don't have a observer to notify the error\n                    // the result will be already broke in other ways.\n                    .catch(function (_) { });\n            }\n        });\n        // release connection back to the pool\n        return this._connectionHolder.releaseConnection();\n    };\n    /**\n     * @private\n     * @param {object} meta The meta with bookmarks\n     * @returns {void}\n     */\n    Transaction.prototype._onCompleteCallback = function (meta, previousBookmarks) {\n        this._onBookmarks(new bookmarks_1.Bookmarks(meta === null || meta === void 0 ? void 0 : meta.bookmark), previousBookmarks !== null && previousBookmarks !== void 0 ? previousBookmarks : bookmarks_1.Bookmarks.empty(), meta === null || meta === void 0 ? void 0 : meta.db);\n    };\n    return Transaction;\n}());\nvar _states = {\n    // The transaction is running with no explicit success or failure marked\n    ACTIVE: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, pendingResults = _a.pendingResults, preparationJob = _a.preparationJob;\n            return {\n                result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults, preparationJob),\n                state: _states.SUCCEEDED\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, pendingResults = _a.pendingResults, preparationJob = _a.preparationJob;\n            return {\n                result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults, preparationJob),\n                state: _states.ROLLED_BACK\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete, onConnection = _a.onConnection, reactive = _a.reactive, fetchSize = _a.fetchSize, highRecordWatermark = _a.highRecordWatermark, lowRecordWatermark = _a.lowRecordWatermark, preparationJob = _a.preparationJob;\n            // RUN in explicit transaction can't contain bookmarks and transaction configuration\n            // No need to include mode and database name as it shall be included in begin\n            var requirements = preparationJob !== null && preparationJob !== void 0 ? preparationJob : Promise.resolve();\n            var observerPromise = connectionHolder.getConnection()\n                .then(function (conn) { return requirements.then(function () { return conn; }); })\n                .then(function (conn) {\n                onConnection();\n                if (conn != null) {\n                    return conn.run(query, parameters, {\n                        bookmarks: bookmarks_1.Bookmarks.empty(),\n                        txConfig: tx_config_1.TxConfig.empty(),\n                        beforeError: onError,\n                        afterComplete: onComplete,\n                        reactive: reactive,\n                        fetchSize: fetchSize,\n                        highRecordWatermark: highRecordWatermark,\n                        lowRecordWatermark: lowRecordWatermark\n                    });\n                }\n                else {\n                    throw (0, error_1.newError)('No connection available');\n                }\n            })\n                .catch(function (error) { return new observers_1.FailedObserver({ error: error, onError: onError }); });\n            return newCompletedResult(observerPromise, query, parameters, connectionHolder, highRecordWatermark, lowRecordWatermark);\n        }\n    },\n    // An error has occurred, transaction can no longer be used and no more messages will\n    // be sent for this transaction.\n    FAILED: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),\n                    onError: onError\n                }), 'COMMIT', {}, connectionHolder, 0, // high watermark\n                0 // low watermark\n                ),\n                state: _states.FAILED\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.CompletedObserver(), 'ROLLBACK', {}, connectionHolder, 0, // high watermark\n                0 // low watermark\n                ),\n                state: _states.FAILED\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),\n                onError: onError\n            }), query, parameters, connectionHolder, 0, // high watermark\n            0 // low watermark\n            );\n        }\n    },\n    // This transaction has successfully committed\n    SUCCEEDED: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has already been committed.'),\n                    onError: onError\n                }), 'COMMIT', {}, connection_holder_1.EMPTY_CONNECTION_HOLDER, 0, // high watermark\n                0 // low watermark\n                ),\n                state: _states.SUCCEEDED,\n                connectionHolder: connectionHolder\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been committed.'),\n                    onError: onError\n                }), 'ROLLBACK', {}, connection_holder_1.EMPTY_CONNECTION_HOLDER, 0, // high watermark\n                0 // low watermark\n                ),\n                state: _states.SUCCEEDED,\n                connectionHolder: connectionHolder\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been committed.'),\n                onError: onError\n            }), query, parameters, connectionHolder, 0, // high watermark\n            0 // low watermark\n            );\n        }\n    },\n    // This transaction has been rolled back\n    ROLLED_BACK: {\n        commit: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot commit this transaction, because it has already been rolled back.'),\n                    onError: onError\n                }), 'COMMIT', {}, connectionHolder, 0, // high watermark\n                0 // low watermark\n                ),\n                state: _states.ROLLED_BACK\n            };\n        },\n        rollback: function (_a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return {\n                result: newCompletedResult(new observers_1.FailedObserver({\n                    error: (0, error_1.newError)('Cannot rollback this transaction, because it has already been rolled back.')\n                }), 'ROLLBACK', {}, connectionHolder, 0, // high watermark\n                0 // low watermark\n                ),\n                state: _states.ROLLED_BACK\n            };\n        },\n        run: function (query, parameters, _a) {\n            var connectionHolder = _a.connectionHolder, onError = _a.onError, onComplete = _a.onComplete;\n            return newCompletedResult(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in this transaction, because it has already been rolled back.'),\n                onError: onError\n            }), query, parameters, connectionHolder, 0, // high watermark\n            0 // low watermark\n            );\n        }\n    }\n};\n/**\n *\n * @param {boolean} commit\n * @param {ConnectionHolder} connectionHolder\n * @param {function(err:Error): any} onError\n * @param {function(metadata:object): any} onComplete\n * @param {function() : any} onConnection\n * @param {list<Result>>}pendingResults all run results in this transaction\n */\nfunction finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults, preparationJob) {\n    var requirements = preparationJob !== null && preparationJob !== void 0 ? preparationJob : Promise.resolve();\n    var observerPromise = connectionHolder.getConnection()\n        .then(function (conn) { return requirements.then(function () { return conn; }); })\n        .then(function (connection) {\n        onConnection();\n        pendingResults.forEach(function (r) { return r._cancel(); });\n        return Promise.all(pendingResults.map(function (result) { return result.summary(); })).then(function (results) {\n            if (connection != null) {\n                if (commit) {\n                    return connection.commitTransaction({\n                        beforeError: onError,\n                        afterComplete: onComplete\n                    });\n                }\n                else {\n                    return connection.rollbackTransaction({\n                        beforeError: onError,\n                        afterComplete: onComplete\n                    });\n                }\n            }\n            else {\n                throw (0, error_1.newError)('No connection available');\n            }\n        });\n    })\n        .catch(function (error) { return new observers_1.FailedObserver({ error: error, onError: onError }); });\n    // for commit & rollback we need result that uses real connection holder and notifies it when\n    // connection is not needed and can be safely released to the pool\n    return new result_1.default(observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder, {\n        high: Number.MAX_VALUE,\n        low: Number.MAX_VALUE\n    });\n}\n/**\n * Creates a {@link Result} with empty connection holder.\n * For cases when result represents an intermediate or failed action, does not require any metadata and does not\n * need to influence real connection holder to release connections.\n * @param {ResultStreamObserver} observer - an observer for the created result.\n * @param {string} query - the cypher query that produced the result.\n * @param {Object} parameters - the parameters for cypher query that produced the result.\n * @param {ConnectionHolder} connectionHolder - the connection holder used to get the result\n * @return {Result} new result.\n * @private\n */\nfunction newCompletedResult(observerPromise, query, parameters, connectionHolder, highRecordWatermark, lowRecordWatermark) {\n    if (connectionHolder === void 0) { connectionHolder = connection_holder_1.EMPTY_CONNECTION_HOLDER; }\n    return new result_1.default(Promise.resolve(observerPromise), query, parameters, new connection_holder_1.ReadOnlyConnectionHolder(connectionHolder !== null && connectionHolder !== void 0 ? connectionHolder : connection_holder_1.EMPTY_CONNECTION_HOLDER), {\n        low: lowRecordWatermark,\n        high: highRecordWatermark\n    });\n}\nexports[\"default\"] = Transaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0ZBQWlCO0FBQ3RDLDBCQUEwQixtQkFBTyxDQUFDLDhHQUE4QjtBQUNoRSxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsOEZBQXNCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLDhGQUFzQjtBQUNoRCxj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U0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVDQUF1QyxjQUFjLElBQUk7QUFDekY7QUFDQTtBQUNBLDhDQUE4QyxxQkFBcUI7QUFDbkUsa0VBQWtFLDBCQUEwQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsa0NBQWtDLHdDQUF3QyxnQ0FBZ0MsSUFBSTtBQUM5RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyY2VsLW5lbzRqLWFpLW9wZW5haS8uL25vZGVfbW9kdWxlcy9uZW80ai1kcml2ZXItY29yZS9saWIvdHJhbnNhY3Rpb24uanM/YTFmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSBcIk5lbzRqXCJcbiAqIE5lbzRqIFN3ZWRlbiBBQiBbaHR0cHM6Ly9uZW80ai5jb21dXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYyAqL1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxcIik7XG52YXIgY29ubmVjdGlvbl9ob2xkZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2Nvbm5lY3Rpb24taG9sZGVyXCIpO1xudmFyIGJvb2ttYXJrc18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYm9va21hcmtzXCIpO1xudmFyIHR4X2NvbmZpZ18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvdHgtY29uZmlnXCIpO1xudmFyIG9ic2VydmVyc18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvb2JzZXJ2ZXJzXCIpO1xudmFyIGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbnZhciByZXN1bHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXN1bHRcIikpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24gaW4gdGhlIE5lbzRqIGRhdGFiYXNlLlxuICpcbiAqIEBhY2Nlc3MgcHVibGljXG4gKi9cbnZhciBUcmFuc2FjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgICAqIEBwYXJhbSB7Q29ubmVjdGlvbkhvbGRlcn0gYXJncy5jb25uZWN0aW9uSG9sZGVyIC0gdGhlIGNvbm5lY3Rpb24gaG9sZGVyIHRvIGdldCBjb25uZWN0aW9uIGZyb20uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBhcmdzLm9uQ2xvc2UgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0cmFuc2FjdGlvbiBpcyBjb21taXR0ZWQgb3Igcm9sbGVkIGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihib29rbWFya3M6IEJvb2ttYXJrcyl9IGFyZ3Mub25Cb29rbWFya3MgY2FsbGJhY2sgaW52b2tlZCB3aGVuIG5ldyBib29rbWFyayBpcyBwcm9kdWNlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGFyZ3Mub25Db25uZWN0aW9uIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYSBjb25uZWN0aW9uIGlzIG9idGFpbmVkIHRvIGVuc3VyZSB0aGUgY29ubmVjaXRvblxuICAgICAqIGlzIG5vdCB5ZXQgcmVsZWFzZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhcmdzLnJlYWN0aXZlIHdoZXRoZXIgdGhpcyB0cmFuc2FjdGlvbiBnZW5lcmF0ZXMgcmVhY3RpdmUgc3RyZWFtc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmZldGNoU2l6ZSAtIHRoZSByZWNvcmQgZmV0Y2ggc2l6ZSBpbiBlYWNoIHB1bGxpbmcgYmF0Y2guXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuaW1wZXJzb25hdGVkVXNlciAtIFRoZSBuYW1lIG9mIHRoZSB1c2VyIHdoaWNoIHNob3VsZCBiZSBpbXBlcnNvbmF0ZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJncy5oaWdoUmVjb3JkV2F0ZXJtYXJrIC0gVGhlIGhpZ2ggd2F0ZXJtYXJrIGZvciB0aGUgcmVjb3JkIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJncy5sb3dSZWNvcmRXYXRlcm1hcmsgLSBUaGUgbG93IHdhdGVybWFyayBmb3IgdGhlIHJlY29yZCBidWZmZXIuXG4gICAgICogQHBhcmFtIHtOb3RpZmljYXRpb25GaWx0ZXJ9IGFyZ3Mubm90aWZpY2F0aW9uRmlsdGVyIC0gVGhlIG5vdGlmaWNhdGlvbiBmaWx0ZXIgdXNlZCBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0ge05vbkF1dG9Db21taXRBcGlUZWxlbWV0cnlDb25maWd9IGFyZ3MuYXBpVGVsZW1ldHJ5Q29uZmlnIC0gVGhlIGFwaSB0ZWxlbWV0cnkgY29uZmlndXJhdGlvbi4gRW1wdHkvTnVsbCBmb3IgZGlzYWJsaW5nIHRlbGVtZXRyeVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKF9hKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX2EuY29ubmVjdGlvbkhvbGRlciwgb25DbG9zZSA9IF9hLm9uQ2xvc2UsIG9uQm9va21hcmtzID0gX2Eub25Cb29rbWFya3MsIG9uQ29ubmVjdGlvbiA9IF9hLm9uQ29ubmVjdGlvbiwgcmVhY3RpdmUgPSBfYS5yZWFjdGl2ZSwgZmV0Y2hTaXplID0gX2EuZmV0Y2hTaXplLCBpbXBlcnNvbmF0ZWRVc2VyID0gX2EuaW1wZXJzb25hdGVkVXNlciwgaGlnaFJlY29yZFdhdGVybWFyayA9IF9hLmhpZ2hSZWNvcmRXYXRlcm1hcmssIGxvd1JlY29yZFdhdGVybWFyayA9IF9hLmxvd1JlY29yZFdhdGVybWFyaywgbm90aWZpY2F0aW9uRmlsdGVyID0gX2Eubm90aWZpY2F0aW9uRmlsdGVyLCBhcGlUZWxlbWV0cnlDb25maWcgPSBfYS5hcGlUZWxlbWV0cnlDb25maWc7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIgPSBjb25uZWN0aW9uSG9sZGVyO1xuICAgICAgICB0aGlzLl9yZWFjdGl2ZSA9IHJlYWN0aXZlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IF9zdGF0ZXMuQUNUSVZFO1xuICAgICAgICB0aGlzLl9vbkNsb3NlID0gb25DbG9zZTtcbiAgICAgICAgdGhpcy5fb25Cb29rbWFya3MgPSBvbkJvb2ttYXJrcztcbiAgICAgICAgdGhpcy5fb25Db25uZWN0aW9uID0gb25Db25uZWN0aW9uO1xuICAgICAgICB0aGlzLl9vbkVycm9yID0gdGhpcy5fb25FcnJvckNhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2ZldGNoU2l6ZSA9IGZldGNoU2l6ZTtcbiAgICAgICAgdGhpcy5fb25Db21wbGV0ZSA9IHRoaXMuX29uQ29tcGxldGVDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXN1bHRzID0gW107XG4gICAgICAgIHRoaXMuX2ltcGVyc29uYXRlZFVzZXIgPSBpbXBlcnNvbmF0ZWRVc2VyO1xuICAgICAgICB0aGlzLl9sb3dSZWNvcmRXYXRlcm1hayA9IGxvd1JlY29yZFdhdGVybWFyaztcbiAgICAgICAgdGhpcy5faGlnaFJlY29yZFdhdGVybWFyayA9IGhpZ2hSZWNvcmRXYXRlcm1hcms7XG4gICAgICAgIHRoaXMuX2Jvb2ttYXJrcyA9IGJvb2ttYXJrc18xLkJvb2ttYXJrcy5lbXB0eSgpO1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25GaWx0ZXIgPSBub3RpZmljYXRpb25GaWx0ZXI7XG4gICAgICAgIHRoaXMuX2FwaVRlbGVtZXRyeUNvbmZpZyA9IGFwaVRlbGVtZXRyeUNvbmZpZztcbiAgICAgICAgdGhpcy5fYWNjZXB0QWN0aXZlID0gZnVuY3Rpb24gKCkgeyB9OyAvLyBzYXRpc2Z5IERlbm9KU1xuICAgICAgICB0aGlzLl9hY3RpdmVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMuX2FjY2VwdEFjdGl2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9va21hcmtzIHwgc3RyaW5nIHwgIHN0cmluZyBbXX0gYm9va21hcmtzXG4gICAgICogQHBhcmFtIHtUeENvbmZpZ30gdHhDb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRzIExpc3Qgb2Ygb2JzZXJ2ZXJzIHRvIGV2ZW50c1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fYmVnaW4gPSBmdW5jdGlvbiAoZ2V0Qm9va21hcmtzLCB0eENvbmZpZywgZXZlbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXJcbiAgICAgICAgICAgIC5nZXRDb25uZWN0aW9uKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25Db25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb25uZWN0aW9uICE9IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdldEJvb2ttYXJrcygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EuX2Jvb2ttYXJrcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjb25uZWN0aW9uLmJlZ2luVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29rbWFya3M6IHRoaXMuX2Jvb2ttYXJrcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhDb25maWc6IHR4Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLl9jb25uZWN0aW9uSG9sZGVyLm1vZGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YWJhc2U6IHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIuZGF0YWJhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wZXJzb25hdGVkVXNlcjogdGhpcy5faW1wZXJzb25hdGVkVXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uRmlsdGVyOiB0aGlzLl9ub3RpZmljYXRpb25GaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVRlbGVtZXRyeUNvbmZpZzogdGhpcy5fYXBpVGVsZW1ldHJ5Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25FcnJvcihlcnJvcikuY2F0Y2goZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJDb21wbGV0ZTogZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMub25Db21wbGV0ZShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuZGIgIT09IHVuZGVmaW5lZCAmJiAoKGV2ZW50cyA9PT0gbnVsbCB8fCBldmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50cy5vbkRCKSAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5vbkRCKG1ldGFkYXRhLmRiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vbkNvbXBsZXRlKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiB0aHJvdyAoMCwgZXJyb3JfMS5uZXdFcnJvcikoJ05vIGNvbm5lY3Rpb24gYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGV2ZW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX29uRXJyb3IoZXJyb3IpLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAvLyBJdCBzaG91bGQgbWFrZSB0aGUgdHJhbnNhY3Rpb24gYWN0aXZlIGFueXdheVxuICAgICAgICAgICAgLy8gZnVydGhlciBlcnJvcnMgd2lsbCBiZSB0cmVhdGVkIGJ5IHRoZSBleGlzdGluZ1xuICAgICAgICAgICAgLy8gb2JzZXJ2ZXJzXG4gICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYWNjZXB0QWN0aXZlKCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUnVuIEN5cGhlciBxdWVyeVxuICAgICAqIENvdWxkIGJlIGNhbGxlZCB3aXRoIGEgcXVlcnkgb2JqZWN0IGkuZS46IGB7dGV4dDogXCJNQVRDSCAuLi5cIiwgcGFyYW1ldGVyczoge3BhcmFtOiAxfX1gXG4gICAgICogb3Igd2l0aCB0aGUgcXVlcnkgYW5kIHBhcmFtZXRlcnMgYXMgc2VwYXJhdGUgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IHF1ZXJ5IC0gQ3lwaGVyIHF1ZXJ5IHRvIGV4ZWN1dGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIE1hcCB3aXRoIHBhcmFtZXRlcnMgdG8gdXNlIGluIHF1ZXJ5XG4gICAgICogQHJldHVybiB7UmVzdWx0fSBOZXcgUmVzdWx0XG4gICAgICovXG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChxdWVyeSwgcGFyYW1ldGVycykge1xuICAgICAgICB2YXIgX2EgPSAoMCwgdXRpbF8xLnZhbGlkYXRlUXVlcnlBbmRQYXJhbWV0ZXJzKShxdWVyeSwgcGFyYW1ldGVycyksIHZhbGlkYXRlZFF1ZXJ5ID0gX2EudmFsaWRhdGVkUXVlcnksIHBhcmFtcyA9IF9hLnBhcmFtcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3N0YXRlLnJ1bih2YWxpZGF0ZWRRdWVyeSwgcGFyYW1zLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiB0aGlzLl9jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvcixcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IHRoaXMuX29uQ29tcGxldGUsXG4gICAgICAgICAgICBvbkNvbm5lY3Rpb246IHRoaXMuX29uQ29ubmVjdGlvbixcbiAgICAgICAgICAgIHJlYWN0aXZlOiB0aGlzLl9yZWFjdGl2ZSxcbiAgICAgICAgICAgIGZldGNoU2l6ZTogdGhpcy5fZmV0Y2hTaXplLFxuICAgICAgICAgICAgaGlnaFJlY29yZFdhdGVybWFyazogdGhpcy5faGlnaFJlY29yZFdhdGVybWFyayxcbiAgICAgICAgICAgIGxvd1JlY29yZFdhdGVybWFyazogdGhpcy5fbG93UmVjb3JkV2F0ZXJtYWssXG4gICAgICAgICAgICBwcmVwYXJhdGlvbkpvYjogdGhpcy5fYWN0aXZlUHJvbWlzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21taXRzIHRoZSB0cmFuc2FjdGlvbiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQWZ0ZXIgY29tbWl0dGluZyB0aGUgdHJhbnNhY3Rpb24gY2FuIG5vIGxvbmdlciBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEFuIGVtcHR5IHByb21pc2UgaWYgY29tbWl0dGVkIHN1Y2Nlc3NmdWxseSBvciBlcnJvciBpZiBhbnkgZXJyb3IgaGFwcGVuZWQgZHVyaW5nIGNvbW1pdC5cbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tbWl0dGVkID0gdGhpcy5fc3RhdGUuY29tbWl0KHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Ib2xkZXI6IHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIsXG4gICAgICAgICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKG1ldGEpIHsgcmV0dXJuIF90aGlzLl9vbkNvbXBsZXRlQ2FsbGJhY2sobWV0YSwgX3RoaXMuX2Jvb2ttYXJrcyk7IH0sXG4gICAgICAgICAgICBvbkNvbm5lY3Rpb246IHRoaXMuX29uQ29ubmVjdGlvbixcbiAgICAgICAgICAgIHBlbmRpbmdSZXN1bHRzOiB0aGlzLl9yZXN1bHRzLFxuICAgICAgICAgICAgcHJlcGFyYXRpb25Kb2I6IHRoaXMuX2FjdGl2ZVByb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gY29tbWl0dGVkLnN0YXRlO1xuICAgICAgICAvLyBjbGVhbiB1cFxuICAgICAgICB0aGlzLl9vbkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBjb21taXR0ZWQucmVzdWx0LnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIHJlamVjdChlcnJvcik7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJvbGxiYWNrcyB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBBZnRlciByb2xsaW5nIGJhY2ssIHRoZSB0cmFuc2FjdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQW4gZW1wdHkgcHJvbWlzZSBpZiByb2xsZWQgYmFjayBzdWNjZXNzZnVsbHkgb3IgZXJyb3IgaWYgYW55IGVycm9yIGhhcHBlbmVkIGR1cmluZ1xuICAgICAqIHJvbGxiYWNrLlxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yb2xsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJvbGxlZGJhY2sgPSB0aGlzLl9zdGF0ZS5yb2xsYmFjayh7XG4gICAgICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiB0aGlzLl9jb25uZWN0aW9uSG9sZGVyLFxuICAgICAgICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvcixcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IHRoaXMuX29uQ29tcGxldGUsXG4gICAgICAgICAgICBvbkNvbm5lY3Rpb246IHRoaXMuX29uQ29ubmVjdGlvbixcbiAgICAgICAgICAgIHBlbmRpbmdSZXN1bHRzOiB0aGlzLl9yZXN1bHRzLFxuICAgICAgICAgICAgcHJlcGFyYXRpb25Kb2I6IHRoaXMuX2FjdGl2ZVByb21pc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gcm9sbGVkYmFjay5zdGF0ZTtcbiAgICAgICAgLy8gY2xlYW4gdXBcbiAgICAgICAgdGhpcy5fb25DbG9zZSgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcm9sbGVkYmFjay5yZXN1bHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9LFxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gcmVqZWN0KGVycm9yKTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyB0cmFuc2FjdGlvbiBpcyBhY3RpdmUsIHdoaWNoIG1lYW5zIGNvbW1pdCBhbmQgcm9sbGJhY2sgZGlkIG5vdCBoYXBwZW4uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gbm90IGNvbW1pdHRlZCBhbmQgbm90IHJvbGxlZCBiYWNrLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IF9zdGF0ZXMuQUNUSVZFO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCByb2xsIGJhY2sgdGhlIHRyYW5zYWN0aW9uIGlmIGl0IGlzIG5vdCBhbHJlYWR5IGNvbW1pdHRlZCBvciByb2xsZWQgYmFjay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBbiBlbXB0eSBwcm9taXNlIGlmIGNsb3NlZCBzdWNjZXNzZnVsbHkgb3IgZXJyb3IgaWYgYW55IGVycm9yIGhhcHBlbmVkIGR1cmluZ1xuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3BlbigpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucm9sbGJhY2soKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNEaXNwb3NlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5fb25FcnJvckNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGVycm9yIHdpbGwgYmUgXCJhY2tub3dsZWRnZWRcIiBieSBzZW5kaW5nIGEgUkVTRVQgbWVzc2FnZVxuICAgICAgICAvLyBkYXRhYmFzZSB3aWxsIHRoZW4gZm9yZ2V0IGFib3V0IHRoaXMgdHJhbnNhY3Rpb24gYW5kIGNsZWFudXAgYWxsIGNvcnJlc3BvbmRpbmcgcmVzb3VyY2VzXG4gICAgICAgIC8vIGl0IGlzIHRodXMgc2FmZSB0byBtb3ZlIHRoaXMgdHJhbnNhY3Rpb24gdG8gYSBGQUlMRUQgc3RhdGUgYW5kIGRpc2FsbG93IGFueSBmdXJ0aGVyIGludGVyYWN0aW9ucyB3aXRoIGl0XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gX3N0YXRlcy5GQUlMRUQpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgZmFpbGVkLCBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICAvLyBpZiB3ZSBjYWxsIG9uRXJyb3IgZm9yIGVhY2ggcmVzdWx0IGFnYWluLCB3ZSBtaWdodCBydW4gaW50byBhbiBpbmZpbml0ZSBsb29wLCB0aGF0IGNhdXNlcyBhbiBPT00gZXZlbnR1YWxseVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSA9IF9zdGF0ZXMuRkFJTEVEO1xuICAgICAgICB0aGlzLl9vbkNsb3NlKCk7XG4gICAgICAgIHRoaXMuX3Jlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmlzT3BlbigpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHJlc3VsdC5fc3RyZWFtT2JzZXJ2ZXJQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHRTdHJlYW1PYnNlcnZlcikgeyByZXR1cm4gcmVzdWx0U3RyZWFtT2JzZXJ2ZXIub25FcnJvcihlcnJvcik7IH0pXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIG9ic2VydmVyIHRvIG5vdGlmeSB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc3VsdCB3aWxsIGJlIGFscmVhZHkgYnJva2UgaW4gb3RoZXIgd2F5cy5cbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChfKSB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVsZWFzZSBjb25uZWN0aW9uIGJhY2sgdG8gdGhlIHBvb2xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25Ib2xkZXIucmVsZWFzZUNvbm5lY3Rpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGEgVGhlIG1ldGEgd2l0aCBib29rbWFya3NcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX29uQ29tcGxldGVDYWxsYmFjayA9IGZ1bmN0aW9uIChtZXRhLCBwcmV2aW91c0Jvb2ttYXJrcykge1xuICAgICAgICB0aGlzLl9vbkJvb2ttYXJrcyhuZXcgYm9va21hcmtzXzEuQm9va21hcmtzKG1ldGEgPT09IG51bGwgfHwgbWV0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWV0YS5ib29rbWFyayksIHByZXZpb3VzQm9va21hcmtzICE9PSBudWxsICYmIHByZXZpb3VzQm9va21hcmtzICE9PSB2b2lkIDAgPyBwcmV2aW91c0Jvb2ttYXJrcyA6IGJvb2ttYXJrc18xLkJvb2ttYXJrcy5lbXB0eSgpLCBtZXRhID09PSBudWxsIHx8IG1ldGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldGEuZGIpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uO1xufSgpKTtcbnZhciBfc3RhdGVzID0ge1xuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiBpcyBydW5uaW5nIHdpdGggbm8gZXhwbGljaXQgc3VjY2VzcyBvciBmYWlsdXJlIG1hcmtlZFxuICAgIEFDVElWRToge1xuICAgICAgICBjb21taXQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfYS5jb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yID0gX2Eub25FcnJvciwgb25Db21wbGV0ZSA9IF9hLm9uQ29tcGxldGUsIG9uQ29ubmVjdGlvbiA9IF9hLm9uQ29ubmVjdGlvbiwgcGVuZGluZ1Jlc3VsdHMgPSBfYS5wZW5kaW5nUmVzdWx0cywgcHJlcGFyYXRpb25Kb2IgPSBfYS5wcmVwYXJhdGlvbkpvYjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmaW5pc2hUcmFuc2FjdGlvbih0cnVlLCBjb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yLCBvbkNvbXBsZXRlLCBvbkNvbm5lY3Rpb24sIHBlbmRpbmdSZXN1bHRzLCBwcmVwYXJhdGlvbkpvYiksXG4gICAgICAgICAgICAgICAgc3RhdGU6IF9zdGF0ZXMuU1VDQ0VFREVEXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByb2xsYmFjazogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9hLmNvbm5lY3Rpb25Ib2xkZXIsIG9uRXJyb3IgPSBfYS5vbkVycm9yLCBvbkNvbXBsZXRlID0gX2Eub25Db21wbGV0ZSwgb25Db25uZWN0aW9uID0gX2Eub25Db25uZWN0aW9uLCBwZW5kaW5nUmVzdWx0cyA9IF9hLnBlbmRpbmdSZXN1bHRzLCBwcmVwYXJhdGlvbkpvYiA9IF9hLnByZXBhcmF0aW9uSm9iO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZpbmlzaFRyYW5zYWN0aW9uKGZhbHNlLCBjb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yLCBvbkNvbXBsZXRlLCBvbkNvbm5lY3Rpb24sIHBlbmRpbmdSZXN1bHRzLCBwcmVwYXJhdGlvbkpvYiksXG4gICAgICAgICAgICAgICAgc3RhdGU6IF9zdGF0ZXMuUk9MTEVEX0JBQ0tcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bjogZnVuY3Rpb24gKHF1ZXJ5LCBwYXJhbWV0ZXJzLCBfYSkge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfYS5jb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yID0gX2Eub25FcnJvciwgb25Db21wbGV0ZSA9IF9hLm9uQ29tcGxldGUsIG9uQ29ubmVjdGlvbiA9IF9hLm9uQ29ubmVjdGlvbiwgcmVhY3RpdmUgPSBfYS5yZWFjdGl2ZSwgZmV0Y2hTaXplID0gX2EuZmV0Y2hTaXplLCBoaWdoUmVjb3JkV2F0ZXJtYXJrID0gX2EuaGlnaFJlY29yZFdhdGVybWFyaywgbG93UmVjb3JkV2F0ZXJtYXJrID0gX2EubG93UmVjb3JkV2F0ZXJtYXJrLCBwcmVwYXJhdGlvbkpvYiA9IF9hLnByZXBhcmF0aW9uSm9iO1xuICAgICAgICAgICAgLy8gUlVOIGluIGV4cGxpY2l0IHRyYW5zYWN0aW9uIGNhbid0IGNvbnRhaW4gYm9va21hcmtzIGFuZCB0cmFuc2FjdGlvbiBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGluY2x1ZGUgbW9kZSBhbmQgZGF0YWJhc2UgbmFtZSBhcyBpdCBzaGFsbCBiZSBpbmNsdWRlZCBpbiBiZWdpblxuICAgICAgICAgICAgdmFyIHJlcXVpcmVtZW50cyA9IHByZXBhcmF0aW9uSm9iICE9PSBudWxsICYmIHByZXBhcmF0aW9uSm9iICE9PSB2b2lkIDAgPyBwcmVwYXJhdGlvbkpvYiA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdmFyIG9ic2VydmVyUHJvbWlzZSA9IGNvbm5lY3Rpb25Ib2xkZXIuZ2V0Q29ubmVjdGlvbigpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbm4pIHsgcmV0dXJuIHJlcXVpcmVtZW50cy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm47IH0pOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgICAgICAgICAgb25Db25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubi5ydW4ocXVlcnksIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2ttYXJrczogYm9va21hcmtzXzEuQm9va21hcmtzLmVtcHR5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eENvbmZpZzogdHhfY29uZmlnXzEuVHhDb25maWcuZW1wdHkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJDb21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0aXZlOiByZWFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoU2l6ZTogZmV0Y2hTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaFJlY29yZFdhdGVybWFyazogaGlnaFJlY29yZFdhdGVybWFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd1JlY29yZFdhdGVybWFyazogbG93UmVjb3JkV2F0ZXJtYXJrXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdObyBjb25uZWN0aW9uIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gbmV3IG9ic2VydmVyc18xLkZhaWxlZE9ic2VydmVyKHsgZXJyb3I6IGVycm9yLCBvbkVycm9yOiBvbkVycm9yIH0pOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdDb21wbGV0ZWRSZXN1bHQob2JzZXJ2ZXJQcm9taXNlLCBxdWVyeSwgcGFyYW1ldGVycywgY29ubmVjdGlvbkhvbGRlciwgaGlnaFJlY29yZFdhdGVybWFyaywgbG93UmVjb3JkV2F0ZXJtYXJrKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gQW4gZXJyb3IgaGFzIG9jY3VycmVkLCB0cmFuc2FjdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYW5kIG5vIG1vcmUgbWVzc2FnZXMgd2lsbFxuICAgIC8vIGJlIHNlbnQgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgRkFJTEVEOiB7XG4gICAgICAgIGNvbW1pdDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9hLmNvbm5lY3Rpb25Ib2xkZXIsIG9uRXJyb3IgPSBfYS5vbkVycm9yLCBvbkNvbXBsZXRlID0gX2Eub25Db21wbGV0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IG9ic2VydmVyc18xLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnQ2Fubm90IGNvbW1pdCB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBiZWVuIHJvbGxlZCBiYWNrIGVpdGhlciBiZWNhdXNlIG9mIGFuIGVycm9yIG9yIGV4cGxpY2l0IHRlcm1pbmF0aW9uLicpLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICAgICAgICAgICAgfSksICdDT01NSVQnLCB7fSwgY29ubmVjdGlvbkhvbGRlciwgMCwgLy8gaGlnaCB3YXRlcm1hcmtcbiAgICAgICAgICAgICAgICAwIC8vIGxvdyB3YXRlcm1hcmtcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBfc3RhdGVzLkZBSUxFRFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcm9sbGJhY2s6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfYS5jb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yID0gX2Eub25FcnJvciwgb25Db21wbGV0ZSA9IF9hLm9uQ29tcGxldGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogbmV3Q29tcGxldGVkUmVzdWx0KG5ldyBvYnNlcnZlcnNfMS5Db21wbGV0ZWRPYnNlcnZlcigpLCAnUk9MTEJBQ0snLCB7fSwgY29ubmVjdGlvbkhvbGRlciwgMCwgLy8gaGlnaCB3YXRlcm1hcmtcbiAgICAgICAgICAgICAgICAwIC8vIGxvdyB3YXRlcm1hcmtcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBfc3RhdGVzLkZBSUxFRFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVuOiBmdW5jdGlvbiAocXVlcnksIHBhcmFtZXRlcnMsIF9hKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9hLmNvbm5lY3Rpb25Ib2xkZXIsIG9uRXJyb3IgPSBfYS5vbkVycm9yLCBvbkNvbXBsZXRlID0gX2Eub25Db21wbGV0ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IG9ic2VydmVyc18xLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yXzEubmV3RXJyb3IpKCdDYW5ub3QgcnVuIHF1ZXJ5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGJlZW4gcm9sbGVkIGJhY2sgZWl0aGVyIGJlY2F1c2Ugb2YgYW4gZXJyb3Igb3IgZXhwbGljaXQgdGVybWluYXRpb24uJyksXG4gICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgICAgfSksIHF1ZXJ5LCBwYXJhbWV0ZXJzLCBjb25uZWN0aW9uSG9sZGVyLCAwLCAvLyBoaWdoIHdhdGVybWFya1xuICAgICAgICAgICAgMCAvLyBsb3cgd2F0ZXJtYXJrXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIGhhcyBzdWNjZXNzZnVsbHkgY29tbWl0dGVkXG4gICAgU1VDQ0VFREVEOiB7XG4gICAgICAgIGNvbW1pdDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9hLmNvbm5lY3Rpb25Ib2xkZXIsIG9uRXJyb3IgPSBfYS5vbkVycm9yLCBvbkNvbXBsZXRlID0gX2Eub25Db21wbGV0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IG9ic2VydmVyc18xLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnQ2Fubm90IGNvbW1pdCB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY29tbWl0dGVkLicpLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICAgICAgICAgICAgfSksICdDT01NSVQnLCB7fSwgY29ubmVjdGlvbl9ob2xkZXJfMS5FTVBUWV9DT05ORUNUSU9OX0hPTERFUiwgMCwgLy8gaGlnaCB3YXRlcm1hcmtcbiAgICAgICAgICAgICAgICAwIC8vIGxvdyB3YXRlcm1hcmtcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBfc3RhdGVzLlNVQ0NFRURFRCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSG9sZGVyOiBjb25uZWN0aW9uSG9sZGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICByb2xsYmFjazogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9hLmNvbm5lY3Rpb25Ib2xkZXIsIG9uRXJyb3IgPSBfYS5vbkVycm9yLCBvbkNvbXBsZXRlID0gX2Eub25Db21wbGV0ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IG9ic2VydmVyc18xLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICgwLCBlcnJvcl8xLm5ld0Vycm9yKSgnQ2Fubm90IHJvbGxiYWNrIHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjb21taXR0ZWQuJyksXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgICAgICAgICB9KSwgJ1JPTExCQUNLJywge30sIGNvbm5lY3Rpb25faG9sZGVyXzEuRU1QVFlfQ09OTkVDVElPTl9IT0xERVIsIDAsIC8vIGhpZ2ggd2F0ZXJtYXJrXG4gICAgICAgICAgICAgICAgMCAvLyBsb3cgd2F0ZXJtYXJrXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogX3N0YXRlcy5TVUNDRUVERUQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkhvbGRlcjogY29ubmVjdGlvbkhvbGRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVuOiBmdW5jdGlvbiAocXVlcnksIHBhcmFtZXRlcnMsIF9hKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9hLmNvbm5lY3Rpb25Ib2xkZXIsIG9uRXJyb3IgPSBfYS5vbkVycm9yLCBvbkNvbXBsZXRlID0gX2Eub25Db21wbGV0ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IG9ic2VydmVyc18xLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yXzEubmV3RXJyb3IpKCdDYW5ub3QgcnVuIHF1ZXJ5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjb21taXR0ZWQuJyksXG4gICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgICAgfSksIHF1ZXJ5LCBwYXJhbWV0ZXJzLCBjb25uZWN0aW9uSG9sZGVyLCAwLCAvLyBoaWdoIHdhdGVybWFya1xuICAgICAgICAgICAgMCAvLyBsb3cgd2F0ZXJtYXJrXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHJvbGxlZCBiYWNrXG4gICAgUk9MTEVEX0JBQ0s6IHtcbiAgICAgICAgY29tbWl0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uSG9sZGVyID0gX2EuY29ubmVjdGlvbkhvbGRlciwgb25FcnJvciA9IF9hLm9uRXJyb3IsIG9uQ29tcGxldGUgPSBfYS5vbkNvbXBsZXRlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IG5ld0NvbXBsZXRlZFJlc3VsdChuZXcgb2JzZXJ2ZXJzXzEuRmFpbGVkT2JzZXJ2ZXIoe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yXzEubmV3RXJyb3IpKCdDYW5ub3QgY29tbWl0IHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiByb2xsZWQgYmFjay4nKSxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgICAgICAgIH0pLCAnQ09NTUlUJywge30sIGNvbm5lY3Rpb25Ib2xkZXIsIDAsIC8vIGhpZ2ggd2F0ZXJtYXJrXG4gICAgICAgICAgICAgICAgMCAvLyBsb3cgd2F0ZXJtYXJrXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogX3N0YXRlcy5ST0xMRURfQkFDS1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcm9sbGJhY2s6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25Ib2xkZXIgPSBfYS5jb25uZWN0aW9uSG9sZGVyLCBvbkVycm9yID0gX2Eub25FcnJvciwgb25Db21wbGV0ZSA9IF9hLm9uQ29tcGxldGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogbmV3Q29tcGxldGVkUmVzdWx0KG5ldyBvYnNlcnZlcnNfMS5GYWlsZWRPYnNlcnZlcih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAoMCwgZXJyb3JfMS5uZXdFcnJvcikoJ0Nhbm5vdCByb2xsYmFjayB0aGlzIHRyYW5zYWN0aW9uLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gcm9sbGVkIGJhY2suJylcbiAgICAgICAgICAgICAgICB9KSwgJ1JPTExCQUNLJywge30sIGNvbm5lY3Rpb25Ib2xkZXIsIDAsIC8vIGhpZ2ggd2F0ZXJtYXJrXG4gICAgICAgICAgICAgICAgMCAvLyBsb3cgd2F0ZXJtYXJrXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogX3N0YXRlcy5ST0xMRURfQkFDS1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVuOiBmdW5jdGlvbiAocXVlcnksIHBhcmFtZXRlcnMsIF9hKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbkhvbGRlciA9IF9hLmNvbm5lY3Rpb25Ib2xkZXIsIG9uRXJyb3IgPSBfYS5vbkVycm9yLCBvbkNvbXBsZXRlID0gX2Eub25Db21wbGV0ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXdDb21wbGV0ZWRSZXN1bHQobmV3IG9ic2VydmVyc18xLkZhaWxlZE9ic2VydmVyKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yXzEubmV3RXJyb3IpKCdDYW5ub3QgcnVuIHF1ZXJ5IGluIHRoaXMgdHJhbnNhY3Rpb24sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiByb2xsZWQgYmFjay4nKSxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICAgICAgICB9KSwgcXVlcnksIHBhcmFtZXRlcnMsIGNvbm5lY3Rpb25Ib2xkZXIsIDAsIC8vIGhpZ2ggd2F0ZXJtYXJrXG4gICAgICAgICAgICAwIC8vIGxvdyB3YXRlcm1hcmtcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBjb21taXRcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbkhvbGRlcn0gY29ubmVjdGlvbkhvbGRlclxuICogQHBhcmFtIHtmdW5jdGlvbihlcnI6RXJyb3IpOiBhbnl9IG9uRXJyb3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obWV0YWRhdGE6b2JqZWN0KTogYW55fSBvbkNvbXBsZXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCkgOiBhbnl9IG9uQ29ubmVjdGlvblxuICogQHBhcmFtIHtsaXN0PFJlc3VsdD4+fXBlbmRpbmdSZXN1bHRzIGFsbCBydW4gcmVzdWx0cyBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZpbmlzaFRyYW5zYWN0aW9uKGNvbW1pdCwgY29ubmVjdGlvbkhvbGRlciwgb25FcnJvciwgb25Db21wbGV0ZSwgb25Db25uZWN0aW9uLCBwZW5kaW5nUmVzdWx0cywgcHJlcGFyYXRpb25Kb2IpIHtcbiAgICB2YXIgcmVxdWlyZW1lbnRzID0gcHJlcGFyYXRpb25Kb2IgIT09IG51bGwgJiYgcHJlcGFyYXRpb25Kb2IgIT09IHZvaWQgMCA/IHByZXBhcmF0aW9uSm9iIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIG9ic2VydmVyUHJvbWlzZSA9IGNvbm5lY3Rpb25Ib2xkZXIuZ2V0Q29ubmVjdGlvbigpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb25uKSB7IHJldHVybiByZXF1aXJlbWVudHMudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uOyB9KTsgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgb25Db25uZWN0aW9uKCk7XG4gICAgICAgIHBlbmRpbmdSZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIuX2NhbmNlbCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmdSZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuc3VtbWFyeSgpOyB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21taXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY29tbWl0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlckNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ucm9sbGJhY2tUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFcnJvcjogb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yXzEubmV3RXJyb3IpKCdObyBjb25uZWN0aW9uIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBuZXcgb2JzZXJ2ZXJzXzEuRmFpbGVkT2JzZXJ2ZXIoeyBlcnJvcjogZXJyb3IsIG9uRXJyb3I6IG9uRXJyb3IgfSk7IH0pO1xuICAgIC8vIGZvciBjb21taXQgJiByb2xsYmFjayB3ZSBuZWVkIHJlc3VsdCB0aGF0IHVzZXMgcmVhbCBjb25uZWN0aW9uIGhvbGRlciBhbmQgbm90aWZpZXMgaXQgd2hlblxuICAgIC8vIGNvbm5lY3Rpb24gaXMgbm90IG5lZWRlZCBhbmQgY2FuIGJlIHNhZmVseSByZWxlYXNlZCB0byB0aGUgcG9vbFxuICAgIHJldHVybiBuZXcgcmVzdWx0XzEuZGVmYXVsdChvYnNlcnZlclByb21pc2UsIGNvbW1pdCA/ICdDT01NSVQnIDogJ1JPTExCQUNLJywge30sIGNvbm5lY3Rpb25Ib2xkZXIsIHtcbiAgICAgICAgaGlnaDogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgbG93OiBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUmVzdWx0fSB3aXRoIGVtcHR5IGNvbm5lY3Rpb24gaG9sZGVyLlxuICogRm9yIGNhc2VzIHdoZW4gcmVzdWx0IHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIG9yIGZhaWxlZCBhY3Rpb24sIGRvZXMgbm90IHJlcXVpcmUgYW55IG1ldGFkYXRhIGFuZCBkb2VzIG5vdFxuICogbmVlZCB0byBpbmZsdWVuY2UgcmVhbCBjb25uZWN0aW9uIGhvbGRlciB0byByZWxlYXNlIGNvbm5lY3Rpb25zLlxuICogQHBhcmFtIHtSZXN1bHRTdHJlYW1PYnNlcnZlcn0gb2JzZXJ2ZXIgLSBhbiBvYnNlcnZlciBmb3IgdGhlIGNyZWF0ZWQgcmVzdWx0LlxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5IC0gdGhlIGN5cGhlciBxdWVyeSB0aGF0IHByb2R1Y2VkIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIHRoZSBwYXJhbWV0ZXJzIGZvciBjeXBoZXIgcXVlcnkgdGhhdCBwcm9kdWNlZCB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtDb25uZWN0aW9uSG9sZGVyfSBjb25uZWN0aW9uSG9sZGVyIC0gdGhlIGNvbm5lY3Rpb24gaG9sZGVyIHVzZWQgdG8gZ2V0IHRoZSByZXN1bHRcbiAqIEByZXR1cm4ge1Jlc3VsdH0gbmV3IHJlc3VsdC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ld0NvbXBsZXRlZFJlc3VsdChvYnNlcnZlclByb21pc2UsIHF1ZXJ5LCBwYXJhbWV0ZXJzLCBjb25uZWN0aW9uSG9sZGVyLCBoaWdoUmVjb3JkV2F0ZXJtYXJrLCBsb3dSZWNvcmRXYXRlcm1hcmspIHtcbiAgICBpZiAoY29ubmVjdGlvbkhvbGRlciA9PT0gdm9pZCAwKSB7IGNvbm5lY3Rpb25Ib2xkZXIgPSBjb25uZWN0aW9uX2hvbGRlcl8xLkVNUFRZX0NPTk5FQ1RJT05fSE9MREVSOyB9XG4gICAgcmV0dXJuIG5ldyByZXN1bHRfMS5kZWZhdWx0KFByb21pc2UucmVzb2x2ZShvYnNlcnZlclByb21pc2UpLCBxdWVyeSwgcGFyYW1ldGVycywgbmV3IGNvbm5lY3Rpb25faG9sZGVyXzEuUmVhZE9ubHlDb25uZWN0aW9uSG9sZGVyKGNvbm5lY3Rpb25Ib2xkZXIgIT09IG51bGwgJiYgY29ubmVjdGlvbkhvbGRlciAhPT0gdm9pZCAwID8gY29ubmVjdGlvbkhvbGRlciA6IGNvbm5lY3Rpb25faG9sZGVyXzEuRU1QVFlfQ09OTkVDVElPTl9IT0xERVIpLCB7XG4gICAgICAgIGxvdzogbG93UmVjb3JkV2F0ZXJtYXJrLFxuICAgICAgICBoaWdoOiBoaWdoUmVjb3JkV2F0ZXJtYXJrXG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2FjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/neo4j-driver-core/lib/types.js":
/*!*****************************************************!*\
  !*** ./node_modules/neo4j-driver-core/lib/types.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [https://neo4j.com]\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InternalConfig = exports.Config = void 0;\n/**\n * The Neo4j Driver configuration.\n *\n * @interface\n */\nvar Config = /** @class */ (function () {\n    /**\n     * @constructor\n     * @private\n     */\n    function Config() {\n        /**\n         * Encryption level\n         *\n         * @type {'ENCRYPTION_ON'|'ENCRYPTION_OFF'|undefined}\n         */\n        this.encrypted = undefined;\n        /**\n         * Trust strategy to use if encryption is enabled.\n         *\n         * There is no mode to disable trust other than disabling encryption altogether. The reason for\n         * this is that if you don't know who you are talking to, it is easy for an\n         * attacker to hijack your encrypted connection, rendering encryption pointless.\n         *\n         * TRUST_SYSTEM_CA_SIGNED_CERTIFICATES is the default choice. For NodeJS environments, this\n         * means that you trust whatever certificates are in the default trusted certificate\n         * store of the underlying system. For Browser environments, the trusted certificate\n         * store is usually managed by the browser. Refer to your system or browser documentation\n         * if you want to explicitly add a certificate as trusted.\n         *\n         * TRUST_CUSTOM_CA_SIGNED_CERTIFICATES is another option for trust verification -\n         * whenever we establish an encrypted connection, we ensure the host is using\n         * an encryption certificate that is in, or is signed by, a certificate given\n         * as trusted through configuration. This option is only available for NodeJS environments.\n         *\n         * TRUST_ALL_CERTIFICATES means that you trust everything without any verifications\n         * steps carried out.  This option is only available for NodeJS environments and should not\n         * be used on production systems.\n         *\n         * @type {'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES'|'TRUST_CUSTOM_CA_SIGNED_CERTIFICATES'|'TRUST_ALL_CERTIFICATES'|undefined}\n         */\n        this.trust = undefined;\n        /**\n         * List of one or more paths to trusted encryption certificates.\n         *\n         * This only works in the NodeJS bundle,\n         * and only matters if you use \"TRUST_CUSTOM_CA_SIGNED_CERTIFICATES\".\n         *\n         * The certificate files should be in regular X.509 PEM format.\n         *\n         * For instance, ['./trusted.pem']\n         *\n         * @type {?string[]}\n         * @see {@link Config#trust}\n         */\n        this.trustedCertificates = [];\n        /**\n         * The maximum total number of connections allowed to be managed by the connection pool, per host.\n         *\n         * This includes both in-use and idle connections.\n         *\n         * **Default**: ```100```\n         *\n         * @type {number|undefined}\n         */\n        this.maxConnectionPoolSize = 100;\n        /**\n         * The maximum allowed lifetime for a pooled connection in milliseconds.\n         *\n         * Pooled connections older than this\n         * threshold will be closed and removed from the pool. Such discarding happens during connection acquisition\n         * so that new session is never backed by an old connection. Setting this option to a low value will cause\n         * a high connection churn and might result in a performance hit. It is recommended to set maximum lifetime\n         * to a slightly smaller value than the one configured in network equipment (load balancer, proxy, firewall,\n         * etc. can also limit maximum connection lifetime). No maximum lifetime limit is imposed by default. Zero\n         * and negative values result in lifetime not being checked.\n         *\n         * **Default**: ```60 * 60 * 1000``` (1 hour)\n         *\n         * @type {number|undefined}\n         */\n        this.maxConnectionLifetime = 60 * 60 * 1000; // 1 hour\n        /**\n         * The maximum amount of time to wait to acquire a connection from the pool (to either create a new\n         * connection or borrow an existing one).\n         *\n         * **Default**: ```60000``` (1 minute)\n         *\n         * @type {number|undefined}\n         */\n        this.connectionAcquisitionTimeout = 60000; // 1 minute\n        /**\n         * Specify the maximum time in milliseconds transactions are allowed to retry via\n         * {@link Session#executeRead}, {@link Session#executeWrite}, and {@link Driver#executeQuery} functions.\n         *\n         * These functions will retry the given unit of work on `ServiceUnavailable`, `SessionExpired` and transient\n         * errors with exponential backoff using an initial delay of 1 second.\n         *\n         * **Default**: ```30000``` (30 seconds)\n         *\n         * @type {number|undefined}\n         */\n        this.maxTransactionRetryTime = 30000; // 30 seconds\n        /**\n         * Specify the maximum time in milliseconds the connection can be idle without needing\n         * to perform a liveness check on acquire from the pool.\n         *\n         * Pooled connections that have been idle in the pool for longer than this\n         * timeout will be tested before they are used again, to ensure they are still live.\n         * If this option is set too low, an additional network call will be incurred\n         * when acquiring a connection, which causes a performance hit.\n         *\n         * If this is set high, you may receive sessions that are backed by no longer\n         * live connections, which will lead to exceptions in your application.\n         * Assuming the database is running, these exceptions will go away if you retry\n         * acquiring sessions.\n         *\n         * Hence, this parameter tunes a balance between the likelihood of your application\n         * seeing connection problems, and performance.\n         *\n         * You normally should not need to tune this parameter. No connection liveliness\n         * check is done by default. Value 0 means connections will always be tested for\n         * validity and negative values mean connections will never be tested.\n         *\n         * **Default**: ```undefined``` (Disabled)\n         *\n         * @type {number|undefined}\n         */\n        this.connectionLivenessCheckTimeout = undefined; // Disabled\n        /**\n         * Specify socket connection timeout in milliseconds.\n         *\n         * Negative and zero values result in no timeout being applied.\n         * Connection establishment will be then bound by the timeout configured\n         * on the operating system level.\n         *\n         * **Default**: ```30000``` (30 seconds)\n         *\n         * @type {number|undefined}\n         */\n        this.connectionTimeout = 30000; // 30 seconds\n        /**\n         * Make this driver always return native JavaScript numbers for integer values, instead of the\n         * dedicated {@link Integer} class.\n         *\n         * Values that do not fit in native number bit range will be represented as `Number.NEGATIVE_INFINITY` or `Number.POSITIVE_INFINITY`.\n         *\n         * **Warning:** {@link ResultSummary} It is not always safe to enable this setting when JavaScript applications are not the only ones\n         * interacting with the database. Stored numbers might in such case be not representable by native\n         * `Number` type and thus the driver will return lossy values. This might also happen when data was\n         * initially imported using neo4j import tool and contained numbers larger than\n         * `Number.MAX_SAFE_INTEGER`. Driver will then return positive infinity, which is lossy.\n         *\n         * **Default**: ```false```\n         *\n         * Default value for this option is `false` because native JavaScript numbers might result\n         * in loss of precision in the general case.\n         *\n         * @type {boolean|undefined}\n         */\n        this.disableLosslessIntegers = false;\n        /**\n         * Make this driver always return native Javascript `BigInt` for integer values,\n         * instead of the dedicated {@link Integer} class or `Number`.\n         *\n         * **Warning:** `BigInt` doesn't implement the method `toJSON`. To serialize it as `json`,\n         * it's needed to add a custom implementation of the `toJSON` on the\n         * `BigInt.prototype`. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json.\n         *\n         * **Default**: ```false``` (for backwards compatibility)\n         *\n         * @type {boolean|undefined}\n         */\n        this.useBigInt = false;\n        /**\n         * Specify the logging configuration for the driver. Object should have two properties `level` and `logger`.\n         *\n         * Property `level` represents the logging level which should be one of: 'error', 'warn', 'info' or 'debug'. This property is optional and\n         * its default value is 'info'. Levels have priorities: 'error': 0, 'warn': 1, 'info': 2, 'debug': 3. Enabling a certain level also enables all\n         * levels with lower priority. For example: 'error', 'warn' and 'info' will be logged when 'info' level is configured.\n         *\n         * Property `logger` represents the logging function which will be invoked for every log call with an acceptable level. The function should\n         * take two string arguments `level` and `message`. The function should not execute any blocking or long-running operations\n         * because it is often executed on a hot path.\n         *\n         * No logging is done by default. See `neo4j.logging` object that contains predefined logging implementations.\n         *\n         * @type {LoggingConfig|undefined}\n         * @see {@link logging}\n         */\n        this.logging = undefined;\n        /**\n         * Specify a custom server address resolver function used by the routing driver to resolve the initial address used to create the driver.\n         *\n         * Such resolution happens:\n         *   * during the very first rediscovery when driver is created\n         *   * when all the known routers from the current routing table have failed and driver needs to fallback to the initial address\n         *\n         *  In NodeJS environment driver defaults to performing a DNS resolution of the initial address using 'dns' module.\n         *  In browser environment driver uses the initial address as-is.\n         *  Value should be a function that takes a single string argument - the initial address. It should return an array of new addresses.\n         *  Address is a string of shape '<host>:<port>'. Provided function can return either a Promise resolved with an array of addresses\n         *  or array of addresses directly.\n         *\n         * @type {function(address: string) {} |undefined}\n         */\n        this.resolver = undefined;\n        /**\n         * Configure filter for Notification objects returned in {@link ResultSummary#notifications}.\n         *\n         * See {@link SessionConfig#notificationFilter} for usage instructions.\n         *\n         * @type {NotificationFilter|undefined}\n         */\n        this.notificationFilter = undefined;\n        /**\n         * Optionally override the default user agent name.\n         *\n         * **Default**: ```'neo4j-javascript/<version>'```\n         *\n         * @type {string|undefined}\n         */\n        this.userAgent = undefined;\n        /**\n         * Specify if telemetry collection is disabled.\n         *\n         * By default, the driver will send anonymous usage statistics to the server it connects to if the server requests those.\n         * By setting ``telemetryDisabled=true``, the driver will not send any telemetry data.\n         *\n         * The driver transmits the following information:\n         *\n         * Every time one of the following APIs is used to execute a query (for the first time), the server is informed of this\n         * (without any further information like arguments, client identifiers, etc.):\n         *\n         * * {@link Driver#executeQuery}\n         * * {@link Session#run}\n         * * {@link Session#beginTransaction}\n         * * {@link Session#executeRead}\n         * * {@link Session#executeWrite}\n         * * {@link Session#writeTransaction}\n         * * {@link Session#readTransaction}\n         * * The reactive counterparts of methods above.\n         *\n         * Metrics are only collected when enabled both in server and driver instances.\n         *\n         * **Default**: ```false```\n         *\n         * @type {boolean}\n         */\n        this.telemetryDisabled = false;\n        /**\n         * Client Certificate used for mutual TLS.\n         *\n         * A {@link ClientCertificateProvider} can be configure for scenarios\n         * where the {@link ClientCertificate} might change over time.\n         *\n         * @type {ClientCertificate|ClientCertificateProvider|undefined}\n         * @since 5.27\n         */\n        this.clientCertificate = undefined;\n    }\n    return Config;\n}());\nexports.Config = Config;\nvar InternalConfig = /** @class */ (function (_super) {\n    __extends(InternalConfig, _super);\n    function InternalConfig() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return InternalConfig;\n}(Config));\nexports.InternalConfig = InternalConfig;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmVvNGotZHJpdmVyLWNvcmUvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQixHQUFHLDJCQUEyQixPQUFPLDJCQUEyQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtDQUFrQztBQUNwRztBQUNBLGdCQUFnQix3Q0FBd0M7QUFDeEQ7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQztBQUMvQyxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJjZWwtbmVvNGotYWktb3BlbmFpLy4vbm9kZV9tb2R1bGVzL25lbzRqLWRyaXZlci1jb3JlL2xpYi90eXBlcy5qcz9mZjQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIFwiTmVvNGpcIlxuICogTmVvNGogU3dlZGVuIEFCIFtodHRwczovL25lbzRqLmNvbV1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVybmFsQ29uZmlnID0gZXhwb3J0cy5Db25maWcgPSB2b2lkIDA7XG4vKipcbiAqIFRoZSBOZW80aiBEcml2ZXIgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbnZhciBDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb25maWcoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNyeXB0aW9uIGxldmVsXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHsnRU5DUllQVElPTl9PTid8J0VOQ1JZUFRJT05fT0ZGJ3x1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuY3J5cHRlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydXN0IHN0cmF0ZWd5IHRvIHVzZSBpZiBlbmNyeXB0aW9uIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZXJlIGlzIG5vIG1vZGUgdG8gZGlzYWJsZSB0cnVzdCBvdGhlciB0aGFuIGRpc2FibGluZyBlbmNyeXB0aW9uIGFsdG9nZXRoZXIuIFRoZSByZWFzb24gZm9yXG4gICAgICAgICAqIHRoaXMgaXMgdGhhdCBpZiB5b3UgZG9uJ3Qga25vdyB3aG8geW91IGFyZSB0YWxraW5nIHRvLCBpdCBpcyBlYXN5IGZvciBhblxuICAgICAgICAgKiBhdHRhY2tlciB0byBoaWphY2sgeW91ciBlbmNyeXB0ZWQgY29ubmVjdGlvbiwgcmVuZGVyaW5nIGVuY3J5cHRpb24gcG9pbnRsZXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUUlVTVF9TWVNURU1fQ0FfU0lHTkVEX0NFUlRJRklDQVRFUyBpcyB0aGUgZGVmYXVsdCBjaG9pY2UuIEZvciBOb2RlSlMgZW52aXJvbm1lbnRzLCB0aGlzXG4gICAgICAgICAqIG1lYW5zIHRoYXQgeW91IHRydXN0IHdoYXRldmVyIGNlcnRpZmljYXRlcyBhcmUgaW4gdGhlIGRlZmF1bHQgdHJ1c3RlZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgKiBzdG9yZSBvZiB0aGUgdW5kZXJseWluZyBzeXN0ZW0uIEZvciBCcm93c2VyIGVudmlyb25tZW50cywgdGhlIHRydXN0ZWQgY2VydGlmaWNhdGVcbiAgICAgICAgICogc3RvcmUgaXMgdXN1YWxseSBtYW5hZ2VkIGJ5IHRoZSBicm93c2VyLiBSZWZlciB0byB5b3VyIHN5c3RlbSBvciBicm93c2VyIGRvY3VtZW50YXRpb25cbiAgICAgICAgICogaWYgeW91IHdhbnQgdG8gZXhwbGljaXRseSBhZGQgYSBjZXJ0aWZpY2F0ZSBhcyB0cnVzdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUUlVTVF9DVVNUT01fQ0FfU0lHTkVEX0NFUlRJRklDQVRFUyBpcyBhbm90aGVyIG9wdGlvbiBmb3IgdHJ1c3QgdmVyaWZpY2F0aW9uIC1cbiAgICAgICAgICogd2hlbmV2ZXIgd2UgZXN0YWJsaXNoIGFuIGVuY3J5cHRlZCBjb25uZWN0aW9uLCB3ZSBlbnN1cmUgdGhlIGhvc3QgaXMgdXNpbmdcbiAgICAgICAgICogYW4gZW5jcnlwdGlvbiBjZXJ0aWZpY2F0ZSB0aGF0IGlzIGluLCBvciBpcyBzaWduZWQgYnksIGEgY2VydGlmaWNhdGUgZ2l2ZW5cbiAgICAgICAgICogYXMgdHJ1c3RlZCB0aHJvdWdoIGNvbmZpZ3VyYXRpb24uIFRoaXMgb3B0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBOb2RlSlMgZW52aXJvbm1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUUlVTVF9BTExfQ0VSVElGSUNBVEVTIG1lYW5zIHRoYXQgeW91IHRydXN0IGV2ZXJ5dGhpbmcgd2l0aG91dCBhbnkgdmVyaWZpY2F0aW9uc1xuICAgICAgICAgKiBzdGVwcyBjYXJyaWVkIG91dC4gIFRoaXMgb3B0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBOb2RlSlMgZW52aXJvbm1lbnRzIGFuZCBzaG91bGQgbm90XG4gICAgICAgICAqIGJlIHVzZWQgb24gcHJvZHVjdGlvbiBzeXN0ZW1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7J1RSVVNUX1NZU1RFTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTJ3wnVFJVU1RfQ1VTVE9NX0NBX1NJR05FRF9DRVJUSUZJQ0FURVMnfCdUUlVTVF9BTExfQ0VSVElGSUNBVEVTJ3x1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRydXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBvbmUgb3IgbW9yZSBwYXRocyB0byB0cnVzdGVkIGVuY3J5cHRpb24gY2VydGlmaWNhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9ubHkgd29ya3MgaW4gdGhlIE5vZGVKUyBidW5kbGUsXG4gICAgICAgICAqIGFuZCBvbmx5IG1hdHRlcnMgaWYgeW91IHVzZSBcIlRSVVNUX0NVU1RPTV9DQV9TSUdORURfQ0VSVElGSUNBVEVTXCIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjZXJ0aWZpY2F0ZSBmaWxlcyBzaG91bGQgYmUgaW4gcmVndWxhciBYLjUwOSBQRU0gZm9ybWF0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgaW5zdGFuY2UsIFsnLi90cnVzdGVkLnBlbSddXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHs/c3RyaW5nW119XG4gICAgICAgICAqIEBzZWUge0BsaW5rIENvbmZpZyN0cnVzdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJ1c3RlZENlcnRpZmljYXRlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gdG90YWwgbnVtYmVyIG9mIGNvbm5lY3Rpb25zIGFsbG93ZWQgdG8gYmUgbWFuYWdlZCBieSB0aGUgY29ubmVjdGlvbiBwb29sLCBwZXIgaG9zdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpbmNsdWRlcyBib3RoIGluLXVzZSBhbmQgaWRsZSBjb25uZWN0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogKipEZWZhdWx0Kio6IGBgYDEwMGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4Q29ubmVjdGlvblBvb2xTaXplID0gMTAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gYWxsb3dlZCBsaWZldGltZSBmb3IgYSBwb29sZWQgY29ubmVjdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBvb2xlZCBjb25uZWN0aW9ucyBvbGRlciB0aGFuIHRoaXNcbiAgICAgICAgICogdGhyZXNob2xkIHdpbGwgYmUgY2xvc2VkIGFuZCByZW1vdmVkIGZyb20gdGhlIHBvb2wuIFN1Y2ggZGlzY2FyZGluZyBoYXBwZW5zIGR1cmluZyBjb25uZWN0aW9uIGFjcXVpc2l0aW9uXG4gICAgICAgICAqIHNvIHRoYXQgbmV3IHNlc3Npb24gaXMgbmV2ZXIgYmFja2VkIGJ5IGFuIG9sZCBjb25uZWN0aW9uLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGEgbG93IHZhbHVlIHdpbGwgY2F1c2VcbiAgICAgICAgICogYSBoaWdoIGNvbm5lY3Rpb24gY2h1cm4gYW5kIG1pZ2h0IHJlc3VsdCBpbiBhIHBlcmZvcm1hbmNlIGhpdC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gc2V0IG1heGltdW0gbGlmZXRpbWVcbiAgICAgICAgICogdG8gYSBzbGlnaHRseSBzbWFsbGVyIHZhbHVlIHRoYW4gdGhlIG9uZSBjb25maWd1cmVkIGluIG5ldHdvcmsgZXF1aXBtZW50IChsb2FkIGJhbGFuY2VyLCBwcm94eSwgZmlyZXdhbGwsXG4gICAgICAgICAqIGV0Yy4gY2FuIGFsc28gbGltaXQgbWF4aW11bSBjb25uZWN0aW9uIGxpZmV0aW1lKS4gTm8gbWF4aW11bSBsaWZldGltZSBsaW1pdCBpcyBpbXBvc2VkIGJ5IGRlZmF1bHQuIFplcm9cbiAgICAgICAgICogYW5kIG5lZ2F0aXZlIHZhbHVlcyByZXN1bHQgaW4gbGlmZXRpbWUgbm90IGJlaW5nIGNoZWNrZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqRGVmYXVsdCoqOiBgYGA2MCAqIDYwICogMTAwMGBgYCAoMSBob3VyKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4Q29ubmVjdGlvbkxpZmV0aW1lID0gNjAgKiA2MCAqIDEwMDA7IC8vIDEgaG91clxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCB0byBhY3F1aXJlIGEgY29ubmVjdGlvbiBmcm9tIHRoZSBwb29sICh0byBlaXRoZXIgY3JlYXRlIGEgbmV3XG4gICAgICAgICAqIGNvbm5lY3Rpb24gb3IgYm9ycm93IGFuIGV4aXN0aW5nIG9uZSkuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqRGVmYXVsdCoqOiBgYGA2MDAwMGBgYCAoMSBtaW51dGUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQWNxdWlzaXRpb25UaW1lb3V0ID0gNjAwMDA7IC8vIDEgbWludXRlXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoZSBtYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRyYW5zYWN0aW9ucyBhcmUgYWxsb3dlZCB0byByZXRyeSB2aWFcbiAgICAgICAgICoge0BsaW5rIFNlc3Npb24jZXhlY3V0ZVJlYWR9LCB7QGxpbmsgU2Vzc2lvbiNleGVjdXRlV3JpdGV9LCBhbmQge0BsaW5rIERyaXZlciNleGVjdXRlUXVlcnl9IGZ1bmN0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgcmV0cnkgdGhlIGdpdmVuIHVuaXQgb2Ygd29yayBvbiBgU2VydmljZVVuYXZhaWxhYmxlYCwgYFNlc3Npb25FeHBpcmVkYCBhbmQgdHJhbnNpZW50XG4gICAgICAgICAqIGVycm9ycyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYgdXNpbmcgYW4gaW5pdGlhbCBkZWxheSBvZiAxIHNlY29uZC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipEZWZhdWx0Kio6IGBgYDMwMDAwYGBgICgzMCBzZWNvbmRzKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4VHJhbnNhY3Rpb25SZXRyeVRpbWUgPSAzMDAwMDsgLy8gMzAgc2Vjb25kc1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSB0aGUgbWF4aW11bSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGUgY29ubmVjdGlvbiBjYW4gYmUgaWRsZSB3aXRob3V0IG5lZWRpbmdcbiAgICAgICAgICogdG8gcGVyZm9ybSBhIGxpdmVuZXNzIGNoZWNrIG9uIGFjcXVpcmUgZnJvbSB0aGUgcG9vbC5cbiAgICAgICAgICpcbiAgICAgICAgICogUG9vbGVkIGNvbm5lY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGlkbGUgaW4gdGhlIHBvb2wgZm9yIGxvbmdlciB0aGFuIHRoaXNcbiAgICAgICAgICogdGltZW91dCB3aWxsIGJlIHRlc3RlZCBiZWZvcmUgdGhleSBhcmUgdXNlZCBhZ2FpbiwgdG8gZW5zdXJlIHRoZXkgYXJlIHN0aWxsIGxpdmUuXG4gICAgICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCB0b28gbG93LCBhbiBhZGRpdGlvbmFsIG5ldHdvcmsgY2FsbCB3aWxsIGJlIGluY3VycmVkXG4gICAgICAgICAqIHdoZW4gYWNxdWlyaW5nIGEgY29ubmVjdGlvbiwgd2hpY2ggY2F1c2VzIGEgcGVyZm9ybWFuY2UgaGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIHNldCBoaWdoLCB5b3UgbWF5IHJlY2VpdmUgc2Vzc2lvbnMgdGhhdCBhcmUgYmFja2VkIGJ5IG5vIGxvbmdlclxuICAgICAgICAgKiBsaXZlIGNvbm5lY3Rpb25zLCB3aGljaCB3aWxsIGxlYWQgdG8gZXhjZXB0aW9ucyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAgICAgKiBBc3N1bWluZyB0aGUgZGF0YWJhc2UgaXMgcnVubmluZywgdGhlc2UgZXhjZXB0aW9ucyB3aWxsIGdvIGF3YXkgaWYgeW91IHJldHJ5XG4gICAgICAgICAqIGFjcXVpcmluZyBzZXNzaW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogSGVuY2UsIHRoaXMgcGFyYW1ldGVyIHR1bmVzIGEgYmFsYW5jZSBiZXR3ZWVuIHRoZSBsaWtlbGlob29kIG9mIHlvdXIgYXBwbGljYXRpb25cbiAgICAgICAgICogc2VlaW5nIGNvbm5lY3Rpb24gcHJvYmxlbXMsIGFuZCBwZXJmb3JtYW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IG5vcm1hbGx5IHNob3VsZCBub3QgbmVlZCB0byB0dW5lIHRoaXMgcGFyYW1ldGVyLiBObyBjb25uZWN0aW9uIGxpdmVsaW5lc3NcbiAgICAgICAgICogY2hlY2sgaXMgZG9uZSBieSBkZWZhdWx0LiBWYWx1ZSAwIG1lYW5zIGNvbm5lY3Rpb25zIHdpbGwgYWx3YXlzIGJlIHRlc3RlZCBmb3JcbiAgICAgICAgICogdmFsaWRpdHkgYW5kIG5lZ2F0aXZlIHZhbHVlcyBtZWFuIGNvbm5lY3Rpb25zIHdpbGwgbmV2ZXIgYmUgdGVzdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKkRlZmF1bHQqKjogYGBgdW5kZWZpbmVkYGBgIChEaXNhYmxlZClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25MaXZlbmVzc0NoZWNrVGltZW91dCA9IHVuZGVmaW5lZDsgLy8gRGlzYWJsZWRcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgc29ja2V0IGNvbm5lY3Rpb24gdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5lZ2F0aXZlIGFuZCB6ZXJvIHZhbHVlcyByZXN1bHQgaW4gbm8gdGltZW91dCBiZWluZyBhcHBsaWVkLlxuICAgICAgICAgKiBDb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgd2lsbCBiZSB0aGVuIGJvdW5kIGJ5IHRoZSB0aW1lb3V0IGNvbmZpZ3VyZWRcbiAgICAgICAgICogb24gdGhlIG9wZXJhdGluZyBzeXN0ZW0gbGV2ZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqRGVmYXVsdCoqOiBgYGAzMDAwMGBgYCAoMzAgc2Vjb25kcylcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0ID0gMzAwMDA7IC8vIDMwIHNlY29uZHNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2UgdGhpcyBkcml2ZXIgYWx3YXlzIHJldHVybiBuYXRpdmUgSmF2YVNjcmlwdCBudW1iZXJzIGZvciBpbnRlZ2VyIHZhbHVlcywgaW5zdGVhZCBvZiB0aGVcbiAgICAgICAgICogZGVkaWNhdGVkIHtAbGluayBJbnRlZ2VyfSBjbGFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVmFsdWVzIHRoYXQgZG8gbm90IGZpdCBpbiBuYXRpdmUgbnVtYmVyIGJpdCByYW5nZSB3aWxsIGJlIHJlcHJlc2VudGVkIGFzIGBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlgIG9yIGBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlgLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKldhcm5pbmc6Kioge0BsaW5rIFJlc3VsdFN1bW1hcnl9IEl0IGlzIG5vdCBhbHdheXMgc2FmZSB0byBlbmFibGUgdGhpcyBzZXR0aW5nIHdoZW4gSmF2YVNjcmlwdCBhcHBsaWNhdGlvbnMgYXJlIG5vdCB0aGUgb25seSBvbmVzXG4gICAgICAgICAqIGludGVyYWN0aW5nIHdpdGggdGhlIGRhdGFiYXNlLiBTdG9yZWQgbnVtYmVycyBtaWdodCBpbiBzdWNoIGNhc2UgYmUgbm90IHJlcHJlc2VudGFibGUgYnkgbmF0aXZlXG4gICAgICAgICAqIGBOdW1iZXJgIHR5cGUgYW5kIHRodXMgdGhlIGRyaXZlciB3aWxsIHJldHVybiBsb3NzeSB2YWx1ZXMuIFRoaXMgbWlnaHQgYWxzbyBoYXBwZW4gd2hlbiBkYXRhIHdhc1xuICAgICAgICAgKiBpbml0aWFsbHkgaW1wb3J0ZWQgdXNpbmcgbmVvNGogaW1wb3J0IHRvb2wgYW5kIGNvbnRhaW5lZCBudW1iZXJzIGxhcmdlciB0aGFuXG4gICAgICAgICAqIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuIERyaXZlciB3aWxsIHRoZW4gcmV0dXJuIHBvc2l0aXZlIGluZmluaXR5LCB3aGljaCBpcyBsb3NzeS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipEZWZhdWx0Kio6IGBgYGZhbHNlYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHQgdmFsdWUgZm9yIHRoaXMgb3B0aW9uIGlzIGBmYWxzZWAgYmVjYXVzZSBuYXRpdmUgSmF2YVNjcmlwdCBudW1iZXJzIG1pZ2h0IHJlc3VsdFxuICAgICAgICAgKiBpbiBsb3NzIG9mIHByZWNpc2lvbiBpbiB0aGUgZ2VuZXJhbCBjYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVMb3NzbGVzc0ludGVnZXJzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIHRoaXMgZHJpdmVyIGFsd2F5cyByZXR1cm4gbmF0aXZlIEphdmFzY3JpcHQgYEJpZ0ludGAgZm9yIGludGVnZXIgdmFsdWVzLFxuICAgICAgICAgKiBpbnN0ZWFkIG9mIHRoZSBkZWRpY2F0ZWQge0BsaW5rIEludGVnZXJ9IGNsYXNzIG9yIGBOdW1iZXJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKldhcm5pbmc6KiogYEJpZ0ludGAgZG9lc24ndCBpbXBsZW1lbnQgdGhlIG1ldGhvZCBgdG9KU09OYC4gVG8gc2VyaWFsaXplIGl0IGFzIGBqc29uYCxcbiAgICAgICAgICogaXQncyBuZWVkZWQgdG8gYWRkIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgdG9KU09OYCBvbiB0aGVcbiAgICAgICAgICogYEJpZ0ludC5wcm90b3R5cGVgLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQmlnSW50I3VzZV93aXRoaW5fanNvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogKipEZWZhdWx0Kio6IGBgYGZhbHNlYGBgIChmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlQmlnSW50ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoZSBsb2dnaW5nIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkcml2ZXIuIE9iamVjdCBzaG91bGQgaGF2ZSB0d28gcHJvcGVydGllcyBgbGV2ZWxgIGFuZCBgbG9nZ2VyYC5cbiAgICAgICAgICpcbiAgICAgICAgICogUHJvcGVydHkgYGxldmVsYCByZXByZXNlbnRzIHRoZSBsb2dnaW5nIGxldmVsIHdoaWNoIHNob3VsZCBiZSBvbmUgb2Y6ICdlcnJvcicsICd3YXJuJywgJ2luZm8nIG9yICdkZWJ1ZycuIFRoaXMgcHJvcGVydHkgaXMgb3B0aW9uYWwgYW5kXG4gICAgICAgICAqIGl0cyBkZWZhdWx0IHZhbHVlIGlzICdpbmZvJy4gTGV2ZWxzIGhhdmUgcHJpb3JpdGllczogJ2Vycm9yJzogMCwgJ3dhcm4nOiAxLCAnaW5mbyc6IDIsICdkZWJ1Zyc6IDMuIEVuYWJsaW5nIGEgY2VydGFpbiBsZXZlbCBhbHNvIGVuYWJsZXMgYWxsXG4gICAgICAgICAqIGxldmVscyB3aXRoIGxvd2VyIHByaW9yaXR5LiBGb3IgZXhhbXBsZTogJ2Vycm9yJywgJ3dhcm4nIGFuZCAnaW5mbycgd2lsbCBiZSBsb2dnZWQgd2hlbiAnaW5mbycgbGV2ZWwgaXMgY29uZmlndXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogUHJvcGVydHkgYGxvZ2dlcmAgcmVwcmVzZW50cyB0aGUgbG9nZ2luZyBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGludm9rZWQgZm9yIGV2ZXJ5IGxvZyBjYWxsIHdpdGggYW4gYWNjZXB0YWJsZSBsZXZlbC4gVGhlIGZ1bmN0aW9uIHNob3VsZFxuICAgICAgICAgKiB0YWtlIHR3byBzdHJpbmcgYXJndW1lbnRzIGBsZXZlbGAgYW5kIGBtZXNzYWdlYC4gVGhlIGZ1bmN0aW9uIHNob3VsZCBub3QgZXhlY3V0ZSBhbnkgYmxvY2tpbmcgb3IgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbnNcbiAgICAgICAgICogYmVjYXVzZSBpdCBpcyBvZnRlbiBleGVjdXRlZCBvbiBhIGhvdCBwYXRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBObyBsb2dnaW5nIGlzIGRvbmUgYnkgZGVmYXVsdC4gU2VlIGBuZW80ai5sb2dnaW5nYCBvYmplY3QgdGhhdCBjb250YWlucyBwcmVkZWZpbmVkIGxvZ2dpbmcgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7TG9nZ2luZ0NvbmZpZ3x1bmRlZmluZWR9XG4gICAgICAgICAqIEBzZWUge0BsaW5rIGxvZ2dpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvZ2dpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgY3VzdG9tIHNlcnZlciBhZGRyZXNzIHJlc29sdmVyIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIHJvdXRpbmcgZHJpdmVyIHRvIHJlc29sdmUgdGhlIGluaXRpYWwgYWRkcmVzcyB1c2VkIHRvIGNyZWF0ZSB0aGUgZHJpdmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTdWNoIHJlc29sdXRpb24gaGFwcGVuczpcbiAgICAgICAgICogICAqIGR1cmluZyB0aGUgdmVyeSBmaXJzdCByZWRpc2NvdmVyeSB3aGVuIGRyaXZlciBpcyBjcmVhdGVkXG4gICAgICAgICAqICAgKiB3aGVuIGFsbCB0aGUga25vd24gcm91dGVycyBmcm9tIHRoZSBjdXJyZW50IHJvdXRpbmcgdGFibGUgaGF2ZSBmYWlsZWQgYW5kIGRyaXZlciBuZWVkcyB0byBmYWxsYmFjayB0byB0aGUgaW5pdGlhbCBhZGRyZXNzXG4gICAgICAgICAqXG4gICAgICAgICAqICBJbiBOb2RlSlMgZW52aXJvbm1lbnQgZHJpdmVyIGRlZmF1bHRzIHRvIHBlcmZvcm1pbmcgYSBETlMgcmVzb2x1dGlvbiBvZiB0aGUgaW5pdGlhbCBhZGRyZXNzIHVzaW5nICdkbnMnIG1vZHVsZS5cbiAgICAgICAgICogIEluIGJyb3dzZXIgZW52aXJvbm1lbnQgZHJpdmVyIHVzZXMgdGhlIGluaXRpYWwgYWRkcmVzcyBhcy1pcy5cbiAgICAgICAgICogIFZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IC0gdGhlIGluaXRpYWwgYWRkcmVzcy4gSXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBuZXcgYWRkcmVzc2VzLlxuICAgICAgICAgKiAgQWRkcmVzcyBpcyBhIHN0cmluZyBvZiBzaGFwZSAnPGhvc3Q+Ojxwb3J0PicuIFByb3ZpZGVkIGZ1bmN0aW9uIGNhbiByZXR1cm4gZWl0aGVyIGEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIGFuIGFycmF5IG9mIGFkZHJlc3Nlc1xuICAgICAgICAgKiAgb3IgYXJyYXkgb2YgYWRkcmVzc2VzIGRpcmVjdGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oYWRkcmVzczogc3RyaW5nKSB7fSB8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZSBmaWx0ZXIgZm9yIE5vdGlmaWNhdGlvbiBvYmplY3RzIHJldHVybmVkIGluIHtAbGluayBSZXN1bHRTdW1tYXJ5I25vdGlmaWNhdGlvbnN9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUge0BsaW5rIFNlc3Npb25Db25maWcjbm90aWZpY2F0aW9uRmlsdGVyfSBmb3IgdXNhZ2UgaW5zdHJ1Y3Rpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Tm90aWZpY2F0aW9uRmlsdGVyfHVuZGVmaW5lZH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uRmlsdGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWxseSBvdmVycmlkZSB0aGUgZGVmYXVsdCB1c2VyIGFnZW50IG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqRGVmYXVsdCoqOiBgYGAnbmVvNGotamF2YXNjcmlwdC88dmVyc2lvbj4nYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGlmIHRlbGVtZXRyeSBjb2xsZWN0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCB0aGUgZHJpdmVyIHdpbGwgc2VuZCBhbm9ueW1vdXMgdXNhZ2Ugc3RhdGlzdGljcyB0byB0aGUgc2VydmVyIGl0IGNvbm5lY3RzIHRvIGlmIHRoZSBzZXJ2ZXIgcmVxdWVzdHMgdGhvc2UuXG4gICAgICAgICAqIEJ5IHNldHRpbmcgYGB0ZWxlbWV0cnlEaXNhYmxlZD10cnVlYGAsIHRoZSBkcml2ZXIgd2lsbCBub3Qgc2VuZCBhbnkgdGVsZW1ldHJ5IGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBkcml2ZXIgdHJhbnNtaXRzIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG4gICAgICAgICAqXG4gICAgICAgICAqIEV2ZXJ5IHRpbWUgb25lIG9mIHRoZSBmb2xsb3dpbmcgQVBJcyBpcyB1c2VkIHRvIGV4ZWN1dGUgYSBxdWVyeSAoZm9yIHRoZSBmaXJzdCB0aW1lKSwgdGhlIHNlcnZlciBpcyBpbmZvcm1lZCBvZiB0aGlzXG4gICAgICAgICAqICh3aXRob3V0IGFueSBmdXJ0aGVyIGluZm9ybWF0aW9uIGxpa2UgYXJndW1lbnRzLCBjbGllbnQgaWRlbnRpZmllcnMsIGV0Yy4pOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIHtAbGluayBEcml2ZXIjZXhlY3V0ZVF1ZXJ5fVxuICAgICAgICAgKiAqIHtAbGluayBTZXNzaW9uI3J1bn1cbiAgICAgICAgICogKiB7QGxpbmsgU2Vzc2lvbiNiZWdpblRyYW5zYWN0aW9ufVxuICAgICAgICAgKiAqIHtAbGluayBTZXNzaW9uI2V4ZWN1dGVSZWFkfVxuICAgICAgICAgKiAqIHtAbGluayBTZXNzaW9uI2V4ZWN1dGVXcml0ZX1cbiAgICAgICAgICogKiB7QGxpbmsgU2Vzc2lvbiN3cml0ZVRyYW5zYWN0aW9ufVxuICAgICAgICAgKiAqIHtAbGluayBTZXNzaW9uI3JlYWRUcmFuc2FjdGlvbn1cbiAgICAgICAgICogKiBUaGUgcmVhY3RpdmUgY291bnRlcnBhcnRzIG9mIG1ldGhvZHMgYWJvdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIE1ldHJpY3MgYXJlIG9ubHkgY29sbGVjdGVkIHdoZW4gZW5hYmxlZCBib3RoIGluIHNlcnZlciBhbmQgZHJpdmVyIGluc3RhbmNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogKipEZWZhdWx0Kio6IGBgYGZhbHNlYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZWxlbWV0cnlEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xpZW50IENlcnRpZmljYXRlIHVzZWQgZm9yIG11dHVhbCBUTFMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEge0BsaW5rIENsaWVudENlcnRpZmljYXRlUHJvdmlkZXJ9IGNhbiBiZSBjb25maWd1cmUgZm9yIHNjZW5hcmlvc1xuICAgICAgICAgKiB3aGVyZSB0aGUge0BsaW5rIENsaWVudENlcnRpZmljYXRlfSBtaWdodCBjaGFuZ2Ugb3ZlciB0aW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Q2xpZW50Q2VydGlmaWNhdGV8Q2xpZW50Q2VydGlmaWNhdGVQcm92aWRlcnx1bmRlZmluZWR9XG4gICAgICAgICAqIEBzaW5jZSA1LjI3XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWVudENlcnRpZmljYXRlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gQ29uZmlnO1xufSgpKTtcbmV4cG9ydHMuQ29uZmlnID0gQ29uZmlnO1xudmFyIEludGVybmFsQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnRlcm5hbENvbmZpZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnRlcm5hbENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW50ZXJuYWxDb25maWc7XG59KENvbmZpZykpO1xuZXhwb3J0cy5JbnRlcm5hbENvbmZpZyA9IEludGVybmFsQ29uZmlnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neo4j-driver-core/lib/types.js\n");

/***/ })

};
;